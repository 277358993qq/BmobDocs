{
    "docs": [
        {
            "location": "/index.html", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID和REST API Key后，下载SDK。\n\n\n安装BmobSDK\n\n\n一、把下面这行代码加入你的页面中，其中，\"bmob-min.js\"为SDK文件：\n\n\nscript src=\nbmob-min.js\n/script\n\n\n\n\n\n二、接着是加入下面这行代码进行初始化\n\n\nBmob.initialize(\n你的Application ID\n, \n你的REST API Key\n);\n\n\n\n\n\n添加一行数据\n\n\n添加数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var gameScore = new GameScore();\n    gameScore.set(\nscore\n, 1337);\n    gameScore.save(null, {\n      success: function(object) {\n        alert(\ncreate object success, object id:\n+object.id);\n      },\n      error: function(model, error) {\n        alert(\ncreate object fail\n);\n      }\n    });\n\n\n\n\n获取一行数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var query = new Bmob.Query(GameScore);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        alert(object.get(\nscore\n));\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n修改一行数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var query = new Bmob.Query(GameScore);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.set(\nscore\n, 1338);\n        object.save(null, {\n          success: function(objectUpdate) {\n            alert(\ncreate object success, object score:\n+objectUpdate.get(\nscore\n));\n          },\n          error: function(model, error) {\n            alert(\ncreate object fail\n);\n          }\n        });\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n删除一行数据\n\n\n    var GameScore = Bmob.Object.extend(\nGameScore\n);\n    var query = new Bmob.Query(GameScore);\n    query.get(\n4edc3f6ee9\n, {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.destroy({\n          success: function(deleteObject) {\n          alert(\ndelete success\n);\n          },\n          error: function(GameScoretest, error) {\n          alert(\ndelete fail\n);\n          }\n        });\n      },\n      error: function(object, error) {\n        alert(\nquery object fail\n);\n      }\n    });\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载", 
            "title": "快速入门"
        }, 
        {
            "location": "/index.html#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/index.html#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/index.html#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID和REST API Key后，下载SDK。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/index.html#bmobsdk", 
            "text": "一、把下面这行代码加入你的页面中，其中，\"bmob-min.js\"为SDK文件：  script src= bmob-min.js /script   二、接着是加入下面这行代码进行初始化  Bmob.initialize( 你的Application ID ,  你的REST API Key );", 
            "title": "安装BmobSDK"
        }, 
        {
            "location": "/index.html#_2", 
            "text": "添加数据      var GameScore = Bmob.Object.extend( GameScore );\n    var gameScore = new GameScore();\n    gameScore.set( score , 1337);\n    gameScore.save(null, {\n      success: function(object) {\n        alert( create object success, object id: +object.id);\n      },\n      error: function(model, error) {\n        alert( create object fail );\n      }\n    });", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/index.html#_3", 
            "text": "var GameScore = Bmob.Object.extend( GameScore );\n    var query = new Bmob.Query(GameScore);\n    query.get( 4edc3f6ee9 , {\n      success: function(object) {\n        // The object was retrieved successfully.\n        alert(object.get( score ));\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/index.html#_4", 
            "text": "var GameScore = Bmob.Object.extend( GameScore );\n    var query = new Bmob.Query(GameScore);\n    query.get( 4edc3f6ee9 , {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.set( score , 1338);\n        object.save(null, {\n          success: function(objectUpdate) {\n            alert( create object success, object score: +objectUpdate.get( score ));\n          },\n          error: function(model, error) {\n            alert( create object fail );\n          }\n        });\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/index.html#_5", 
            "text": "var GameScore = Bmob.Object.extend( GameScore );\n    var query = new Bmob.Query(GameScore);\n    query.get( 4edc3f6ee9 , {\n      success: function(object) {\n        // The object was retrieved successfully.\n        object.destroy({\n          success: function(deleteObject) {\n          alert( delete success );\n          },\n          error: function(GameScoretest, error) {\n          alert( delete fail );\n          }\n        });\n      },\n      error: function(object, error) {\n        alert( query object fail );\n      }\n    });", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/index.html#_6", 
            "text": "快速入门相关源码下载", 
            "title": "源码下载"
        }, 
        {
            "location": "/module/develop_doc/README/index.html", 
            "text": "简介\n\n\n\n\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n\n\n\n\nBmob的JavaScript SDK基于\nBackbone.js\n框架开发，在使用过程中除\nBmob.view\n类需要提供jQuery或者类似JQuery的\n$\n方法外，不需要再引入其他类库。\n\n\n\n\n\n\n典型案例\n\n\n聊天室：\nhttp://chatroom.bmob.cn\n （采用实时数据同步SDK开发，右击可直接查看源码）\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。\n\n\n对象\n\n\n数据对象\n\n\nBmob数据存储是建立在\nBmob.Object\n基础上的。如记录游戏成绩的\nBmob.Object\n示例如下：\n\n\nscore: 1337, playerName: \nbmob\n, cheatMode: false\n\n\n\n\n这里需要注意的是：\n\n\n\n\n键必须是字母或者数字的字符串，值可以是字符串、数字、布尔值或者数组和字典。\n\n\n每一个\nBmob.Object\n都是一个特定子类的实例，子类名可以来区分各种数据，如我们可以把记录游戏成绩的类称之为\nGameScore\n。\n\n\n\n\n创建对象\n\n\n你可以使用\nBmob.Object.extend\n方法来创建新的\nBmob.Object\n子类，示例代码如下：\n\n\n// 创建Bmob.Object子类\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\n\n// 创建该类的一个实例\nvar gameScore = new GameScore();\n\n\n\n\n\n如果你想为\nBmob.Object\n的子类添加一些实例方法和类方法，示例代码如下：\n\n\n// 为Bmob.Object的子类添加实例方法和类方法\nvar GameScore = Bmob.Object.extend(\nGameScore\n, {\n  //实例方法\n  gleaterThanOneHundred: function() {\n    return this.get(\nscore\n) \n 100;\n  }\n}, {\n  //类方法\n  spawn: function(score) {\n    var gameScore = new GameScore();\n    gameScore.set(\nscore\n, score);\n    return gameScore;\n  }\n});\n\nvar gameScore = GameScore.spawn(200);\nalert(gameScore.gleaterThanOneHundred()); \n\n\n\n\n添加数据\n\n\n添加数据非常简单，任何\nBmob.Object\n子类都有\nsave\n方法可以用于将当前对象的内容保存到服务端。示例代码如下：\n\n\n//创建类和实例\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar gameScore = new GameScore();\ngameScore.set(\nscore\n, 137);\ngameScore.set(\nplayerName\n, \nbmob\n);\ngameScore.set(\ncheatMode\n, false);\n//添加数据，第一个入口参数是null\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n    alert('添加数据成功，返回的objectId是：' + gameScore.id);\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n    alert('添加数据失败，返回错误信息：' + error.description);\n  }\n});\n\n\n\n\n你也可以用如下的示例代码添加数据：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar gameScore = new GameScore();\n// 添加数据，第一个入口参数是Json数据\ngameScore.save({\n  score: 1337,\n  playerName: \nbmob\n,\n  cheatMode: false\n}, {\n  success: function(gameScore) {\n    // 添加成功\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n  }\n});\n\n\n\n\n这里有几点需要注意的是:\n\n\n\n\n如果云端数据库中不存在\nGameScore\n表，Bmob会自动地在你第一次使用它的时候创建。\n\n\n每个\nBmob.Object\n对象都有几个默认的字段是自动创建的：\nobjectId\n是一个对于每一个保存的对象为一个标志；\ncreatedAt\n和\nupdatedAt\n表示对象在Bmob中创建和最后一次更改的时间。这些字段的创建和内容是由服务器端自动完成的，在保存\nBmob.Object\n之前不会存在。\n\n\n添加成功后，可以通过\ngameScore.createdAt\n获取对象的创建时间，通过\ngameScore.updatedAt\n获取对象的更新时间；可以通过\ngameScore.id\n获取对象的objectId。\n\n\n\n\n查询数据\n\n\n数据的查询是每个应用都会频繁使用到的，Bmob提供了\nBmob.Object\n类，方便大家实现不同条件的查询。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据是非常简单的，只需要使用\nBmob.Query\n的\nfind\n方法就可以了，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\n// 查询所有数据\nquery.find({\n  success: function(results) {\n    alert(\n共查询到 \n + results.length + \n 条记录\n);\n    // 循环处理查询到的数据\n    for (var i = 0; i \n results.length; i++) {\n      var object = results[i];\n      alert(object.id + ' - ' + object.get('playerName'));\n    }\n  },\n  error: function(error) {\n    alert(\n查询失败: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n如果你只想要一个结果，一个更加方便的方法是使用\nfirst\n，而不是\nfind\n方法，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\nquery.first({\n  success: function(object) {\n    // 查询成功\n  },\n  error: function(error) {\n    alert(\n查询失败: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这里需要注意一点的是：\n\n默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可\n点击查看分页查询\n一节。\n\n\n获取对象的特殊属性\n\n\n注意，在对象中获取objectId，createdAt，updatedAt的方法分别如下：\nobj.id\nobj.createdAt\nobj.updatedAt\n\n\n查询单条数据\n\n\n当我们知道某条数据的\nobjectId\n时，就可以根据\nobjectId\n值直接获取单条数据对象，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\n//创建查询对象，入口参数是对象类的实例\nvar query = new Bmob.Query(GameScore);\n//查询单条数据，第一个参数是这条数据的objectId值\nquery.get(\n82c3e62d2c\n, {\n  success: function(gameScore) {\n    // 查询成功，调用get方法获取对应属性的值\n    var score = gameScore.get(\nscore\n);\n    var playerName = gameScore.get(\nplayerName\n);\n    var cheatMode = gameScore.get(\ncheatMode\n);\n  },\n  error: function(object, error) {\n    // 查询失败\n  }\n});\n\n\n\n\n条件查询\n\n\n如果要查询某个属性等于某个值，示例代码如下：\n\n\nquery.equalTo(\nplayerName\n, \nbmob\n);\n\n\n\n\n如果要查询某个属性不等于某个值，示例代码如下：\n\n\nquery.notEqualTo(\nplayerName\n, \nbmob cloud\n);\n\n\n\n\n对查询的属性值进行大小比较的示例代码如下：\n\n\n// score \n 50\nquery.lessThan(\nscore\n, 50);\n\n// score \n= 50\nquery.lessThanOrEqualTo(\nscore\n, 50);\n\n// score \n 50\nquery.greaterThan(\nscore\n, 50);\n\n// score \n= 50\nquery.greaterThanOrEqualTo(\nscore\n, 50);\n\n\n\n\n两条查询语句一起写，就相当于\nAND\n查询，如下示例代码，查询同时满足\n\"playerName\"=\"bmob\" and \"score\"\n100\n的数据：\n\n\nquery.notEqualTo(\nplayerName\n, \nbmob\n);\nquery.greaterThan(\nscore\n, 100);\n\n\n\n\n一个完整的例子：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\nquery.equalTo(\nplayerName\n, \nbmob\n); \n// 查询所有数据\nquery.find({\n    success: function(results) {\n        alert(\n共查询到 \n + results.length + \n 条记录\n);\n        // 循环处理查询到的数据\n        for (var i = 0; i \n results.length; i++) {\n        var object = results[i];\n        alert(object.id + ' - ' + object.get('playerName'));\n        }\n    },\n    error: function(error) {\n        alert(\n查询失败: \n + error.code + \n \n + error.message);\n    }\n});\n\n\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用\nlimit\n方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为10，最大有效设置值1000（设置的数值超过1000还是视为1000）。\n\n\n// 返回最多10条数据\nquery.limit(10); \n\n\n\n\n在数据较多的情况下，在\nlimit\n的基础上分页显示数据是比较合理的解决办法，\nskip\n方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下\nskip\n的值为10。\n\n\nquery.skip(10); // skip the first 10 results\n\n\n\n\n结果排序\n\n\n我们可以对返回的结果进行排序（只支持\nnumber\n和\nstring\n类型的排序），示例代码如下：\n\n\n// 对score字段升序排列\nquery.ascending(\nscore\n);\n\n// 对score字段降序排列\nquery.descending(\nscore\n);\n\n\n\n\n统计记录数量\n\n\n如果你只是想统计满足\nquery\n的结果集到底有多条记录，你可以使用\ncount\n方法。如为了获得GameScore表的记录数量，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\nquery.count({\n  success: function(count) {\n    // 查询成功，返回记录数量\n    alert(\n共有 \n + count + \n 条记录\n);\n  },\n  error: function(error) {\n    // 查询失败\n  }\n});\n\n\n\n\n\n复杂查询\n\n\n如果你想查询某一字段值在某一集合中的记录的话，可以使用\ncontainedIn\n方法，如获取\n\"Bmob\"、\"Codenow\"、\"JS\"\n这三位玩家的记录信息，那么示例代码如下：\n\n\n// 第一个参数是字段名称，第二个参数是数组\nquery.containedIn(\nplayerName\n, [\nBmob\n, \nCodenow\n, \nJS\n]);\n\n\n\n\n\n相反地，你可以使用\nnotContainedIn\n方法来查询在集合外的目标对象。\n\n\n如果想要查询含有某一特定属性的对象，可以使用\nexists\n。相对地，如果你想获取没有这一特定属性的对象，你可以使用\ndoesNotExist\n，示例代码如下：\n\n\n// 查询含有score属性的对象\nquery.exists(\nscore\n);\n\n// 查询不含有score属性的对象\nquery.doesNotExist(\nscore\n);\n\n\n\n\n你可以使用\nmatchesKeyInQuery\n方法来进行嵌套的子查询。举例说，如果你有一个类包含了运动队， 而你在用户类中存储了用户的家乡信息，你可以构造一个查询来查找某地的运动队有赢的记录的用户，示例代码如下：\n\n\nvar Team = Bmob.Object.extend(\nTeam\n);\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan(\nwinPct\n, 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.matchesKeyInQuery(\nhometown\n, \ncity\n, teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});\n\n\n\n\n相对地，可以使用\ndoesNotMatchKeyInQuery\n来获取属性不在子查询结果中的对象。比如为了获得用户的家乡队输了的情况：\n\n\nvar Team = Bmob.Object.extend(\nTeam\n);\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan(\nwinPct\n, 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.doesNotMatchKeyInQuery(\nhometown\n, \ncity\n, teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});\n\n\n\n\n查询指定列\n\n\n有时候你不想返回所有的字段信息，那么就可以用\nselect\n方法来限定返回的字段。示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\n// 只返回score和playerName字段值\nquery.select(\nscore\n, \nplayerName\n);\nquery.find().then(function(results) {\n  // 返回成功\n});\n\n\n\n\n注意：系统默认的字段\nobjectId\n、\ncreatedAt\n、\nupdatedAt\n、\nACL\n也会返回。\n\n\n对字符串类型做查询\n\n\n如果想要查询以某一个特定字符串开头的记录，可以使用\nstartWith\n方法，示例代码如下：\n\n\n// 查询在playerName字段中以bm开头的记录\nvar query = new Bmob.Query(GameScore);\nquery.startsWith(\nplayerName\n, \nbm\n);\n\n\n\n\n或查询\n\n\n你可以使用\nBmob.Query.or\n方法操作或查询，示例代码如下：\n\n\nvar lotsOfWins = new Bmob.Query(GameScore);\nlotsOfWins.greaterThan(\nscore\n, 150);\n\nvar fewWins = new Bmob.Query(GameScore);\nfewWins.lessThan(\nscore\n, 5);\n\nvar mainQuery = Bmob.Query.or(lotsOfWins, fewWins);\nmainQuery.find({\n  success: function(results) {\n     // 返回 score \n 150 or score \n 5 的值\n  },\n  error: function(error) {\n    // 返回失败\n  }\n});\n\n\n\n\n注意：我们不会在组合查询的子查询中支持非过滤型的条件 (比如:limit,skip,ascending/descending,include)\n\n\n修改数据\n\n\n修改数据非常简单，首先需要获取到要更新的\nBmob.Object\n对象，修改值后保存数据就可以了，示例代码如下：\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar query = new Bmob.Query(GameScore);\n\n// 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\nquery.get('3453453453fdsdf', {\n    success: function(gameScore) {\n      // 回调中可以取得这个 GameScore 对象的一个实例，然后就可以修改它了\n      gameScore.set('title', 'test!');\n      gameScore.save();\n\n      // The object was retrieved successfully.\n    },\n    error: function(object, error) {\n\n    }\n});\n\n\n\n\n或者\n\n\nvar GameScore = Bmob.Object.extend(\nGameScore\n);\nvar gameScore = new GameScore();\ngameScore.set(\ncheatMode\n, true);\ngameScore.set(\nscore\n, 1338);\n//添加数据\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 修改数据\n    gameScore.set(\ncheatMode\n, true);\n    gameScore.set(\nscore\n, 1338);\n    gameScore.save();\n  }\n})\n\n\n\n\n如果想更新成功后获取更新后的对象属性，请设置\nfetchWhenSave\n：\n\n\n //假设gamescore是已经存在的对象\n    gameScore.fetchWhenSave(true);\n    gameScore.set(\ncheatMode\n, true);\n    gameScore.set(\nscore\n, 1338);\n    gameScore.save();\n\n\n\n\n删除数据\n\n\n删除数据可以使用\nBmob.Object\n的\ndestroy\n方法，示例代码如下：\n\n\nmyObject.destroy({\n  success: function(myObject) {\n    // 删除成功\n  },\n  error: function(myObject, error) {\n    // 删除失败\n  }\n});\n\n\n\n\n\n删除字段\n\n\n你可以使用\nunset\n方法在删除一个字段：\n\n\n// 删除playerName字段\nmyObject.unset(\nplayerName\n);\nmyObject.save();\n\n\n\n\n常见数据类型的操作\n\n\nvar number = 42;\nvar string = \nthe number is \n + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set(\nmyNumber\n, number);\nbigObject.set(\nmyString\n, string);\nbigObject.set(\nmyDate\n, date);\nbigObject.set(\nmyArray\n, array);\nbigObject.set(\nmyObject\n, object);\nbigObject.set(\nmyNull\n, null);\nbigObject.save();\n\n\n\n\n数组操作\n\n\n添加及更新数组\n\n\n为了帮你存储数组类数据，有三种操作你可以原子性地改动一个数组，这需要一个给定的 key：\n\n\n\n\nadd\n在一个数组的末尾加入一个给定的对象。\n\n\naddUnique\n只会把原本不存在的对象加入数组，所以加入的位置没有保证。\n\n\n\n\n比如, 我们想在数组\"skills\"中加入项目：\n\n\ngameScore.addUnique(\nskills\n, \nflying\n);\ngameScore.addUnique(\nskills\n, \nkungfu\n);\ngameScore.save();\n\n\n\n\n数组查询\n\n\n对于value是数组的情况，你可以这样查询数组中的值有\n2\n的情况的对象：\n\n\n// Find objects where the array in arrayKey contains 2.\nquery.equalTo(\narrayKey\n, 2);\n\n\n\n\n你同样可以用下面的方式找到同时包含元素\n2、3、4\n的数组：\n\n\n// Find objects where the array in arrayKey contains all of the elements 2, 3, and 4.\nquery.containsAll(\narrayKey\n, [2, 3, 4]);\n\n\n\n\n删除数组\n\n\nremove\n在一个数组中删除所有指定的所有实例：\n\n\nvar GameScoretest = Bmob.Object.extend(\nGameScoretest\n);\nvar query = new Bmob.Query(GameScoretest);\nquery.get(\nbc5da708dc\n,{\n  success: function(gameScore) {\n    gameScore.remove(\nskills\n,\ntest\n);\n    gameScore.save();\n  },\n  error: function(error) {\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n}); \n\n\n\n\n数据关联\n\n\n添加及修改关联关系\n\n\n一对一关系和一对多关系\n\n\n一对一关系和一对多关系都可以通过在一个\nBmob.Object\n内保存另一个对象来实现。比如，每一个 Comment都对应了一个Post，创建一个有一个Comment的Post，你可以这样写：\n\n\n// Declare the types.\nvar Post = Bmob.Object.extend(\nPost\n);\nvar Comment = Bmob.Object.extend(\nComment\n);\n\n// Create the post\nvar myPost = new Post();\nmyPost.set(\ntitle\n, \nI'm Hungry\n);\nmyPost.set(\ncontent\n, \nWhere should we go for lunch?\n);\n\n// Create the comment\nvar myComment = new Comment();\nmyComment.set(\ncontent\n, \nLet's do Sushirrito.\n);\n\n// Add the post as a value in the comment\nmyComment.set(\nparent\n, myPost);\n\n// This will save both myPost and myComment\nmyComment.save();\n\n\n\n\nBmob内部会自动处理，调用Comment的\nsave\n方法就可以同时保存两个新对象。\n\n\n如果是现有对象想要关联到新对象，你同样可以通过只用它们的\nobjectId\n来连接彼此。请注意，不能直接像上面的例子那样将现有对象设置进去，而是必须\nnew\n一个新对象并只设置\nid\n属性：\n\n\nvar post = Bmob.Object.createWithoutData(\nPost\n, \n320b0395f3\n);\nmyComment.set(\nparent\n, post);\n\n\n\n\n或者：\n\n\nvar post = new Post();\npost.id = '520c7e1ae4b0a3ac9ebe326a';\nmyComment.set(\nparent\n, post);\n\n\n\n\n默认情况下，当获取一个对象时，关联的\nBmob.Object\n不会被获取到，这些对象的值不能访问，除非像下面这样获取它们：\n\n\nvar post = fetchedComment.get(\nparent\n);\npost.fetch({\n  success: function(post) {\n    var title = post.get(\ntitle\n);\n  }\n});\n\n\n\n\n多对多关系\n\n\n多对多关系是通过\nBmob.Relation\n来建模的，这样很像在一个key中存储一个\nBmob.Object\n数组，但是你不需要一次性下载关系中的所有对象。这使得\nBmob.Relation\n比数组可以更好地扩展到更多对象。例如，一个User可能喜欢很多Post，在这种情况下，你可以把一个用户喜欢的所有Post存为一个Relation，为了将一个Post加入一个User的like列表，你可以：\n\n\nvar user = Bmob.User.current();\nvar relation = user.relation(\nlikes\n);\nrelation.add(post);\nuser.save();\n\n\n\n\n你还可以传入一个\nBmob.Object\n数组来做\nadd\n和\nremove\n：\n\n\nrelation.add([post1, post2, post3]);\nuser.save();\n\n\n\n\n查询关联关系\n\n\n默认情况下，\nrelation\n关联的对象并不会被下载，你可以通过使用\nquery\n方法返回的\nBmob.Query\n对象来获取\nBmob.Object\n的列表，例如：\n\n\nrelation.query().find({\n  success: function(list) {\n    // list contains the posts that the current user likes.\n  }\n});\n\n\n\n\n如果你仅仅要一个Post的子集，你可以在\nBmob.Query\n中加入更多的条件：\n\n\nvar query = relation.query();\nquery.equalTo(\ntitle\n, \nI'm Hungry\n);\nquery.find({\n  success:function(list) {\n    // list contains post liked by the current user which have the title \nI'm Hungry\n.\n  }\n});\n\n\n\n\n如果希望查询结果中包含多个相关联的其他数据类型。你可以使用 include 方 法。例如有个comments，你可能想同时获取它们相关的 post 数据:\n\n\nvar query = new Bmob.Query(Comment);\n\nquery.include(\npost\n);\n\n\n\n\n你可以在接下来关于\nBmob.Query\n的章节中看到更详细的内容。一个\nBmob.Relation\n的行为很像一个\nBmob.Object\n数组，所以任何在数组可做的查询操作，也都可以作用在\nBmob.Relation\n上。\n\n\n如果你知道post，想反向查询user，可以通过\nBmob.Relation.reverseQuery\n方法：\n\n\nvar query = Bmob.Relation.reverseQuery('_User', 'likes', post);\nquery.find({\n  success:function(users) {\n   //users是表示喜欢这个post的用户列表。\n  }\n});\n\n\n\n\n删除关联关系\n\n\n你可以从一个\nBmob.Relation\n中删除一个post：\n\n\nrelation.remove(post);\nuser.save();\n\n\n\n\n你可以在用\nsave\n方法保存前多次调用\nadd\n和\nremove\n方法：\n\n\nrelation.remove(post1);\nrelation.remove(post2);\nuser.save();\n\n\n\n\n原子计数器\n\n\n许多应用都需要维持一些计数器数据，譬如用来跟踪游戏分数、金币甚至道具的数目等等。Bmob提供了便捷的方式来对任何数字字段进行原子性的增加或者减少：\n\n\ngameScore.increment(\nscore\n);\ngameScore.save();\n\n\n\n\n你可以同样传入第二个参数到\nincrement\n方法来指定增加多少，\n1\n是默认值。\n\n\n文件\n\n\n整个文件上传\n\n\n上传文件有两种方法：\n\n\n直接上传文件，例如，我们上传一个内容为\"Hello, World!\"，名称为\"hello.txt\"的文件，可用如下的代码：\n\n\nvar bytes = \nHello, World!\n;\nvar file = new Bmob.File(\nhello.txt\n, bytes);\nfile.save().then(function(obj) {\n  //alert(obj.url());\n}, function(error) {\n  // the save failed.\n});\n\n\n\n\n最经常的对于HTML5的应用来说，可能需要用html表单和一个文件上传控制器。在现代的浏览器中这很容易，只需要创建一个file input tag来允许用户选择他们磁盘上的文件就可以了。\n\n\ninput type=\nfile\n id=\nprofilePhotoFileUpload\n\n\n\n\n\n然后，在一个处理\nclick\n或其他的函数里，获取对那个文件的一个引用：\n\n\n        var fileUploadControl = $(\n#profilePhotoFileUpload\n)[0];\n        if (fileUploadControl.files.length \n 0) {\n        var file = fileUploadControl.files[0];\n        var name = \nlogo.jpg\n;\n        var file = new Bmob.File(name, file);     \n        file.save();\n\n\n\n\n文件删除\n\n\n  file.destroy(); //删除文件\n\n\n\n\n\n图片处理\n\n\n提供一些工具接口，方便开发者处理图片。\n\n\n缩微图\n\n\n提供原图的URL地址和相应的参数， 返回缩微图的URL地址， 具体参数定义如下：\n\n\nmode:模式 0: 指定宽， 高自适应，等比例缩放\n     模式 1: 指定高， 宽自适应，等比例缩放\n     模式 2: 指定最长边，短边自适应，等比例缩放\n     模式 3: 指定最短边，长边自适应，等比例缩放\n     模式 4: 指定最大宽高， 等比例缩放\n     模式 5: 固定宽高， 居中裁剪    \nimage:原图片url\nwidth:宽度，模式 0, 4, 5必填\nheight：高度，模式 1, 4, 5必填\nlongEdge：长边，模式 2必填\nshortEdge：短边，模式 3必填\nquality：质量，选填, 范围 1-100\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流\n\n\n\n\n调用的代码：\n\n\nBmob.Image.thumbnail({\nimage\n:\nhttp://file.bmob.cn/M00/01/26/wKgBP1OX9LLVh5gNAAHGYsmKRjk666.jpg\n,\nmode\n:0,\nquality\n:100,\nwidth\n:100}\n\n  ).then(function(obj) {\n\n  alert(\nfilename:\n+obj.filename); //\n  alert(\nurl:\n+obj.url); //\n});\n\n\n\n\n\n如果\noutType = 0\n返回云端url地址:\n\n\n{\n  \nfilename\n: \ne6c8ac18c9.jpg\n,\n  \ngroup\n: \ngroup1\n,\n  \nurl\n: \nM00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg\n\n}\n\n\n\n\n如果 \noutType = 1\n 返回文件内容的 base64 字符串：\n\n\n{\n  \nfile\n:\nbase64的文件内容\n\n}\n\n\n\n\n水印图\n\n\n提供原图的URL地址，水印图的URL地址和相应的参数，返回缩微图的URL地址，具体参数定义如下：\n\n\nimage：原图路径\nwatermark：水印图路径\ndissolve:透明度，0-255\ndistanceX：横轴边距，单位:像素(px)，缺省值为10\ndistanceY：纵轴边距，单位:像素(px)，缺省值为10\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流\ngravity:水印位置，见下图\n\n\n\n\n\n\n调用的代码：\n\n\n//get image thumbnail\nBmob.Image.watermark({\nimage\n:\nhttp://test.com/new/images/banner005.jpg\n,\nwatermark\n:\nhttp://test.com/new/images/header2.png\n,\ndissolve\n:100,\ngravity\n:\nSouthWest\n,\ndistanceX\n:10,\ndistanceY\n:10}\n\n  ).then(function(obj) {\n\n  alert(\nfilename:\n+obj.filename); //\n  alert(\nurl:\n+obj.url); //\n});\n\n\n\n\n\n如果 \noutType = 0\n 返回云端url地址:\n\n\n{\n  \nfilename\n: \ne6c8ac18c9.jpg\n,\n  \ngroup\n: \ngroup1\n,\n  \nurl\n: \nM00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg\n\n}\n\n\n\n\n如果 \noutType = 1\n 返回文件内容的 base64 字符串：\n\n\n{\n  \nfile\n:\nbase64的文件内容\n\n}\n\n\n\n\nPromise\n\n\n除了回调函数之外，每一个在Bmob JavaScript SDK中的异步方法都会返回一个 Promise. 使用 Promise，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多.\n\n\nthen 方法\n\n\n每一个\nPromise\n都有一个叫\nthen\n的方法, 这个方法接受一对\ncallback\n。第一个\ncallback\n在\npromise\n被解决的时候调用，第二个会在\npromise\n被拒绝的时候调用。\n\n\nobj.save().then(function(obj) {\n  // the object was saved successfully.\n}, function(error) {\n  // the save failed.\n});\n\n\n\n\n将Promise 组织在一起\n\n\nPromise\n比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。 如果一个\nPromise\n的回调会返回一个\nPromise\n，那么第二个\nthen\n里的\ncallback\n在第一个\nthen\n的\ncallback\n没有解决前是不会解决的。\n\n\nvar query = new Bmob.Query(\nStudent\n);\nquery.descending(\ngpa\n);\nquery.find().then(function(students) {\n  students[0].set(\nvaledictorian\n, true);\n  return students[0].save();\n\n}).then(function(valedictorian) {\n  return query.find();\n\n}).then(function(students) {\n  students[1].set(\nsalutatorian\n, true);\n  return students[1].save();\n\n}).then(function(salutatorian) {\n  // Everything is done!\n\n});\n\n\n\n\n错误处理\n\n\n如果任意一个在链中的\nPromise\n返回一个错误的话，所有的成功的\ncallback\n在接下来都会被跳过直到遇到一个处理错误的\ncallback\n。处理\nerror\n的\ncallback\n可以转换\nerror\n或者可以通过返回一个新的\nPromise\n的方式来处理它。你可以想象成拒绝的\npromise\n有点像异常，而\nerror callback\n则像是一个\ncatch\n来处理这个异常或者抛出异常。\n\n\nvar query = new Bmob.Query(\nStudent\n);\nquery.descending(\ngpa\n);\nquery.find().then(function(students) {\n  students[0].set(\nvaledictorian\n, true);\n  // Force this callback to fail.\n  return Bmob.Promise.error(\nThere was an error.\n);\n\n}).then(function(valedictorian) {\n  // Now this will be skipped.\n  return query.find();\n\n}).then(function(students) {\n  // This will also be skipped.\n  students[1].set(\nsalutatorian\n, true);\n  return students[1].save();\n}, function(error) {\n  // This error handler WILL be called. error will be \nThere was an error.\n.\n  // Let's handle the error by returning a new promise.\n  return Bmob.Promise.as(\nHello!\n);\n\n}).then(function(hello) {\n  // Everything is done!\n}, function(error) {\n  // This isn't called because the error was already handled.\n});\n\n\n\n\n通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数会是很方便的做法.\n\n\n创建 Promise\n\n\n在开始阶段，你可以只用系统（譬如\nfind\n和\nsave\n方法等）返回的\npromise\n。但在更高级的场景下，你可能需要创建自己的\npromise\n。在创建了\nPromise\n之后，你需要调用\nresolve\n或者\nreject\n来触发它的\ncallback\n。\n\n\nvar successful = new Bmob.Promise();\nsuccessful.resolve(\nThe good result.\n);\n\nvar failed = new Bmob.Promise();\nfailed.reject(\nAn error message.\n);\n\n\n\n\n如果你在创建\npromise\n的时候就知道它的结果，下面有两个很方便的方法可以使用：\n\n\nvar successful = Bmob.Promise.as(\nThe good result.\n);\nvar failed = Bmob.Promise.error(\nAn error message.\n);\n\n\n\n\n顺序的Promise\n\n\nvar query = new Bmob.Query(\nComments\n);\nquery.equalTo(\npost\n, 123);\n\nquery.find().then(function(results) {\n  // Create a trivial resolved promise as a base case.\n  var promise = Bmob.Promise.as();\n  _.each(results, function(result) {\n    // For each item, extend the promise with a function to delete it.\n    promise = promise.then(function() {\n      // Return a promise that will be resolved when the delete is finished.\n      return result.destroy();\n    });\n  });\n  return promise;\n\n}).then(function() {\n  // Every comment was deleted.\n});\n\n\n\n\n并行的Promise\n\n\n你也可以用\nPromise\n来并行的进行多个任务，这时需要使用\nwhen\n方法。你可以一次同时开始几个操作，使用\nBmob.Promise.when\n来创建一个新的\npromise\n，它会在所有输入的\nPromise\n被解决之后才被解决。即便一些输入的\npromise\n失败了，新的\nPromise\n也会被成功执行。你可以在 \ncallback\n的参数部分检查每一个\npromise\n的结果，并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。\n\n\nvar query = new Bmob.Query(\nComments\n);\nquery.equalTo(\npost\n, 123);\n\nquery.find().then(function(results) {\n  // Collect one promise for each delete into an array.\n  var promises = [];\n  _.each(results, function(result) {\n    // Start this delete immediately and add its promise to the list.\n    promises.push(result.destroy());\n  });\n  // Return a new promise that is resolved when all of the deletes are finished.\n  return Bmob.Promise.when(promises);\n\n}).then(function() {\n  // Every comment was deleted.\n});\n\n\n\n\n创建异步方法\n\n\n有了上面这些工具以后, 就很容易创建你自己的异步方法来返回\npromise\n了。举例说，你可以创建一个有\npromise\n版本的\nsetTimeout\n。\n\n\nvar delay = function(millis) {\n  var promise = new Bmob.Promise();\n  setTimeout(function() {\n    promise.resolve();\n  }, millis);\n  return promise;\n};\n\ndelay(100).then(function() {\n  // This ran after 100ms!\n});\n\n\n\n\nCollection\n\n\n一个\nBmob.Collection\n就是一个\nBmob.Objects\n的有序集合，它和\nBackbone.Collection\n是兼容的，有相同的特性和功能，你可以通过用一个模型类或者一个特定的\nBmob.Query\n来创建一个新的子类。\n\n\n// A Collection containing all instances of TestObject.\nvar TestCollection = Bmob.Collection.extend({\n  model: TestObject\n});\nvar collection = new TestCollection();\n\n// A Collection of TestObjects whose temperature is \nhot\n.\nvar HotCollection = Bmob.Collection.extend({\n  model: TestObject,\n  query: (new Bmob.Query(TestObject)).equalTo(\ntemperature\n, \nhot\n)\n});\nvar collection = new HotCollection();\n\n// The Collection of TestObjects that match a complex query.\nvar query = new Bmob.Query(TestObject);\nquery.equalTo(\ntemperature\n, \nhot\n);\nquery.greaterThan(\ndegreesF\n, 100);\nvar collection = query.collection();\n\n\n\n\n获取Collection\n\n\n使用\nfetch\n方法来获取一个\ncollection\n里的所有元素:\n\n\nvar collection = new TestCollection();\ncollection.fetch({\n  success: function(collection) {\n    collection.each(function(object) {\n      console.warn(object);\n    });\n  },\n  error: function(collection, error) {\n    // The collection could not be retrieved.\n  }\n});\n\n\n\n\nCollection 排序\n\n\n你可以设定一个\ncomparator\n来对\ncollection\n中的元素进行排序:\n\n\nvar collection = new TestCollection();\ncollection.comparator = function(object) {\n  return object.get(\ntemperature\n);\n};\n\n\n\n\n修改一个 Collection\n\n\nCollection\n是可变的，你可以访问所有元素，增加或者删除元素：\n\n\nvar collection = new TestCollection();\n\ncollection.add([\n  {\nname\n: \nDuke\n},\n  {\nname\n: \nScarlett\n}\n]);\n\n// Get the \nDuke\n Bmob.Object by its sorted position.\nvar model = collection.at(0);\n\n// Or you can get it by Bmob objectId.\nvar modelAgain = collection.get(model.id);\n\n// Remove \nDuke\n from the collection.\ncollection.remove(model);\n\n// Completely replace all items in the collection.\ncollection.reset([\n  {\nname\n: \nHawk\n},\n  {\nname\n: \nJane\n}\n]);\n\n\n\n\n用户\n\n\n在许多应用中，都有一个用户账户的概念，用户账户让用户可以用安全的方式访问他们自己的信息。我们提供了一个特殊的用户类叫\nBmob.User\n来自动处理有关用户的账户管理的功能。\n\n\nBmob.User\n是\nBmob.Object\n的一个子类，而且有\nBmob.Object\n一样的功能，比如可变的模式、自动的持久化、键值对接口等。所有对\nBmob.Object\n有用的方法同样可以作用于\nBmob.User\n。\nBmob.User\n的不同之处在于\nBmob.User\n对于用户的账户有一些特定的功能。\n\n\n属性\n\n\nBmob.User\n有一些与\nBmob.Object\n不一样的字段:\n\n\nusername\n：用户的用户名（必须提供）\n\npassword\n：用户的密码（在注册的时候必须提供）\n\nemail\n：用户的 email（可选）\n我们会在下面的用例中详细介绍细节\n\n\n注册\n\n\n通常你的app第一件要做的事情就是让用户进行注册，下面的代码展示了怎样进行通常的注册过程：\n\n\nvar user = new Bmob.User();\nuser.set(\nusername\n, \nmy name\n);\nuser.set(\npassword\n, \nmy pass\n);\nuser.set(\nemail\n, \nemail@example.com\n);\n\n// other fields can be set just like with Bmob.Object\nuser.set(\nphone\n, \n415-392-0202\n);\n\nuser.signUp(null, {\n  success: function(user) {\n    // Hooray! Let them use the app now.\n  },\n  error: function(user, error) {\n    // Show the error message somewhere and let the user try again.\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这个调用会异步地在在你的应用中创建一个新的用户。在它这样做之前，它同样会确认用户名和\nemail\n在应用内都是唯一的。同样，我们从不会将用户密码以明文向任何客户端发送。\n\n\n注意我们使用了\nsignUp\n方法而不是\nsave\n方法，新的\nBmob.User\n永远应该使用\nsignUp\n方法来新建。而随后的用户的信息更新可以调用\nsave\n来做。\n\n\n如果一个\nsignup\n没有成功的话，你应该读取返回的错误对象。最常见的问题是\nusername\n或者\nemail\n已经被其他用户所使用了。你应该清楚地反馈给你的用户，让他们再次用一个不同的用户名来注册。\n\n\n你也可以使用\nemail\n来作为用户名，只要求你的用户输入他们的\nemail\n但是同时自动填充好\nusername\n属性就可以了，\nBmob.User\n会跟原来一样工作，我们会在下面的重设密码环节再次说明这个细节。\n\n\n登录\n\n\n在你要求你的用户注册之后，当然应该让他们在以后用自己的账户登录进来，你可以使用\nlogIn\n方法来进行登陆：\n\n\nBmob.User.logIn(\nmyname\n, \nmypass\n, {\n  success: function(user) {\n    // Do stuff after successful login.\n  },\n  error: function(user, error) {\n    // The login failed. Check error to see why.\n  }\n});\n\n\n\n\n验证 Email\n\n\n在application设置中启用email验证可以让你的应用给最终用户一些更安全的使用体验，譬如部分功能只开放给验证过邮箱的用户使用等等。Email验证会在\nBmob.User\n上加入一个\nemailVerified\n字段。当一个\nBmob.User\n的\nemail\n被设定或者修改后,\nemailVerfied\n会被设定为\nfalse\n。Bmob 会向用户的\nemail\n来发送一个链接，点击这个链接会设置\nemailVerified\n为\ntrue\n：\n\n\n有三种\nemailVerified\n状态可以供参考：\n\n\n\n\ntrue\n：用户已经通过点击Bmob发过来的链接来确认邮箱地址. 当用户账户新创建的时候这个值永远不应该是true。\n\n\nfalse\n：在 \nBmob.User\n对象最后一次刷新的时候，用户还是没有确认他们的\nemail\n地址，如果\nemailVerified\n是false 的话，你应该考虑调用\nBmob.User\n的\nfetch\n方法。\n\n\nmissing\n：\nBmob.User\n被创建了，但是当时的\nemail\n验证功能还没有开启, 或者说\nBmob.User\n没有email地址。\n\n\n\n\n代码例子如下：\n\n\n//reset password\n Bmob.User.requestEmailVerify(\nh6k65@126.com\n, {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n当前用户\n\n\n如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的\nBmob.User\n对象来避免这个问题。\n\n\n无论你使用任何注册或者登录方法，用户都会在\nlocalStorage\n中储存，你可以把缓存作为一个\nsession\n对待，并且自动假设用户已经登录了。\n\n\nvar currentUser = Bmob.User.current();\nif (currentUser) {\n    // do stuff with the user\n} else {\n    // show the signup or login page\n}\n\n\n\n\n你可以通过\nlogout\n来清除掉当前的用户：\n\n\nBmob.User.logOut();\n\nvar currentUser = Bmob.User.current();  // this will now be null\n\n\n\n\n用户对象的安全\n\n\nBmob.User\n类默认就是受保护的，在\nBmob.User\n中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些\nBmob.User\n对象被认证后是可以修改的，其他的仍然是只读的。\n\n\n特别的，你不能调用\nsave\n或者\ndelete\n方法除非\nBmob.User\n经过了认证，就比如调用过了\nlogIn\n或者\nsignUp\n方法，这样保证只有用户能改动他们自身的数据。\n\n\n下面的代码展示了上面说的安全策略：\n\n\nvar user = Bmob.User.logIn(\nmy_username\n, \nmy_password\n, {\n  success: function(user) {\n    user.set(\nusername\n, \nmy_new_username\n);  // attempt to change username\n    user.save(null, {\n      success: function(user) {\n        // This succeeds, since the user was authenticated on the device\n\n        // Get the user from a non-authenticated method\n        var query = new Bmob.Query(Bmob.User);\n        query.get(user.objectId, {\n          success: function(userAgain) {\n            userAgain.set(\nusername\n, \nanother_username\n);\n            userAgain.save(null, {\n              error: function(userAgain, error) {\n                // This will error, since the Bmob.User is not authenticated\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n});\n\n\n\n\n从\nBmob.User.current()\n获取的\nBmob.User\n总是已经通过验证了的。\n\n\n如果你需要查看一个\nBmob.User\n是否已经认证过了，你可以调用\nauthenticated\n方法，你不需要查看一个认证方法中返回的\nBmob.User\n对象是否已经通过验证了。\n\n\n其他对象的安全\n\n\n和\nBmob.User\n相同的安全模型也使用于其他对象。对于任何对象来说，你可以指定哪些用户会被允许读取对象，哪些用户被允许修改对象。为了支持这种安全机制，每一个对象都有一个允许访问列表 (ACL)，是被\nBmob.ACL\n类所实现的。\n\n\n使用一个\nBmob.ACL\n最简单的方式是指定一个对象只能被一个单一的用户读或者写。为了创建这样的对象，首先必须有一个已经登录的\nBmob.User\n。然后，新的\nBmob.ACL(user)\n生成一个\nBmob.ACL\n来限定\nuser\n的访问。一个对象的ACL会在对象保存的时候被存储起来，就像其他的属性一样，这样，为了创建一个当前user私有的一个note：\n\n\nvar Note = Bmob.Object.extend(\nNote\n);\nvar privateNote = new Note();\nprivateNote.set(\ncontent\n, \nThis note is private!\n);\nprivateNote.setACL(new Bmob.ACL(Bmob.User.current()));\nprivateNote.save();\n\n\n\n\n这个note只能由当前的用户所访问，但是可以在用户登录的任何设备上访问，只要是相同的用户就可以了。这项功能对于你如果想让用户再任何其他的设备上保存和访问数据十分有用，比如说一个私人的todo list应用。\n\n\n权限也能在使用者的基础上授予，你可以通过\nsetReadAccess\n和\nsetWriteAccess\n方法独立的向\nBmob.ACL\n中添加权限。比如，假设你有一条消息想要发送给一个组里的多个用户，他们中的每一个都有读和写的权限：\n\n\nvar Message = Bmob.Object.extend(\nMessage\n);\nvar groupMessage = new Message();\nvar groupACL = new Bmob.ACL();\n\n// userList is an array with the users we are sending this message to.\nfor (var i = 0; i \n userList.length; i++) {\n  groupACL.setReadAccess(userList[i], true);\n  groupACL.setWriteAccess(userList[i], true);\n}\n\ngroupMessage.setACL(groupACL);\ngroupMessage.save();\n\n\n\n\n你同样可以对所有的用户授权，只要使用\nsetPublicReadAccess\n和\nsetPublicWriteAccess\n就可以了。这样允许了在一个消息板上发评论的模式，比如，我们要创建一个post只能被它的作者修改，但是可以被所有人读取：\n\n\nvar publicPost = new Post();\nvar postACL = new Bmob.ACL(Bmob.User.current());\npostACL.setPublicReadAccess(true);\npublicPost.setACL(postACL);\npublicPost.save();\n\n\n\n\n比如说删除一个对象，但是你没有写的权限这种操作是禁止的，这样会返回一个\nBmob.Error.OBJECT_NOT_FOUND\n的错误码，为了安全起见，这样防止了客户端区分出到底有哪些对象被创建了但是无法读取还是根本不存在。\n\n\n重设密码\n\n\n在现实中只要你引入了密码系统，总会有用户会忘掉他们的密码。在这种情形下，我们的库提供一个让他们安全地重设密码的功能。\n\n\n为了能让用户重设密码，应该要求用户提供他们的email地址，然后这样调用：\n\n\n Bmob.User.requestPasswordReset(\ntest@126.com\n, {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert(\nError: \n + error.code + \n \n + error.message);\n  }\n});\n\n\n\n\n这样会尝试匹配给定的email和用户的email或者username字段，然后会发送用户的密码重设邮件。由于我们是这样做的，所以你可以选择用户是否拿email作为他们的用户名，或者说用户把email作为用户的另一个信息保存。\n\n\n密码重设的流程如下:\n\n\n\n\n用户输入email来请求重设他们的密码。\n\n\nBmob向用户的email地址发送邮件，包含了一个重设密码的链接。\n\n\n用户点击这个重设密码的链接，会重定向到一个Bmob页面来允许他们重设密码。\n\n\n用户输入新的密码，他们的密码现在会更新为输入的新密码。\n\n\n\n\n查询\n\n\n为了查询用户，你可以简单的创建一个\nBmob.Query\n针对\nBmob.Users\n：\n\n\nvar query = new Bmob.Query(Bmob.User);\nquery.equalTo(gender, \nfemale\n);  // find all the women\nquery.find({\n  success: function(women) {\n    // Do stuff\n  }\n});\n\n\n\n\n关联\n\n\n关联一个\nBmob.User\n的对象可以很快就见效，比如说，假设你有一个blog程序，为了保存一个用户的新post还有读取他们所有的post。\n\n\nvar user = Bmob.User.current();\n\n// Make a new post\nvar Post = Bmob.Object.extend(\nPost\n);\nvar post = new Post();\npost.set(\ntitle\n, \nMy New Post\n);\npost.set(\nbody\n, \nThis is some great content.\n);\npost.set(\nuser\n, user);\npost.save(null, {\n  success: function(post) {\n    // Find all posts by the current user\n    var query = new Bmob.Query(Post);\n    query.equalTo(\nuser\n, user);\n    query.find({\n      success: function(usersPosts) {\n        // userPosts contains all of the posts by the current user.\n      }\n    });\n  }\n});\n\n\n\n\n实时数据平台\n\n\n实时功能简介\n\n\nBmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。\n\n\n注意！！！运行的html文件应该是在web环境中，不能在本地环境中运行。\n\n例如，合法的运行环境：http://local.project/appweb/sdk/js/demo/bmobSocketIo.html\n无效的本地运行环境：file:///D:/jeff/project/appweb/sdk/js/%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%B9%B3%E5%8F%B0/test/bmobSocketIo.html\n\n\n安装实时数据平台的js\n\n\n一、把下面这行代码加入你的页面中，其中，\"bmobSocketIo.js\"为实时数据平台的js文件。\n\n\nscript type=\ntext/javascript\n src=\nbmobSocketIo.js\n/script\n\n\n\n\n\n二、接着是加入下面这行代码进行初始化。\n\n\nBmobSocketIo.initialize(\n你的Application ID\n);\n\n\n\n\n订阅事件\n\n\n订阅表更新的事件\n\n\n订阅表\"GameScore\"更新的事件。\n\n\nBmobSocketIo.updateTable(\nGameScore\n);\n\n\n\n\n订阅行更新的事件\n\n\n订阅表\"GameScore\"中行objectId为\"3342e40e4f\"更新的事件。\n\n\nBmobSocketIo.updateRow(\nGameScore\n,\n3342e40e4f\n);\n\n\n\n\n订阅行删除的事件\n\n\n订阅表\"GameScore\"中行objectId为\"3342e40e4f\"删除的事件。\n\n\nBmobSocketIo.deleteRow(\nGameScore\n,\n1256e40e4f\n);\n\n\n\n\n取消订阅事件\n\n\n取消订阅表更新的事件\n\n\n取消订阅表\"GameScore\"更新的事件。\n\n\nBmobSocketIo.unsubUpdateTable(\nGameScore\n);\n\n\n\n\n取消订阅行更新的事件\n\n\n取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行更新的事件。\n\n\nBmobSocketIo.unsubUpdateRow(\nGameScore\n,\n3342e40e4f\n);\n\n\n\n\n取消订阅行删除的事件\n\n\n取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行删除的事件。\n\n\nBmobSocketIo.unsubDeleteRow(\nGameScore\n,\n1256e40e4f\n);\n\n\n\n\n监听触发的事件\n\n\n监听更新表的事件\n\n\n当订阅了表更新的表数据发送变化时，js中会触发函数onUpdateTable。\n\n\ntablename为更新的表，data为服务端返回的更新数据。\n\n\n   BmobSocketIo.onUpdateTable = function(tablename,data) {    \n      //业务逻辑的代码\n   };\n\n\n\n\n监听行更新的事件\n\n\ntablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。\n\n\n   BmobSocketIo.onUpdateRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };\n\n\n\n\n监听行删除的事件\n\n\ntablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。\n\n\n   BmobSocketIo.onDeleteRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };\n\n\n\n\ndemo\n\n\n在线上演示实时数据平台的一个聊天应用的demo：\nchat room demo\n ，演示了如何使用实时数据服务实现聊天的功能。\n\n\n用浏览器打开两个窗口，在其中一个窗口输入\n昵称\n和\n内容\n，按\n发送\n按钮，在另外一个窗口能看到发送的内容。\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\nACL的格式\n\n\n在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是*(表示公共的访问权限)，ACL 的值是\"读和写的权限\"，这个JSON对象的key总是权限名，而这些key的值总是true。\n\n\n如果您想让一个id为\"Kc3M222k\"的用户有读和写一条数据的权限，而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：\n\n\n{\n  \nKc3M222k\n: {\n    \nread\n: true,\n    \nwrite\n: true\n  },\n  \n*\n: {\n    \nread\n: true\n  }\n}\n\n\n\n\n角色和相关操作\n\n\n在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：\n\n\nname\n : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）。\n\n\nusers\n :一个指向一系列用户的关系, 这些用户会继承角色的权限。\n\n\nroles\n : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。\n\n\n创建角色\n\n\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role(\ntest\n, roleACL);\nrole.save();\n\n\n\n\n角色对象的安全性\n\n\nBmob.Role\n使用和其他Bmob对象一样的ACL权限策略, 除开它需要ACL被显式地设置以外。通常来说，只有用户有极大的权限（比如管理员）才应该被允许创建或者更改Role，所以你应该按这种标准来设定Role的ACL。请注意，如果你给了用户一个\nBmob.Role\n一个写权限，这个用户有可能会在这个权限中加入另一个user，或者甚至直接把角色删除掉。\n\n\n为了创建一个新的\nBmob.Role\n，你应该如下写：\n\n\n// By specifying no write privileges for the ACL, we can ensure the role cannot be altered.\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role(\nAdministrator\n, roleACL);\nrole.save();\n\n\n\n\n你可以通过增加\"user\"和\"roles\"关系的成员来在\nBmob.Role\n中加入用户或者子角色：\n\n\nvar role = new Bmob.Role(roleName, roleACL);\nfor (var i = 0; i \n usersToAddToRole.length; i++) {\n  role.getUsers().add(usersToAddToRole[i]);\n}\nfor (var i = 0; i \n rolesToAddToRole.length; i++) {\n  role.getRoles().add(rolesToAddToRole[i]);\n}\nrole.save();\n\n\n\n\n请非常注意一点，注册角色的ACL的时候，它们只能被应该有权限修改它的人修改。\n\n\n其他对象的安全性\n\n\n现在你应该已经创建了在你的程序中要使用的一系列的角色，你可以用ACL来定义他们的用户可以拥有的权限，每一个\nBmob.Object\n都可以指定一个\nBmob.ACL\n，这样提供了哪些用户或者角色应该有权限来读或者写这个对象。\n\n\n将一个读或者写的权限授予一个角色是很直观的，你可以使用\nBmob.Role\n：\n\n\nvar moderators = /* Query for some Bmob.Role */;\nvar wallPost = new Bmob.Object(\nWallPost\n);\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(moderators, true);\nwallPost.setACL(postACL);\nwallPost.save();\n\n\n\n\n你可以不需要查找这个Role，直接把名字提供给ACL：\n\n\nvar wallPost = new Bmob.Object(\nWallPost\n);\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(\nModerators\n, true);\nwallPost.setACL(postACL);\nwallPost.save();\n\n\n\n\n角色继承\n\n\n就像上面所描述的一样，一个角色可能包含其他的角色，表示两个角色之间的父-子关系，这样做的结果就是任何被授予一个角色的权限都会被隐式地授予这个角 色的所有子角色。\n\n\n这样的关系很经常会在有用户管理内容的程序之中看到，比如论坛，有一个很少量的用户称为管理员，有最高的权限，比如程序设定、创建新的论坛、设定所有人能看到的内容等等。另一类有一部分类似于\"版主\" 的用户，这些人有责任保持用户创建的内容是合适的，任何一个\"版主\"有的权限\"管理员\"都应该有。为了启用这种关系，你应该使\"管理员\"成为\"版主\"的一个子角色。\n\n\nvar administrators = /* Your \nAdministrators\n role */;\nvar moderators = /* Your \nModerators\n role */;\nmoderators.getRoles().add(administrators);\nmoderators.save();\n\n\n\n\n地理位置\n\n\n创建地理位置对象\n\n\n地理位置对象的创建需要用到\nBmob.GeoPoint\n类，如创建一个地理位置在纬度40度，经度在-30度的点的示例代码如下：\n\n\nvar point = new Bmob.GeoPoint({latitude: 40.0, longitude: -30.0});\n\n\n\n\n查询地理位置对象\n\n\n现在你可以有一系列的对象可以做空间坐标查询了，如果能轻松地发现有哪些对象离一个点最近就好了。这样可以通过在\nBmob.Query\n中加入一个\nnear\n来做查询，为了获得离用户最近的10个地点列表，可以这样：\n\n\n// location对应Web后台的一个字段名称\nvar userGeoPoint = userObject.get(\nlocation\n);\n// 创建查询\nvar query = new Bmob.Query(PlaceObject);\n// location附近的位置\nquery.near(\nlocation\n, userGeoPoint);\n// 返回10个地点数据\nquery.limit(10);\n// 查询\nquery.find({\n  success: function(placesObjects) {\n  }\n});\n\n\n\n\n在这时\nplaceObjects\n会返回一个按离\nuserGeoPoint\n的距离排序的列表，注意如果一个\nascending()/descending()\n给了查询的话，会取代按距离排序这项特性。\n\n\n为了按距离限制返回的结果，你可以使用\nwithinMiles\n、\nwithinKilometers\n和\nwithinRadians\n。\n\n\n同样，查询在特定地域的Object是可以的。为了找到用矩形表示的一块地域中的对象，加入\nwithinGeoBox\n来在\nBmob.Query\n中加入约束。\n\n\nvar southwestOfSF = new Bmob.GeoPoint(37.708813, -122.526398);\nvar northeastOfSF = new Bmob.GeoPoint(37.822802, -122.373962);\n\nvar query = new Bmob.Query(PizzaPlaceObject);\nquery.withinGeoBox(\nlocation\n, southwestOfSF, northeastOfSF);\nquery.find({\n  success: function(pizzaPlacesInSF) {\n    ...\n  }\n});\n\n\n\n\n错误代码详细说明\n\n\n错误码列表", 
            "title": "开发文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。    Bmob的JavaScript SDK基于 Backbone.js 框架开发，在使用过程中除 Bmob.view 类需要提供jQuery或者类似JQuery的 $ 方法外，不需要再引入其他类库。", 
            "title": "简介"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_2", 
            "text": "聊天室： http://chatroom.bmob.cn  （采用实时数据同步SDK开发，右击可直接查看源码）", 
            "title": "典型案例"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_3", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。", 
            "title": "应用程序"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_4", 
            "text": "", 
            "title": "对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_5", 
            "text": "Bmob数据存储是建立在 Bmob.Object 基础上的。如记录游戏成绩的 Bmob.Object 示例如下：  score: 1337, playerName:  bmob , cheatMode: false  这里需要注意的是：   键必须是字母或者数字的字符串，值可以是字符串、数字、布尔值或者数组和字典。  每一个 Bmob.Object 都是一个特定子类的实例，子类名可以来区分各种数据，如我们可以把记录游戏成绩的类称之为 GameScore 。", 
            "title": "数据对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_6", 
            "text": "你可以使用 Bmob.Object.extend 方法来创建新的 Bmob.Object 子类，示例代码如下：  // 创建Bmob.Object子类\nvar GameScore = Bmob.Object.extend( GameScore );\n\n// 创建该类的一个实例\nvar gameScore = new GameScore();  如果你想为 Bmob.Object 的子类添加一些实例方法和类方法，示例代码如下：  // 为Bmob.Object的子类添加实例方法和类方法\nvar GameScore = Bmob.Object.extend( GameScore , {\n  //实例方法\n  gleaterThanOneHundred: function() {\n    return this.get( score )   100;\n  }\n}, {\n  //类方法\n  spawn: function(score) {\n    var gameScore = new GameScore();\n    gameScore.set( score , score);\n    return gameScore;\n  }\n});\n\nvar gameScore = GameScore.spawn(200);\nalert(gameScore.gleaterThanOneHundred());", 
            "title": "创建对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_7", 
            "text": "添加数据非常简单，任何 Bmob.Object 子类都有 save 方法可以用于将当前对象的内容保存到服务端。示例代码如下：  //创建类和实例\nvar GameScore = Bmob.Object.extend( GameScore );\nvar gameScore = new GameScore();\ngameScore.set( score , 137);\ngameScore.set( playerName ,  bmob );\ngameScore.set( cheatMode , false);\n//添加数据，第一个入口参数是null\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 添加成功，返回成功之后的objectId（注意：返回的属性名字是id，不是objectId），你还可以在Bmob的Web管理后台看到对应的数据\n    alert('添加数据成功，返回的objectId是：' + gameScore.id);\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n    alert('添加数据失败，返回错误信息：' + error.description);\n  }\n});  你也可以用如下的示例代码添加数据：  var GameScore = Bmob.Object.extend( GameScore );\nvar gameScore = new GameScore();\n// 添加数据，第一个入口参数是Json数据\ngameScore.save({\n  score: 1337,\n  playerName:  bmob ,\n  cheatMode: false\n}, {\n  success: function(gameScore) {\n    // 添加成功\n  },\n  error: function(gameScore, error) {\n    // 添加失败\n  }\n});  这里有几点需要注意的是:   如果云端数据库中不存在 GameScore 表，Bmob会自动地在你第一次使用它的时候创建。  每个 Bmob.Object 对象都有几个默认的字段是自动创建的： objectId 是一个对于每一个保存的对象为一个标志； createdAt 和 updatedAt 表示对象在Bmob中创建和最后一次更改的时间。这些字段的创建和内容是由服务器端自动完成的，在保存 Bmob.Object 之前不会存在。  添加成功后，可以通过 gameScore.createdAt 获取对象的创建时间，通过 gameScore.updatedAt 获取对象的更新时间；可以通过 gameScore.id 获取对象的objectId。", 
            "title": "添加数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_8", 
            "text": "数据的查询是每个应用都会频繁使用到的，Bmob提供了 Bmob.Object 类，方便大家实现不同条件的查询。", 
            "title": "查询数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_9", 
            "text": "查询某个数据表中的所有数据是非常简单的，只需要使用 Bmob.Query 的 find 方法就可以了，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\n// 查询所有数据\nquery.find({\n  success: function(results) {\n    alert( 共查询到   + results.length +   条记录 );\n    // 循环处理查询到的数据\n    for (var i = 0; i   results.length; i++) {\n      var object = results[i];\n      alert(object.id + ' - ' + object.get('playerName'));\n    }\n  },\n  error: function(error) {\n    alert( 查询失败:   + error.code +     + error.message);\n  }\n});  如果你只想要一个结果，一个更加方便的方法是使用 first ，而不是 find 方法，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\nquery.first({\n  success: function(object) {\n    // 查询成功\n  },\n  error: function(error) {\n    alert( 查询失败:   + error.code +     + error.message);\n  }\n});  这里需要注意一点的是： \n默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可 点击查看分页查询 一节。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_10", 
            "text": "注意，在对象中获取objectId，createdAt，updatedAt的方法分别如下：\nobj.id\nobj.createdAt\nobj.updatedAt", 
            "title": "获取对象的特殊属性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_11", 
            "text": "当我们知道某条数据的 objectId 时，就可以根据 objectId 值直接获取单条数据对象，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\n//创建查询对象，入口参数是对象类的实例\nvar query = new Bmob.Query(GameScore);\n//查询单条数据，第一个参数是这条数据的objectId值\nquery.get( 82c3e62d2c , {\n  success: function(gameScore) {\n    // 查询成功，调用get方法获取对应属性的值\n    var score = gameScore.get( score );\n    var playerName = gameScore.get( playerName );\n    var cheatMode = gameScore.get( cheatMode );\n  },\n  error: function(object, error) {\n    // 查询失败\n  }\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_12", 
            "text": "如果要查询某个属性等于某个值，示例代码如下：  query.equalTo( playerName ,  bmob );  如果要查询某个属性不等于某个值，示例代码如下：  query.notEqualTo( playerName ,  bmob cloud );  对查询的属性值进行大小比较的示例代码如下：  // score   50\nquery.lessThan( score , 50);\n\n// score  = 50\nquery.lessThanOrEqualTo( score , 50);\n\n// score   50\nquery.greaterThan( score , 50);\n\n// score  = 50\nquery.greaterThanOrEqualTo( score , 50);  两条查询语句一起写，就相当于 AND 查询，如下示例代码，查询同时满足 \"playerName\"=\"bmob\" and \"score\" 100 的数据：  query.notEqualTo( playerName ,  bmob );\nquery.greaterThan( score , 100);  一个完整的例子：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\nquery.equalTo( playerName ,  bmob ); \n// 查询所有数据\nquery.find({\n    success: function(results) {\n        alert( 共查询到   + results.length +   条记录 );\n        // 循环处理查询到的数据\n        for (var i = 0; i   results.length; i++) {\n        var object = results[i];\n        alert(object.id + ' - ' + object.get('playerName'));\n        }\n    },\n    error: function(error) {\n        alert( 查询失败:   + error.code +     + error.message);\n    }\n});", 
            "title": "条件查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_13", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用 limit 方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为10，最大有效设置值1000（设置的数值超过1000还是视为1000）。  // 返回最多10条数据\nquery.limit(10);   在数据较多的情况下，在 limit 的基础上分页显示数据是比较合理的解决办法， skip 方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下 skip 的值为10。  query.skip(10); // skip the first 10 results", 
            "title": "分页查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_14", 
            "text": "我们可以对返回的结果进行排序（只支持 number 和 string 类型的排序），示例代码如下：  // 对score字段升序排列\nquery.ascending( score );\n\n// 对score字段降序排列\nquery.descending( score );", 
            "title": "结果排序"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_15", 
            "text": "如果你只是想统计满足 query 的结果集到底有多条记录，你可以使用 count 方法。如为了获得GameScore表的记录数量，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\nquery.count({\n  success: function(count) {\n    // 查询成功，返回记录数量\n    alert( 共有   + count +   条记录 );\n  },\n  error: function(error) {\n    // 查询失败\n  }\n});", 
            "title": "统计记录数量"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_16", 
            "text": "如果你想查询某一字段值在某一集合中的记录的话，可以使用 containedIn 方法，如获取 \"Bmob\"、\"Codenow\"、\"JS\" 这三位玩家的记录信息，那么示例代码如下：  // 第一个参数是字段名称，第二个参数是数组\nquery.containedIn( playerName , [ Bmob ,  Codenow ,  JS ]);  相反地，你可以使用 notContainedIn 方法来查询在集合外的目标对象。  如果想要查询含有某一特定属性的对象，可以使用 exists 。相对地，如果你想获取没有这一特定属性的对象，你可以使用 doesNotExist ，示例代码如下：  // 查询含有score属性的对象\nquery.exists( score );\n\n// 查询不含有score属性的对象\nquery.doesNotExist( score );  你可以使用 matchesKeyInQuery 方法来进行嵌套的子查询。举例说，如果你有一个类包含了运动队， 而你在用户类中存储了用户的家乡信息，你可以构造一个查询来查找某地的运动队有赢的记录的用户，示例代码如下：  var Team = Bmob.Object.extend( Team );\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan( winPct , 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.matchesKeyInQuery( hometown ,  city , teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});  相对地，可以使用 doesNotMatchKeyInQuery 来获取属性不在子查询结果中的对象。比如为了获得用户的家乡队输了的情况：  var Team = Bmob.Object.extend( Team );\nvar teamQuery = new Bmob.Query(Team);\nteamQuery.greaterThan( winPct , 0.5);\nvar userQuery = new Bmob.Query(Bmob.User);\nuserQuery.doesNotMatchKeyInQuery( hometown ,  city , teamQuery);\nuserQuery.find({\n  success: function(results) {\n    // results has the list of users with a hometown team with a winning record\n  }\n});", 
            "title": "复杂查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_17", 
            "text": "有时候你不想返回所有的字段信息，那么就可以用 select 方法来限定返回的字段。示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\n// 只返回score和playerName字段值\nquery.select( score ,  playerName );\nquery.find().then(function(results) {\n  // 返回成功\n});  注意：系统默认的字段 objectId 、 createdAt 、 updatedAt 、 ACL 也会返回。", 
            "title": "查询指定列"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_18", 
            "text": "如果想要查询以某一个特定字符串开头的记录，可以使用 startWith 方法，示例代码如下：  // 查询在playerName字段中以bm开头的记录\nvar query = new Bmob.Query(GameScore);\nquery.startsWith( playerName ,  bm );", 
            "title": "对字符串类型做查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_19", 
            "text": "你可以使用 Bmob.Query.or 方法操作或查询，示例代码如下：  var lotsOfWins = new Bmob.Query(GameScore);\nlotsOfWins.greaterThan( score , 150);\n\nvar fewWins = new Bmob.Query(GameScore);\nfewWins.lessThan( score , 5);\n\nvar mainQuery = Bmob.Query.or(lotsOfWins, fewWins);\nmainQuery.find({\n  success: function(results) {\n     // 返回 score   150 or score   5 的值\n  },\n  error: function(error) {\n    // 返回失败\n  }\n});  注意：我们不会在组合查询的子查询中支持非过滤型的条件 (比如:limit,skip,ascending/descending,include)", 
            "title": "或查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_20", 
            "text": "修改数据非常简单，首先需要获取到要更新的 Bmob.Object 对象，修改值后保存数据就可以了，示例代码如下：  var GameScore = Bmob.Object.extend( GameScore );\nvar query = new Bmob.Query(GameScore);\n\n// 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档\nquery.get('3453453453fdsdf', {\n    success: function(gameScore) {\n      // 回调中可以取得这个 GameScore 对象的一个实例，然后就可以修改它了\n      gameScore.set('title', 'test!');\n      gameScore.save();\n\n      // The object was retrieved successfully.\n    },\n    error: function(object, error) {\n\n    }\n});  或者  var GameScore = Bmob.Object.extend( GameScore );\nvar gameScore = new GameScore();\ngameScore.set( cheatMode , true);\ngameScore.set( score , 1338);\n//添加数据\ngameScore.save(null, {\n  success: function(gameScore) {\n    // 修改数据\n    gameScore.set( cheatMode , true);\n    gameScore.set( score , 1338);\n    gameScore.save();\n  }\n})  如果想更新成功后获取更新后的对象属性，请设置 fetchWhenSave ：   //假设gamescore是已经存在的对象\n    gameScore.fetchWhenSave(true);\n    gameScore.set( cheatMode , true);\n    gameScore.set( score , 1338);\n    gameScore.save();", 
            "title": "修改数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_21", 
            "text": "删除数据可以使用 Bmob.Object 的 destroy 方法，示例代码如下：  myObject.destroy({\n  success: function(myObject) {\n    // 删除成功\n  },\n  error: function(myObject, error) {\n    // 删除失败\n  }\n});", 
            "title": "删除数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_22", 
            "text": "你可以使用 unset 方法在删除一个字段：  // 删除playerName字段\nmyObject.unset( playerName );\nmyObject.save();", 
            "title": "删除字段"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_23", 
            "text": "var number = 42;\nvar string =  the number is   + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set( myNumber , number);\nbigObject.set( myString , string);\nbigObject.set( myDate , date);\nbigObject.set( myArray , array);\nbigObject.set( myObject , object);\nbigObject.set( myNull , null);\nbigObject.save();", 
            "title": "常见数据类型的操作"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_24", 
            "text": "", 
            "title": "数组操作"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_25", 
            "text": "为了帮你存储数组类数据，有三种操作你可以原子性地改动一个数组，这需要一个给定的 key：   add 在一个数组的末尾加入一个给定的对象。  addUnique 只会把原本不存在的对象加入数组，所以加入的位置没有保证。   比如, 我们想在数组\"skills\"中加入项目：  gameScore.addUnique( skills ,  flying );\ngameScore.addUnique( skills ,  kungfu );\ngameScore.save();", 
            "title": "添加及更新数组"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_26", 
            "text": "对于value是数组的情况，你可以这样查询数组中的值有 2 的情况的对象：  // Find objects where the array in arrayKey contains 2.\nquery.equalTo( arrayKey , 2);  你同样可以用下面的方式找到同时包含元素 2、3、4 的数组：  // Find objects where the array in arrayKey contains all of the elements 2, 3, and 4.\nquery.containsAll( arrayKey , [2, 3, 4]);", 
            "title": "数组查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_27", 
            "text": "remove 在一个数组中删除所有指定的所有实例：  var GameScoretest = Bmob.Object.extend( GameScoretest );\nvar query = new Bmob.Query(GameScoretest);\nquery.get( bc5da708dc ,{\n  success: function(gameScore) {\n    gameScore.remove( skills , test );\n    gameScore.save();\n  },\n  error: function(error) {\n    alert( Error:   + error.code +     + error.message);\n  }\n});", 
            "title": "删除数组"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_28", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_29", 
            "text": "", 
            "title": "添加及修改关联关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_30", 
            "text": "一对一关系和一对多关系都可以通过在一个 Bmob.Object 内保存另一个对象来实现。比如，每一个 Comment都对应了一个Post，创建一个有一个Comment的Post，你可以这样写：  // Declare the types.\nvar Post = Bmob.Object.extend( Post );\nvar Comment = Bmob.Object.extend( Comment );\n\n// Create the post\nvar myPost = new Post();\nmyPost.set( title ,  I'm Hungry );\nmyPost.set( content ,  Where should we go for lunch? );\n\n// Create the comment\nvar myComment = new Comment();\nmyComment.set( content ,  Let's do Sushirrito. );\n\n// Add the post as a value in the comment\nmyComment.set( parent , myPost);\n\n// This will save both myPost and myComment\nmyComment.save();  Bmob内部会自动处理，调用Comment的 save 方法就可以同时保存两个新对象。  如果是现有对象想要关联到新对象，你同样可以通过只用它们的 objectId 来连接彼此。请注意，不能直接像上面的例子那样将现有对象设置进去，而是必须 new 一个新对象并只设置 id 属性：  var post = Bmob.Object.createWithoutData( Post ,  320b0395f3 );\nmyComment.set( parent , post);  或者：  var post = new Post();\npost.id = '520c7e1ae4b0a3ac9ebe326a';\nmyComment.set( parent , post);  默认情况下，当获取一个对象时，关联的 Bmob.Object 不会被获取到，这些对象的值不能访问，除非像下面这样获取它们：  var post = fetchedComment.get( parent );\npost.fetch({\n  success: function(post) {\n    var title = post.get( title );\n  }\n});", 
            "title": "一对一关系和一对多关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_31", 
            "text": "多对多关系是通过 Bmob.Relation 来建模的，这样很像在一个key中存储一个 Bmob.Object 数组，但是你不需要一次性下载关系中的所有对象。这使得 Bmob.Relation 比数组可以更好地扩展到更多对象。例如，一个User可能喜欢很多Post，在这种情况下，你可以把一个用户喜欢的所有Post存为一个Relation，为了将一个Post加入一个User的like列表，你可以：  var user = Bmob.User.current();\nvar relation = user.relation( likes );\nrelation.add(post);\nuser.save();  你还可以传入一个 Bmob.Object 数组来做 add 和 remove ：  relation.add([post1, post2, post3]);\nuser.save();", 
            "title": "多对多关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_32", 
            "text": "默认情况下， relation 关联的对象并不会被下载，你可以通过使用 query 方法返回的 Bmob.Query 对象来获取 Bmob.Object 的列表，例如：  relation.query().find({\n  success: function(list) {\n    // list contains the posts that the current user likes.\n  }\n});  如果你仅仅要一个Post的子集，你可以在 Bmob.Query 中加入更多的条件：  var query = relation.query();\nquery.equalTo( title ,  I'm Hungry );\nquery.find({\n  success:function(list) {\n    // list contains post liked by the current user which have the title  I'm Hungry .\n  }\n});  如果希望查询结果中包含多个相关联的其他数据类型。你可以使用 include 方 法。例如有个comments，你可能想同时获取它们相关的 post 数据:  var query = new Bmob.Query(Comment);\n\nquery.include( post );  你可以在接下来关于 Bmob.Query 的章节中看到更详细的内容。一个 Bmob.Relation 的行为很像一个 Bmob.Object 数组，所以任何在数组可做的查询操作，也都可以作用在 Bmob.Relation 上。  如果你知道post，想反向查询user，可以通过 Bmob.Relation.reverseQuery 方法：  var query = Bmob.Relation.reverseQuery('_User', 'likes', post);\nquery.find({\n  success:function(users) {\n   //users是表示喜欢这个post的用户列表。\n  }\n});", 
            "title": "查询关联关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_33", 
            "text": "你可以从一个 Bmob.Relation 中删除一个post：  relation.remove(post);\nuser.save();  你可以在用 save 方法保存前多次调用 add 和 remove 方法：  relation.remove(post1);\nrelation.remove(post2);\nuser.save();", 
            "title": "删除关联关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_34", 
            "text": "许多应用都需要维持一些计数器数据，譬如用来跟踪游戏分数、金币甚至道具的数目等等。Bmob提供了便捷的方式来对任何数字字段进行原子性的增加或者减少：  gameScore.increment( score );\ngameScore.save();  你可以同样传入第二个参数到 increment 方法来指定增加多少， 1 是默认值。", 
            "title": "原子计数器"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_35", 
            "text": "", 
            "title": "文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_36", 
            "text": "上传文件有两种方法：  直接上传文件，例如，我们上传一个内容为\"Hello, World!\"，名称为\"hello.txt\"的文件，可用如下的代码：  var bytes =  Hello, World! ;\nvar file = new Bmob.File( hello.txt , bytes);\nfile.save().then(function(obj) {\n  //alert(obj.url());\n}, function(error) {\n  // the save failed.\n});  最经常的对于HTML5的应用来说，可能需要用html表单和一个文件上传控制器。在现代的浏览器中这很容易，只需要创建一个file input tag来允许用户选择他们磁盘上的文件就可以了。  input type= file  id= profilePhotoFileUpload   然后，在一个处理 click 或其他的函数里，获取对那个文件的一个引用：          var fileUploadControl = $( #profilePhotoFileUpload )[0];\n        if (fileUploadControl.files.length   0) {\n        var file = fileUploadControl.files[0];\n        var name =  logo.jpg ;\n        var file = new Bmob.File(name, file);     \n        file.save();", 
            "title": "整个文件上传"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_37", 
            "text": "file.destroy(); //删除文件", 
            "title": "文件删除"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_38", 
            "text": "提供一些工具接口，方便开发者处理图片。", 
            "title": "图片处理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_39", 
            "text": "提供原图的URL地址和相应的参数， 返回缩微图的URL地址， 具体参数定义如下：  mode:模式 0: 指定宽， 高自适应，等比例缩放\n     模式 1: 指定高， 宽自适应，等比例缩放\n     模式 2: 指定最长边，短边自适应，等比例缩放\n     模式 3: 指定最短边，长边自适应，等比例缩放\n     模式 4: 指定最大宽高， 等比例缩放\n     模式 5: 固定宽高， 居中裁剪    \nimage:原图片url\nwidth:宽度，模式 0, 4, 5必填\nheight：高度，模式 1, 4, 5必填\nlongEdge：长边，模式 2必填\nshortEdge：短边，模式 3必填\nquality：质量，选填, 范围 1-100\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流  调用的代码：  Bmob.Image.thumbnail({ image : http://file.bmob.cn/M00/01/26/wKgBP1OX9LLVh5gNAAHGYsmKRjk666.jpg , mode :0, quality :100, width :100}\n\n  ).then(function(obj) {\n\n  alert( filename: +obj.filename); //\n  alert( url: +obj.url); //\n});  如果 outType = 0 返回云端url地址:  {\n   filename :  e6c8ac18c9.jpg ,\n   group :  group1 ,\n   url :  M00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg \n}  如果  outType = 1  返回文件内容的 base64 字符串：  {\n   file : base64的文件内容 \n}", 
            "title": "缩微图"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_40", 
            "text": "提供原图的URL地址，水印图的URL地址和相应的参数，返回缩微图的URL地址，具体参数定义如下：  image：原图路径\nwatermark：水印图路径\ndissolve:透明度，0-255\ndistanceX：横轴边距，单位:像素(px)，缺省值为10\ndistanceY：纵轴边距，单位:像素(px)，缺省值为10\noutType：输出类型，0:默认，输出url；1:输出base64编码的字符串流\ngravity:水印位置，见下图   调用的代码：  //get image thumbnail\nBmob.Image.watermark({ image : http://test.com/new/images/banner005.jpg , watermark : http://test.com/new/images/header2.png , dissolve :100, gravity : SouthWest , distanceX :10, distanceY :10}\n\n  ).then(function(obj) {\n\n  alert( filename: +obj.filename); //\n  alert( url: +obj.url); //\n});  如果  outType = 0  返回云端url地址:  {\n   filename :  e6c8ac18c9.jpg ,\n   group :  group1 ,\n   url :  M00/01/6E/wKhkA1OGpWKAGdNUAAAjdkbUqo4612.jpg \n}  如果  outType = 1  返回文件内容的 base64 字符串：  {\n   file : base64的文件内容 \n}", 
            "title": "水印图"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#promise", 
            "text": "除了回调函数之外，每一个在Bmob JavaScript SDK中的异步方法都会返回一个 Promise. 使用 Promise，你的代码可以比原来的嵌套 callback 的方法看起来优雅得多.", 
            "title": "Promise"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#then", 
            "text": "每一个 Promise 都有一个叫 then 的方法, 这个方法接受一对 callback 。第一个 callback 在 promise 被解决的时候调用，第二个会在 promise 被拒绝的时候调用。  obj.save().then(function(obj) {\n  // the object was saved successfully.\n}, function(error) {\n  // the save failed.\n});", 
            "title": "then 方法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#promise_1", 
            "text": "Promise 比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。 如果一个 Promise 的回调会返回一个 Promise ，那么第二个 then 里的 callback 在第一个 then 的 callback 没有解决前是不会解决的。  var query = new Bmob.Query( Student );\nquery.descending( gpa );\nquery.find().then(function(students) {\n  students[0].set( valedictorian , true);\n  return students[0].save();\n\n}).then(function(valedictorian) {\n  return query.find();\n\n}).then(function(students) {\n  students[1].set( salutatorian , true);\n  return students[1].save();\n\n}).then(function(salutatorian) {\n  // Everything is done!\n\n});", 
            "title": "将Promise 组织在一起"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_41", 
            "text": "如果任意一个在链中的 Promise 返回一个错误的话，所有的成功的 callback 在接下来都会被跳过直到遇到一个处理错误的 callback 。处理 error 的 callback 可以转换 error 或者可以通过返回一个新的 Promise 的方式来处理它。你可以想象成拒绝的 promise 有点像异常，而 error callback 则像是一个 catch 来处理这个异常或者抛出异常。  var query = new Bmob.Query( Student );\nquery.descending( gpa );\nquery.find().then(function(students) {\n  students[0].set( valedictorian , true);\n  // Force this callback to fail.\n  return Bmob.Promise.error( There was an error. );\n\n}).then(function(valedictorian) {\n  // Now this will be skipped.\n  return query.find();\n\n}).then(function(students) {\n  // This will also be skipped.\n  students[1].set( salutatorian , true);\n  return students[1].save();\n}, function(error) {\n  // This error handler WILL be called. error will be  There was an error. .\n  // Let's handle the error by returning a new promise.\n  return Bmob.Promise.as( Hello! );\n\n}).then(function(hello) {\n  // Everything is done!\n}, function(error) {\n  // This isn't called because the error was already handled.\n});  通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数会是很方便的做法.", 
            "title": "错误处理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#promise_2", 
            "text": "在开始阶段，你可以只用系统（譬如 find 和 save 方法等）返回的 promise 。但在更高级的场景下，你可能需要创建自己的 promise 。在创建了 Promise 之后，你需要调用 resolve 或者 reject 来触发它的 callback 。  var successful = new Bmob.Promise();\nsuccessful.resolve( The good result. );\n\nvar failed = new Bmob.Promise();\nfailed.reject( An error message. );  如果你在创建 promise 的时候就知道它的结果，下面有两个很方便的方法可以使用：  var successful = Bmob.Promise.as( The good result. );\nvar failed = Bmob.Promise.error( An error message. );", 
            "title": "创建 Promise"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#promise_3", 
            "text": "var query = new Bmob.Query( Comments );\nquery.equalTo( post , 123);\n\nquery.find().then(function(results) {\n  // Create a trivial resolved promise as a base case.\n  var promise = Bmob.Promise.as();\n  _.each(results, function(result) {\n    // For each item, extend the promise with a function to delete it.\n    promise = promise.then(function() {\n      // Return a promise that will be resolved when the delete is finished.\n      return result.destroy();\n    });\n  });\n  return promise;\n\n}).then(function() {\n  // Every comment was deleted.\n});", 
            "title": "顺序的Promise"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#promise_4", 
            "text": "你也可以用 Promise 来并行的进行多个任务，这时需要使用 when 方法。你可以一次同时开始几个操作，使用 Bmob.Promise.when 来创建一个新的 promise ，它会在所有输入的 Promise 被解决之后才被解决。即便一些输入的 promise 失败了，新的 Promise 也会被成功执行。你可以在  callback 的参数部分检查每一个 promise 的结果，并行地进行操作会比顺序进行更快，但是也会消耗更多的系统资源和带宽。  var query = new Bmob.Query( Comments );\nquery.equalTo( post , 123);\n\nquery.find().then(function(results) {\n  // Collect one promise for each delete into an array.\n  var promises = [];\n  _.each(results, function(result) {\n    // Start this delete immediately and add its promise to the list.\n    promises.push(result.destroy());\n  });\n  // Return a new promise that is resolved when all of the deletes are finished.\n  return Bmob.Promise.when(promises);\n\n}).then(function() {\n  // Every comment was deleted.\n});", 
            "title": "并行的Promise"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_42", 
            "text": "有了上面这些工具以后, 就很容易创建你自己的异步方法来返回 promise 了。举例说，你可以创建一个有 promise 版本的 setTimeout 。  var delay = function(millis) {\n  var promise = new Bmob.Promise();\n  setTimeout(function() {\n    promise.resolve();\n  }, millis);\n  return promise;\n};\n\ndelay(100).then(function() {\n  // This ran after 100ms!\n});", 
            "title": "创建异步方法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#collection", 
            "text": "一个 Bmob.Collection 就是一个 Bmob.Objects 的有序集合，它和 Backbone.Collection 是兼容的，有相同的特性和功能，你可以通过用一个模型类或者一个特定的 Bmob.Query 来创建一个新的子类。  // A Collection containing all instances of TestObject.\nvar TestCollection = Bmob.Collection.extend({\n  model: TestObject\n});\nvar collection = new TestCollection();\n\n// A Collection of TestObjects whose temperature is  hot .\nvar HotCollection = Bmob.Collection.extend({\n  model: TestObject,\n  query: (new Bmob.Query(TestObject)).equalTo( temperature ,  hot )\n});\nvar collection = new HotCollection();\n\n// The Collection of TestObjects that match a complex query.\nvar query = new Bmob.Query(TestObject);\nquery.equalTo( temperature ,  hot );\nquery.greaterThan( degreesF , 100);\nvar collection = query.collection();", 
            "title": "Collection"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#collection_1", 
            "text": "使用 fetch 方法来获取一个 collection 里的所有元素:  var collection = new TestCollection();\ncollection.fetch({\n  success: function(collection) {\n    collection.each(function(object) {\n      console.warn(object);\n    });\n  },\n  error: function(collection, error) {\n    // The collection could not be retrieved.\n  }\n});", 
            "title": "获取Collection"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#collection_2", 
            "text": "你可以设定一个 comparator 来对 collection 中的元素进行排序:  var collection = new TestCollection();\ncollection.comparator = function(object) {\n  return object.get( temperature );\n};", 
            "title": "Collection 排序"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#collection_3", 
            "text": "Collection 是可变的，你可以访问所有元素，增加或者删除元素：  var collection = new TestCollection();\n\ncollection.add([\n  { name :  Duke },\n  { name :  Scarlett }\n]);\n\n// Get the  Duke  Bmob.Object by its sorted position.\nvar model = collection.at(0);\n\n// Or you can get it by Bmob objectId.\nvar modelAgain = collection.get(model.id);\n\n// Remove  Duke  from the collection.\ncollection.remove(model);\n\n// Completely replace all items in the collection.\ncollection.reset([\n  { name :  Hawk },\n  { name :  Jane }\n]);", 
            "title": "修改一个 Collection"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_43", 
            "text": "在许多应用中，都有一个用户账户的概念，用户账户让用户可以用安全的方式访问他们自己的信息。我们提供了一个特殊的用户类叫 Bmob.User 来自动处理有关用户的账户管理的功能。  Bmob.User 是 Bmob.Object 的一个子类，而且有 Bmob.Object 一样的功能，比如可变的模式、自动的持久化、键值对接口等。所有对 Bmob.Object 有用的方法同样可以作用于 Bmob.User 。 Bmob.User 的不同之处在于 Bmob.User 对于用户的账户有一些特定的功能。", 
            "title": "用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_44", 
            "text": "Bmob.User 有一些与 Bmob.Object 不一样的字段:  username ：用户的用户名（必须提供） password ：用户的密码（在注册的时候必须提供） email ：用户的 email（可选）\n我们会在下面的用例中详细介绍细节", 
            "title": "属性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_45", 
            "text": "通常你的app第一件要做的事情就是让用户进行注册，下面的代码展示了怎样进行通常的注册过程：  var user = new Bmob.User();\nuser.set( username ,  my name );\nuser.set( password ,  my pass );\nuser.set( email ,  email@example.com );\n\n// other fields can be set just like with Bmob.Object\nuser.set( phone ,  415-392-0202 );\n\nuser.signUp(null, {\n  success: function(user) {\n    // Hooray! Let them use the app now.\n  },\n  error: function(user, error) {\n    // Show the error message somewhere and let the user try again.\n    alert( Error:   + error.code +     + error.message);\n  }\n});  这个调用会异步地在在你的应用中创建一个新的用户。在它这样做之前，它同样会确认用户名和 email 在应用内都是唯一的。同样，我们从不会将用户密码以明文向任何客户端发送。  注意我们使用了 signUp 方法而不是 save 方法，新的 Bmob.User 永远应该使用 signUp 方法来新建。而随后的用户的信息更新可以调用 save 来做。  如果一个 signup 没有成功的话，你应该读取返回的错误对象。最常见的问题是 username 或者 email 已经被其他用户所使用了。你应该清楚地反馈给你的用户，让他们再次用一个不同的用户名来注册。  你也可以使用 email 来作为用户名，只要求你的用户输入他们的 email 但是同时自动填充好 username 属性就可以了， Bmob.User 会跟原来一样工作，我们会在下面的重设密码环节再次说明这个细节。", 
            "title": "注册"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_46", 
            "text": "在你要求你的用户注册之后，当然应该让他们在以后用自己的账户登录进来，你可以使用 logIn 方法来进行登陆：  Bmob.User.logIn( myname ,  mypass , {\n  success: function(user) {\n    // Do stuff after successful login.\n  },\n  error: function(user, error) {\n    // The login failed. Check error to see why.\n  }\n});", 
            "title": "登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#email", 
            "text": "在application设置中启用email验证可以让你的应用给最终用户一些更安全的使用体验，譬如部分功能只开放给验证过邮箱的用户使用等等。Email验证会在 Bmob.User 上加入一个 emailVerified 字段。当一个 Bmob.User 的 email 被设定或者修改后, emailVerfied 会被设定为 false 。Bmob 会向用户的 email 来发送一个链接，点击这个链接会设置 emailVerified 为 true ：  有三种 emailVerified 状态可以供参考：   true ：用户已经通过点击Bmob发过来的链接来确认邮箱地址. 当用户账户新创建的时候这个值永远不应该是true。  false ：在  Bmob.User 对象最后一次刷新的时候，用户还是没有确认他们的 email 地址，如果 emailVerified 是false 的话，你应该考虑调用 Bmob.User 的 fetch 方法。  missing ： Bmob.User 被创建了，但是当时的 email 验证功能还没有开启, 或者说 Bmob.User 没有email地址。   代码例子如下：  //reset password\n Bmob.User.requestEmailVerify( h6k65@126.com , {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert( Error:   + error.code +     + error.message);\n  }\n});", 
            "title": "验证 Email"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_47", 
            "text": "如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的 Bmob.User 对象来避免这个问题。  无论你使用任何注册或者登录方法，用户都会在 localStorage 中储存，你可以把缓存作为一个 session 对待，并且自动假设用户已经登录了。  var currentUser = Bmob.User.current();\nif (currentUser) {\n    // do stuff with the user\n} else {\n    // show the signup or login page\n}  你可以通过 logout 来清除掉当前的用户：  Bmob.User.logOut();\n\nvar currentUser = Bmob.User.current();  // this will now be null", 
            "title": "当前用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_48", 
            "text": "Bmob.User 类默认就是受保护的，在 Bmob.User 中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些 Bmob.User 对象被认证后是可以修改的，其他的仍然是只读的。  特别的，你不能调用 save 或者 delete 方法除非 Bmob.User 经过了认证，就比如调用过了 logIn 或者 signUp 方法，这样保证只有用户能改动他们自身的数据。  下面的代码展示了上面说的安全策略：  var user = Bmob.User.logIn( my_username ,  my_password , {\n  success: function(user) {\n    user.set( username ,  my_new_username );  // attempt to change username\n    user.save(null, {\n      success: function(user) {\n        // This succeeds, since the user was authenticated on the device\n\n        // Get the user from a non-authenticated method\n        var query = new Bmob.Query(Bmob.User);\n        query.get(user.objectId, {\n          success: function(userAgain) {\n            userAgain.set( username ,  another_username );\n            userAgain.save(null, {\n              error: function(userAgain, error) {\n                // This will error, since the Bmob.User is not authenticated\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n});  从 Bmob.User.current() 获取的 Bmob.User 总是已经通过验证了的。  如果你需要查看一个 Bmob.User 是否已经认证过了，你可以调用 authenticated 方法，你不需要查看一个认证方法中返回的 Bmob.User 对象是否已经通过验证了。", 
            "title": "用户对象的安全"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_49", 
            "text": "和 Bmob.User 相同的安全模型也使用于其他对象。对于任何对象来说，你可以指定哪些用户会被允许读取对象，哪些用户被允许修改对象。为了支持这种安全机制，每一个对象都有一个允许访问列表 (ACL)，是被 Bmob.ACL 类所实现的。  使用一个 Bmob.ACL 最简单的方式是指定一个对象只能被一个单一的用户读或者写。为了创建这样的对象，首先必须有一个已经登录的 Bmob.User 。然后，新的 Bmob.ACL(user) 生成一个 Bmob.ACL 来限定 user 的访问。一个对象的ACL会在对象保存的时候被存储起来，就像其他的属性一样，这样，为了创建一个当前user私有的一个note：  var Note = Bmob.Object.extend( Note );\nvar privateNote = new Note();\nprivateNote.set( content ,  This note is private! );\nprivateNote.setACL(new Bmob.ACL(Bmob.User.current()));\nprivateNote.save();  这个note只能由当前的用户所访问，但是可以在用户登录的任何设备上访问，只要是相同的用户就可以了。这项功能对于你如果想让用户再任何其他的设备上保存和访问数据十分有用，比如说一个私人的todo list应用。  权限也能在使用者的基础上授予，你可以通过 setReadAccess 和 setWriteAccess 方法独立的向 Bmob.ACL 中添加权限。比如，假设你有一条消息想要发送给一个组里的多个用户，他们中的每一个都有读和写的权限：  var Message = Bmob.Object.extend( Message );\nvar groupMessage = new Message();\nvar groupACL = new Bmob.ACL();\n\n// userList is an array with the users we are sending this message to.\nfor (var i = 0; i   userList.length; i++) {\n  groupACL.setReadAccess(userList[i], true);\n  groupACL.setWriteAccess(userList[i], true);\n}\n\ngroupMessage.setACL(groupACL);\ngroupMessage.save();  你同样可以对所有的用户授权，只要使用 setPublicReadAccess 和 setPublicWriteAccess 就可以了。这样允许了在一个消息板上发评论的模式，比如，我们要创建一个post只能被它的作者修改，但是可以被所有人读取：  var publicPost = new Post();\nvar postACL = new Bmob.ACL(Bmob.User.current());\npostACL.setPublicReadAccess(true);\npublicPost.setACL(postACL);\npublicPost.save();  比如说删除一个对象，但是你没有写的权限这种操作是禁止的，这样会返回一个 Bmob.Error.OBJECT_NOT_FOUND 的错误码，为了安全起见，这样防止了客户端区分出到底有哪些对象被创建了但是无法读取还是根本不存在。", 
            "title": "其他对象的安全"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_50", 
            "text": "在现实中只要你引入了密码系统，总会有用户会忘掉他们的密码。在这种情形下，我们的库提供一个让他们安全地重设密码的功能。  为了能让用户重设密码，应该要求用户提供他们的email地址，然后这样调用：   Bmob.User.requestPasswordReset( test@126.com , {\n  success: function() {\n    // Password reset request was sent successfully\n  },\n  error: function(error) {\n    // Show the error message somewhere\n    alert( Error:   + error.code +     + error.message);\n  }\n});  这样会尝试匹配给定的email和用户的email或者username字段，然后会发送用户的密码重设邮件。由于我们是这样做的，所以你可以选择用户是否拿email作为他们的用户名，或者说用户把email作为用户的另一个信息保存。  密码重设的流程如下:   用户输入email来请求重设他们的密码。  Bmob向用户的email地址发送邮件，包含了一个重设密码的链接。  用户点击这个重设密码的链接，会重定向到一个Bmob页面来允许他们重设密码。  用户输入新的密码，他们的密码现在会更新为输入的新密码。", 
            "title": "重设密码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_51", 
            "text": "为了查询用户，你可以简单的创建一个 Bmob.Query 针对 Bmob.Users ：  var query = new Bmob.Query(Bmob.User);\nquery.equalTo(gender,  female );  // find all the women\nquery.find({\n  success: function(women) {\n    // Do stuff\n  }\n});", 
            "title": "查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_52", 
            "text": "关联一个 Bmob.User 的对象可以很快就见效，比如说，假设你有一个blog程序，为了保存一个用户的新post还有读取他们所有的post。  var user = Bmob.User.current();\n\n// Make a new post\nvar Post = Bmob.Object.extend( Post );\nvar post = new Post();\npost.set( title ,  My New Post );\npost.set( body ,  This is some great content. );\npost.set( user , user);\npost.save(null, {\n  success: function(post) {\n    // Find all posts by the current user\n    var query = new Bmob.Query(Post);\n    query.equalTo( user , user);\n    query.find({\n      success: function(usersPosts) {\n        // userPosts contains all of the posts by the current user.\n      }\n    });\n  }\n});", 
            "title": "关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_53", 
            "text": "", 
            "title": "实时数据平台"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_54", 
            "text": "Bmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。  注意！！！运行的html文件应该是在web环境中，不能在本地环境中运行。 \n例如，合法的运行环境：http://local.project/appweb/sdk/js/demo/bmobSocketIo.html\n无效的本地运行环境：file:///D:/jeff/project/appweb/sdk/js/%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%B9%B3%E5%8F%B0/test/bmobSocketIo.html", 
            "title": "实时功能简介"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#js", 
            "text": "一、把下面这行代码加入你的页面中，其中，\"bmobSocketIo.js\"为实时数据平台的js文件。  script type= text/javascript  src= bmobSocketIo.js /script   二、接着是加入下面这行代码进行初始化。  BmobSocketIo.initialize( 你的Application ID );", 
            "title": "安装实时数据平台的js"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_55", 
            "text": "", 
            "title": "订阅事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_56", 
            "text": "订阅表\"GameScore\"更新的事件。  BmobSocketIo.updateTable( GameScore );", 
            "title": "订阅表更新的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_57", 
            "text": "订阅表\"GameScore\"中行objectId为\"3342e40e4f\"更新的事件。  BmobSocketIo.updateRow( GameScore , 3342e40e4f );", 
            "title": "订阅行更新的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_58", 
            "text": "订阅表\"GameScore\"中行objectId为\"3342e40e4f\"删除的事件。  BmobSocketIo.deleteRow( GameScore , 1256e40e4f );", 
            "title": "订阅行删除的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_59", 
            "text": "", 
            "title": "取消订阅事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_60", 
            "text": "取消订阅表\"GameScore\"更新的事件。  BmobSocketIo.unsubUpdateTable( GameScore );", 
            "title": "取消订阅表更新的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_61", 
            "text": "取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行更新的事件。  BmobSocketIo.unsubUpdateRow( GameScore , 3342e40e4f );", 
            "title": "取消订阅行更新的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_62", 
            "text": "取消订阅表\"GameScore\"中objectId为\"3342e40e4f\"行删除的事件。  BmobSocketIo.unsubDeleteRow( GameScore , 1256e40e4f );", 
            "title": "取消订阅行删除的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_63", 
            "text": "", 
            "title": "监听触发的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_64", 
            "text": "当订阅了表更新的表数据发送变化时，js中会触发函数onUpdateTable。  tablename为更新的表，data为服务端返回的更新数据。     BmobSocketIo.onUpdateTable = function(tablename,data) {    \n      //业务逻辑的代码\n   };", 
            "title": "监听更新表的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_65", 
            "text": "tablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。     BmobSocketIo.onUpdateRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };", 
            "title": "监听行更新的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_66", 
            "text": "tablename为更新的表，objectId为更新行的objectId，data为服务端返回的更新数据。     BmobSocketIo.onDeleteRow = function(tablename,objectId,data) {    \n      //业务逻辑的代码\n   };", 
            "title": "监听行删除的事件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#demo", 
            "text": "在线上演示实时数据平台的一个聊天应用的demo： chat room demo  ，演示了如何使用实时数据服务实现聊天的功能。  用浏览器打开两个窗口，在其中一个窗口输入 昵称 和 内容 ，按 发送 按钮，在另外一个窗口能看到发送的内容。", 
            "title": "demo"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#acl_1", 
            "text": "在Bmob中，ACL是按JSON对象格式（key-value）来表示的。这个JSON对象的key是objectId（用户表某个用户对应的objectId）或者是*(表示公共的访问权限)，ACL 的值是\"读和写的权限\"，这个JSON对象的key总是权限名，而这些key的值总是true。  如果您想让一个id为\"Kc3M222k\"的用户有读和写一条数据的权限，而且这个数据应该可以被全部人读取的话，这个ACL的表达方式如下：  {\n   Kc3M222k : {\n     read : true,\n     write : true\n  },\n   * : {\n     read : true\n  }\n}", 
            "title": "ACL的格式"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_67", 
            "text": "在很多情况下，你需要定义一些用户具有某种相同的数据操作权限，而另外一群用户具有另外一种相同的数据操作权限，这时你就可以使用到Bmob的角色（对应Bmob在Web提供的Role表、SDK中的BmobRole类）功能，设置不同的用户组不同的操作权限。角色表有三个特殊字段：  name  : 必须字段，表示角色名称,而且只允许被设置一次（命名必须由字母, 空格, 减号或者下划线构成）。  users  :一个指向一系列用户的关系, 这些用户会继承角色的权限。  roles  : 一个指向一系列子角色的关系, 这些子关系会继承父角色所有的权限。", 
            "title": "角色和相关操作"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_68", 
            "text": "var roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role( test , roleACL);\nrole.save();", 
            "title": "创建角色"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_69", 
            "text": "Bmob.Role 使用和其他Bmob对象一样的ACL权限策略, 除开它需要ACL被显式地设置以外。通常来说，只有用户有极大的权限（比如管理员）才应该被允许创建或者更改Role，所以你应该按这种标准来设定Role的ACL。请注意，如果你给了用户一个 Bmob.Role 一个写权限，这个用户有可能会在这个权限中加入另一个user，或者甚至直接把角色删除掉。  为了创建一个新的 Bmob.Role ，你应该如下写：  // By specifying no write privileges for the ACL, we can ensure the role cannot be altered.\nvar roleACL = new Bmob.ACL();\nroleACL.setPublicReadAccess(true);\nvar role = new Bmob.Role( Administrator , roleACL);\nrole.save();  你可以通过增加\"user\"和\"roles\"关系的成员来在 Bmob.Role 中加入用户或者子角色：  var role = new Bmob.Role(roleName, roleACL);\nfor (var i = 0; i   usersToAddToRole.length; i++) {\n  role.getUsers().add(usersToAddToRole[i]);\n}\nfor (var i = 0; i   rolesToAddToRole.length; i++) {\n  role.getRoles().add(rolesToAddToRole[i]);\n}\nrole.save();  请非常注意一点，注册角色的ACL的时候，它们只能被应该有权限修改它的人修改。", 
            "title": "角色对象的安全性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_70", 
            "text": "现在你应该已经创建了在你的程序中要使用的一系列的角色，你可以用ACL来定义他们的用户可以拥有的权限，每一个 Bmob.Object 都可以指定一个 Bmob.ACL ，这样提供了哪些用户或者角色应该有权限来读或者写这个对象。  将一个读或者写的权限授予一个角色是很直观的，你可以使用 Bmob.Role ：  var moderators = /* Query for some Bmob.Role */;\nvar wallPost = new Bmob.Object( WallPost );\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess(moderators, true);\nwallPost.setACL(postACL);\nwallPost.save();  你可以不需要查找这个Role，直接把名字提供给ACL：  var wallPost = new Bmob.Object( WallPost );\nvar postACL = new Bmob.ACL();\npostACL.setRoleWriteAccess( Moderators , true);\nwallPost.setACL(postACL);\nwallPost.save();", 
            "title": "其他对象的安全性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_71", 
            "text": "就像上面所描述的一样，一个角色可能包含其他的角色，表示两个角色之间的父-子关系，这样做的结果就是任何被授予一个角色的权限都会被隐式地授予这个角 色的所有子角色。  这样的关系很经常会在有用户管理内容的程序之中看到，比如论坛，有一个很少量的用户称为管理员，有最高的权限，比如程序设定、创建新的论坛、设定所有人能看到的内容等等。另一类有一部分类似于\"版主\" 的用户，这些人有责任保持用户创建的内容是合适的，任何一个\"版主\"有的权限\"管理员\"都应该有。为了启用这种关系，你应该使\"管理员\"成为\"版主\"的一个子角色。  var administrators = /* Your  Administrators  role */;\nvar moderators = /* Your  Moderators  role */;\nmoderators.getRoles().add(administrators);\nmoderators.save();", 
            "title": "角色继承"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_72", 
            "text": "", 
            "title": "地理位置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_73", 
            "text": "地理位置对象的创建需要用到 Bmob.GeoPoint 类，如创建一个地理位置在纬度40度，经度在-30度的点的示例代码如下：  var point = new Bmob.GeoPoint({latitude: 40.0, longitude: -30.0});", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_74", 
            "text": "现在你可以有一系列的对象可以做空间坐标查询了，如果能轻松地发现有哪些对象离一个点最近就好了。这样可以通过在 Bmob.Query 中加入一个 near 来做查询，为了获得离用户最近的10个地点列表，可以这样：  // location对应Web后台的一个字段名称\nvar userGeoPoint = userObject.get( location );\n// 创建查询\nvar query = new Bmob.Query(PlaceObject);\n// location附近的位置\nquery.near( location , userGeoPoint);\n// 返回10个地点数据\nquery.limit(10);\n// 查询\nquery.find({\n  success: function(placesObjects) {\n  }\n});  在这时 placeObjects 会返回一个按离 userGeoPoint 的距离排序的列表，注意如果一个 ascending()/descending() 给了查询的话，会取代按距离排序这项特性。  为了按距离限制返回的结果，你可以使用 withinMiles 、 withinKilometers 和 withinRadians 。  同样，查询在特定地域的Object是可以的。为了找到用矩形表示的一块地域中的对象，加入 withinGeoBox 来在 Bmob.Query 中加入约束。  var southwestOfSF = new Bmob.GeoPoint(37.708813, -122.526398);\nvar northeastOfSF = new Bmob.GeoPoint(37.822802, -122.373962);\n\nvar query = new Bmob.Query(PizzaPlaceObject);\nquery.withinGeoBox( location , southwestOfSF, northeastOfSF);\nquery.find({\n  success: function(pizzaPlacesInSF) {\n    ...\n  }\n});", 
            "title": "查询地理位置对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_75", 
            "text": "错误码列表", 
            "title": "错误代码详细说明"
        }, 
        {
            "location": "/module/example/README/index.html", 
            "text": "JS快速入门相关源码:\nhttp://www.bmob.cn/static/bmob_jssdk_quickstart.zip\n\n\n聊天室：\nhttp://chatroom.bmob.cn\n （采用实时数据同步SDK开发，右击可直接查看源码）", 
            "title": "示例和功能"
        }, 
        {
            "location": "/module/common_problem/README/index.html", 
            "text": "常见问题\n\n\nQ:请问比目有TypeScript的前端sdk吗？主要是用在白鹭游戏引擎引擎里的。\nA:这个暂时没有，有普通js的sdk\n\n\n\n\nQ:angularJs如何与bmob配合使用\nA:一般这种情况需要将和Bmob的数据交互封装为一个service，从service中返回数据\n基本的调用层次就是controller调用service，service调用Bmob\nbmobservice.js\n\n\napp.service(\nbmobservice\n, function () {\n//添加一个资源  Bmob对象在index中初始化或者在app.run中进行初始化\nthis.AddResource =function(resource){\n    var ResourceInfo = Bmob.Object.extend(\nResourceInfo\n);\n\n    //创建对象\n    var resourceInfo = new ResourceInfo();\n    //为对象赋值\n    resourceInfo.set(\nTitle\n,resource.Title);\n    resourceInfo.set(\nResourceType\n,resource.ResourceType);\n    resourceInfo.set(\nTarget\n,resource.Target);\n\n    //resourceInfo.save();\n    var array = new Array();\n    var SubResourceInfo = Bmob.Object.extend(\nSubResourceInfo\n);\n    var subResourceInfo = new SubResourceInfo();\n    subResourceInfo.set(\nName\n,resource.SubResourceInfo[0].Name);\n    subResourceInfo.set(\nUrl\n,resource.SubResourceInfo[0].Url);\n    resourceInfo.set(\nSubResource\n,subResourceInfo);\n    resourceInfo.save();\n}\n});\n\n\n\n\n\ntestcontroller.js\n\n\napp.controller('testcontroller',function($scope,$resource,bmobservice){\n        $scope.addresource = function(){\n            var resource = {\n                \nTitle\n:\ntest\n,\n                \nResourceType\n:0,\n                \nTarget\n:\ntest\n,\n                \nSubResourceInfo\n:[{\n                    \nUrl\n:\ntesturl\n,\n                    \nName\n:\ntestname\n\n                }]\n            }\n            bmobservice.AddResource(resource);\n        }\n\n\n\n\n\n\nQ:没有客户端请求的情况下服务端能主动向客户端发送数据吗？\nA:不能\n\n\n\n\nQ:有没有比较数据表中内容相似度的方法\n例如 我表里面有 一个组数据 name: 你好中国人， 我要往里面房数据但是如果我的数据为 name：中国人 ，就不放进去了。。判断两者为同一数据\nA:这种定制化的需求需要开发者自行实现。\n\n\n\n\nQ:有没有办法可以获取password\nA:为安全考虑，我们不对外提供获取password字段值的功能。\n\n\n\n\nQ:Javascript的bmob的数据处理都是异步的，如何设置为同步\nA:如果是在nodejs中，可使用async这个同步类库\n\n\n\n\nQ:如何在node.js的代码中调用bmob\nA:用bmob的nodejs模块\n\n\n\n\nQ:JS如果想产生多行数据保存到表中怎么办?\nA:，一次只能保存一条数据，多条数据需要使用批量操作，可以使用restful接口\n\n\n\n\nQ:js sdk中有更新某个表某个字段所有值的函数吗\nA:没有的，只能一个个更新，restful有一个批量更新的接口，但是每次最多只能操作50条数据\n\n\n\n\nQ:JavaScript 传输数据时，自动加密了吗？\nA:Bmob所有SDK的通讯过程都进行了加密。\n\n\n\n\nQ:消息推送 JS SDK支持吗？我使用H5进行APP开发\nA:JS有推送功能，可以查看推送文档。\n\n\n\n\nQ:BmobSocketIo.onUpdateTable可以无视ACL\nA:实时监听功能不受ACL的限制。\n\n\n\n\nQ:JS SDK 的初始化语句应该放在哪里？\nA:用框架集成到一个页面，例如angularjs 的ng-view。不然只能哪里用到，哪里调用\n\n\n\n\nQ:JS SDK可以增加模糊查询吗\nA:目前JS并没有该接口，可使用JS的网络访问接口调用restful api实现，restful api中含有模糊查询的功能。\n\n\n\n\nQ:我需要将数据加密后再保存到Bmob表吗？\nA:所有SDK到服务器之间的数据都是经过对称加密算法加密后传输的。\n\n\n\n\nQ:JavaScript怎么在bomb数据库里面存入date类型。\nA:\n\n\nvar number = 42;\nvar string = \nthe number is \n + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set(\nmyNumber\n, number);\nbigObject.set(\nmyString\n, string);\nbigObject.set(\nmyDate\n, date);\nbigObject.set(\nmyArray\n, array);\nbigObject.set(\nmyObject\n, object);\nbigObject.set(\nmyNull\n, null);\nbigObject.save();\n\n\n\n\n\n\nQ:bmob的query查询可以做对指定列做sum之类的聚合查询吗？\nA:可以。具体查看JS使用文档\n\n\n\n\nQ:JS版里有多图片上传吗\nA:JS版没有多图片上传，需要自行处理\n\n\n\n\nQ:js中用户登录返回的session是不是都一样？\nA:同一个用户多次登录返回的SessionToken是一样", 
            "title": "常见问题"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_1", 
            "text": "Q:请问比目有TypeScript的前端sdk吗？主要是用在白鹭游戏引擎引擎里的。\nA:这个暂时没有，有普通js的sdk   Q:angularJs如何与bmob配合使用\nA:一般这种情况需要将和Bmob的数据交互封装为一个service，从service中返回数据\n基本的调用层次就是controller调用service，service调用Bmob\nbmobservice.js  app.service( bmobservice , function () {\n//添加一个资源  Bmob对象在index中初始化或者在app.run中进行初始化\nthis.AddResource =function(resource){\n    var ResourceInfo = Bmob.Object.extend( ResourceInfo );\n\n    //创建对象\n    var resourceInfo = new ResourceInfo();\n    //为对象赋值\n    resourceInfo.set( Title ,resource.Title);\n    resourceInfo.set( ResourceType ,resource.ResourceType);\n    resourceInfo.set( Target ,resource.Target);\n\n    //resourceInfo.save();\n    var array = new Array();\n    var SubResourceInfo = Bmob.Object.extend( SubResourceInfo );\n    var subResourceInfo = new SubResourceInfo();\n    subResourceInfo.set( Name ,resource.SubResourceInfo[0].Name);\n    subResourceInfo.set( Url ,resource.SubResourceInfo[0].Url);\n    resourceInfo.set( SubResource ,subResourceInfo);\n    resourceInfo.save();\n}\n});  testcontroller.js  app.controller('testcontroller',function($scope,$resource,bmobservice){\n        $scope.addresource = function(){\n            var resource = {\n                 Title : test ,\n                 ResourceType :0,\n                 Target : test ,\n                 SubResourceInfo :[{\n                     Url : testurl ,\n                     Name : testname \n                }]\n            }\n            bmobservice.AddResource(resource);\n        }   Q:没有客户端请求的情况下服务端能主动向客户端发送数据吗？\nA:不能   Q:有没有比较数据表中内容相似度的方法\n例如 我表里面有 一个组数据 name: 你好中国人， 我要往里面房数据但是如果我的数据为 name：中国人 ，就不放进去了。。判断两者为同一数据\nA:这种定制化的需求需要开发者自行实现。   Q:有没有办法可以获取password\nA:为安全考虑，我们不对外提供获取password字段值的功能。   Q:Javascript的bmob的数据处理都是异步的，如何设置为同步\nA:如果是在nodejs中，可使用async这个同步类库   Q:如何在node.js的代码中调用bmob\nA:用bmob的nodejs模块   Q:JS如果想产生多行数据保存到表中怎么办?\nA:，一次只能保存一条数据，多条数据需要使用批量操作，可以使用restful接口   Q:js sdk中有更新某个表某个字段所有值的函数吗\nA:没有的，只能一个个更新，restful有一个批量更新的接口，但是每次最多只能操作50条数据   Q:JavaScript 传输数据时，自动加密了吗？\nA:Bmob所有SDK的通讯过程都进行了加密。   Q:消息推送 JS SDK支持吗？我使用H5进行APP开发\nA:JS有推送功能，可以查看推送文档。   Q:BmobSocketIo.onUpdateTable可以无视ACL\nA:实时监听功能不受ACL的限制。   Q:JS SDK 的初始化语句应该放在哪里？\nA:用框架集成到一个页面，例如angularjs 的ng-view。不然只能哪里用到，哪里调用   Q:JS SDK可以增加模糊查询吗\nA:目前JS并没有该接口，可使用JS的网络访问接口调用restful api实现，restful api中含有模糊查询的功能。   Q:我需要将数据加密后再保存到Bmob表吗？\nA:所有SDK到服务器之间的数据都是经过对称加密算法加密后传输的。   Q:JavaScript怎么在bomb数据库里面存入date类型。\nA:  var number = 42;\nvar string =  the number is   + number;\nvar date = new Date();\nvar array = [string, number];\nvar object = { number: number, string: string };\n\nvar bigObject = new BigObject();\nbigObject.set( myNumber , number);\nbigObject.set( myString , string);\nbigObject.set( myDate , date);\nbigObject.set( myArray , array);\nbigObject.set( myObject , object);\nbigObject.set( myNull , null);\nbigObject.save();   Q:bmob的query查询可以做对指定列做sum之类的聚合查询吗？\nA:可以。具体查看JS使用文档   Q:JS版里有多图片上传吗\nA:JS版没有多图片上传，需要自行处理   Q:js中用户登录返回的session是不是都一样？\nA:同一个用户多次登录返回的SessionToken是一样", 
            "title": "常见问题"
        }
    ]
}