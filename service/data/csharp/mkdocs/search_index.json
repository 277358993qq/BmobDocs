{
    "docs": [
        {
            "location": "/index.html", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入 www.bmob.cn 或者在百度输入“Bmob后端云”进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥\n\n\n选择你要开发的应用，点击该应用下方对应的“应用密钥”\n\n\n\n\n在跳转页面，获取\nApplication ID\n和\nREST API key\n，此IDs将会在初始化SDK中使用到。\n\n\n\n\n下载安装SDK\n\n\nBmob C# SDK下载地址：\nhttps://github.com/bmob/BmobSharp/releases\n\n\n\n\nWindows\n\n\n\n\n下载后解压，将Windows文件夹下的\nBmob-Windows.dll\n文件引用到你的项目工程中，如下图所示。\n\n\n\n\ndemo：\nbmob-desktop-demo\n\n\n\n\nUnity\n\n\n\n\n下载后解压，将Unity文件夹下的\nBmob-Unity.dll\n文件放置到你的项目工程的 \nAssets/libs/\n 目录下。\n\n\ndemo：\nbmob-unity-demo\n\n开发环境(调试)搭建：请查询\nBmobSharp的README文档\n。\n\n\n新建模型类\n\n\n要想对Bmob云端的数据进行操作，需要创建和数据表对应的模型类。在Bmob中，模型类需要继承自\nBmobTable\n，类的实现如下。\n\n\n//Game表对应的模型类\nclass GameObject : BmobTable\n{\n\n    private String fTable;\n    //以下对应云端字段名称\n    public BmobInt score { get; set; }\n    public String playerName { get; set; }\n    public BmobBoolean cheatMode { get; set; }\n\n    //构造函数\n    public GameObject() { }\n\n    //构造函数\n    public GameObject(String tableName)\n    {\n        this.fTable = tableName;\n    }\n\n    public override string table\n    {\n        get\n        {\n            if (fTable != null)\n            {\n                return fTable;\n            }\n            return base.table;\n        }\n    }\n\n    //读字段信息\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.score = input.getInt(\nscore\n);\n        this.cheatMode = input.getBoolean(\ncheatMode\n);\n        this.playerName = input.getString(\nplayerName\n);\n    }\n\n    //写字段信息\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put(\nscore\n, this.score);\n        output.Put(\ncheatMode\n, this.cheatMode);\n        output.Put(\nplayerName\n, this.playerName);\n    }\n}\n\n\n\n\n初始化AppKey\n\n\n\n\nWindows\n\n\n\n\n在正式对Bmob后端云进行操作之前，需要先初始化AppKey/RestKey信息，也就是初始化之前获取的\nApplication ID/RestKey\n信息，实现代码如下。\n\n\n        //创建Bmob实例\n        private BmobWindows bmob;\n\n        public BmobBaseForm()\n            : base()\n        {\n            bmob = new BmobWindows();\n\n            //初始化，这个ApplicationId/RestKey需要更改为你自己的ApplicationId/RestKey（ http://www.bmob.cn 上注册登录之后，创建应用可获取到ApplicationId/RestKey）\n            Bmob.initialize(\n4414150cb439afdf684d37dc184e0f9f\n, \ne1deb317442129c125b228ddf78e5f22\n);\n\n            //注册调试工具\n            BmobDebug.Register(msg =\n { Debug.WriteLine(msg); });\n        }\n\n        public BmobWindows Bmob\n        {\n            get { return bmob; }\n        }\n\n\n\n\n\n\nUnity\n\n\n\n\n选中摄像机，把BmobUnity对象拖拽到摄像机上，然后再Properties选项卡中设置 \nApplicationId\n 和 \nRestKey\n 。\n\n\n\n\n在脚本中启动方法中获取BmobUntiy：\n\n\n        private static BmobUnity Bmob;\n\n        // Use this for initialization\n        void Start ()\n        {\n                BmobDebug.Register (print);\n                BmobDebug.level = BmobDebug.Level.TRACE;\n                Bmob = gameObject.GetComponent\nBmobUnity\n ();\n        }\n\n\n\n\n添加一行数据\n\n\n初始化AppKey之后，我们就可以对Bmob云数据库进行操作了。下面以添加一行数据为例进行说明，实现代码如下:\n\n\n//对应要操作的数据表\npublic const String TABLE_NAME = \nGame\n;\n//接下来要操作的数据的数据\nprivate GameObject gameObject = new GameObject(TABLE_NAME);\n\nprivate void createData_Click(object sender, EventArgs e)\n{\n    //设置值    \n    System.Random rnd = new System.Random();\n    gameObject.score = rnd.Next(-50, 170);\n    gameObject.playerName = \n123\n;\n    gameObject.cheatMode = false;\n\n    //保存数据\n    var future = Bmob.CreateTaskAsync(gameObject);\n    //异步显示返回的数据\n    FinishedCallback(future.Result, resultText);\n}\n\n\n\n\n更多例子\n\n\n大家可详细查看\n示例源码\n和 \nSDK项目源码\n，了解更多的Bmob C# SDK for Windows的操作。", 
            "title": "快速入门"
        }, 
        {
            "location": "/index.html#bmob", 
            "text": "在网址栏输入 www.bmob.cn 或者在百度输入“Bmob后端云”进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/index.html#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/index.html#_2", 
            "text": "选择你要开发的应用，点击该应用下方对应的“应用密钥”   在跳转页面，获取 Application ID 和 REST API key ，此IDs将会在初始化SDK中使用到。", 
            "title": "获取应用密钥"
        }, 
        {
            "location": "/index.html#sdk", 
            "text": "Bmob C# SDK下载地址： https://github.com/bmob/BmobSharp/releases   Windows   下载后解压，将Windows文件夹下的 Bmob-Windows.dll 文件引用到你的项目工程中，如下图所示。   demo： bmob-desktop-demo   Unity   下载后解压，将Unity文件夹下的 Bmob-Unity.dll 文件放置到你的项目工程的  Assets/libs/  目录下。  demo： bmob-unity-demo \n开发环境(调试)搭建：请查询 BmobSharp的README文档 。", 
            "title": "下载安装SDK"
        }, 
        {
            "location": "/index.html#_3", 
            "text": "要想对Bmob云端的数据进行操作，需要创建和数据表对应的模型类。在Bmob中，模型类需要继承自 BmobTable ，类的实现如下。  //Game表对应的模型类\nclass GameObject : BmobTable\n{\n\n    private String fTable;\n    //以下对应云端字段名称\n    public BmobInt score { get; set; }\n    public String playerName { get; set; }\n    public BmobBoolean cheatMode { get; set; }\n\n    //构造函数\n    public GameObject() { }\n\n    //构造函数\n    public GameObject(String tableName)\n    {\n        this.fTable = tableName;\n    }\n\n    public override string table\n    {\n        get\n        {\n            if (fTable != null)\n            {\n                return fTable;\n            }\n            return base.table;\n        }\n    }\n\n    //读字段信息\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.score = input.getInt( score );\n        this.cheatMode = input.getBoolean( cheatMode );\n        this.playerName = input.getString( playerName );\n    }\n\n    //写字段信息\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put( score , this.score);\n        output.Put( cheatMode , this.cheatMode);\n        output.Put( playerName , this.playerName);\n    }\n}", 
            "title": "新建模型类"
        }, 
        {
            "location": "/index.html#appkey", 
            "text": "Windows   在正式对Bmob后端云进行操作之前，需要先初始化AppKey/RestKey信息，也就是初始化之前获取的 Application ID/RestKey 信息，实现代码如下。          //创建Bmob实例\n        private BmobWindows bmob;\n\n        public BmobBaseForm()\n            : base()\n        {\n            bmob = new BmobWindows();\n\n            //初始化，这个ApplicationId/RestKey需要更改为你自己的ApplicationId/RestKey（ http://www.bmob.cn 上注册登录之后，创建应用可获取到ApplicationId/RestKey）\n            Bmob.initialize( 4414150cb439afdf684d37dc184e0f9f ,  e1deb317442129c125b228ddf78e5f22 );\n\n            //注册调试工具\n            BmobDebug.Register(msg =  { Debug.WriteLine(msg); });\n        }\n\n        public BmobWindows Bmob\n        {\n            get { return bmob; }\n        }   Unity   选中摄像机，把BmobUnity对象拖拽到摄像机上，然后再Properties选项卡中设置  ApplicationId  和  RestKey  。   在脚本中启动方法中获取BmobUntiy：          private static BmobUnity Bmob;\n\n        // Use this for initialization\n        void Start ()\n        {\n                BmobDebug.Register (print);\n                BmobDebug.level = BmobDebug.Level.TRACE;\n                Bmob = gameObject.GetComponent BmobUnity  ();\n        }", 
            "title": "初始化AppKey"
        }, 
        {
            "location": "/index.html#_4", 
            "text": "初始化AppKey之后，我们就可以对Bmob云数据库进行操作了。下面以添加一行数据为例进行说明，实现代码如下:  //对应要操作的数据表\npublic const String TABLE_NAME =  Game ;\n//接下来要操作的数据的数据\nprivate GameObject gameObject = new GameObject(TABLE_NAME);\n\nprivate void createData_Click(object sender, EventArgs e)\n{\n    //设置值    \n    System.Random rnd = new System.Random();\n    gameObject.score = rnd.Next(-50, 170);\n    gameObject.playerName =  123 ;\n    gameObject.cheatMode = false;\n\n    //保存数据\n    var future = Bmob.CreateTaskAsync(gameObject);\n    //异步显示返回的数据\n    FinishedCallback(future.Result, resultText);\n}", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/index.html#_5", 
            "text": "大家可详细查看 示例源码 和  SDK项目源码 ，了解更多的Bmob C# SDK for Windows的操作。", 
            "title": "更多例子"
        }, 
        {
            "location": "/module/develop_doc/README/index.html", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n应用程序\n\n\n在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。\n\n\nBmob客户端初始化\n\n\nUnity\n\n\n要使用Bmob提供的服务，首先需要把BmobUnity附加到你应用程序的Camara，然后获取BmobUnity脚本组件，才能进行下一步的操作。(把图中的Application Id换成你应用的appkey)\n\n\n\n\npublic class HelloBmob : MonoBehaviour\n{\n    //BmobUnity脚本组件实例\n    private BmobUnity bmobUnity;\n\n    // 初始化\n    void Start()\n    {\n        //获取BmobUnity脚本组件\n        bmobUnity = gameObject.GetComponent\nBmobUnity\n();\n    }\n\n\n\n\nDeskstop\n\n\nBmobWindows Bmob = new BmobWindows();\nBmob.initialize(\n4414150cb439afdf684d37dc184e0f9f\n, \ne1deb317442129c125b228ddf78e5f22\n); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =\n { Debug.WriteLine(msg); }); // 用于调试输出请求参数\n\n\n\n\nWindowsphone\n\n\nBmobWindowsPhone Bmob = new BmobWindowsPhone();\nBmob.initialize(\n4414150cb439afdf684d37dc184e0f9f\n, \ne1deb317442129c125b228ddf78e5f22\n); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =\n { Debug.WriteLine(msg); }); // 用于调试输出请求参数\n\n\n\n\nBmob接口方法\n\n\nSDK组件目前提供了如下的方法供大家使用：\n\n\n// 初始化组件（可供动态切换appKey、restKey）\npublic void initialize(string appKey, string restKey);\n\n//////////////////////////////////////////////\n//\n// 数据处理\n//\n//////////////////////////////////////////////\n\npublic void Create(string tablename, IBmobWritable data, BmobCallback\ncn.bmob.response.CreateCallbackData\n callback);\npublic void Create\nT\n(T data, BmobCallback\ncn.bmob.response.CreateCallbackData\n callback) where T : BmobTable;\npublic void Delete(string tablename, string objectId, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback);\npublic void Delete\nT\n(T data, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback) where T : BmobTable;\npublic void Update(string tablename, string objectId, IBmobWritable data, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback);\npublic void Update\nT\n(T data, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback) where T : BmobTable;\npublic void Find\nT\n(string tablename, BmobQuery query, BmobCallback\ncn.bmob.response.QueryCallbackData\nT\n callback);\npublic void Get\nT\n(string tablename, string objectId, BmobCallback\nT\n callback);\npublic void Get\nT\n(T data, BmobCallback\nT\n callback) where T : BmobTable;\n\n//////////////////////////////////////////////\n//\n// 用户处理\n//\n//////////////////////////////////////////////\n\n// 用户注册\npublic void Signup(BmobUser user, BmobCallback\nBmobUser\n callback);\npublic void Signup\nT\n(T user, BmobCallback\nT\n callback) where T : BmobUser;\npublic void DeleteUser(string objectId, string sessionToken, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback);\npublic void DeleteUser\nT\n(T data, BmobCallback\ncn.bmob.response.DeleteCallbackData\n callback) where T : BmobUser;\npublic void UpdateUser(string objectId, BmobUser data, string sessionToken, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback);\npublic void UpdateUser\nT\n(T data, BmobCallback\ncn.bmob.response.UpdateCallbackData\n callback) where T : BmobUser;\n\n// 发送邮箱验证\npublic void EmailVerify(string email, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\n\n// 重置密码\npublic void Reset(string email, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\n\npublic void Login(string username, string pwd, BmobCallback\nBmobUser\n callback);\npublic void Login\nT\n(string username, string pwd, BmobCallback\nT\n callback) where T : BmobUser;\n\n//////////////////////////////////////////////\n//\n// 其他功能\n//\n//////////////////////////////////////////////\n\n// 调用云端代码\npublic void Endpoint\nT\n(string eMethod, BmobCallback\nT\n callback);\npublic void Endpoint\nT\n(string eMethod, IDictionary\nstring, object\n parameters, BmobCallback\nT\n callback);\n\npublic void FileDelete(BmobFile file, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileDelete(string group, string url, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\npublic void FileUpload(string localPath, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\n\npublic void Endpoint\nT\n(string eMethod, BmobCallback\nT\n callback);\npublic void Endpoint\nT\n(string eMethod, IDictionary\nstring, object\n parameters, BmobCallback\nT\n callback);\n\npublic void FileDelete(BmobFile file, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileDelete(string group, string url, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\npublic void FileUpload(string localPath, BmobCallback\ncn.bmob.response.UploadCallbackData\n callback);\n\n// 获取服务器时间戳\npublic void Timestamp(BmobCallback\ncn.bmob.response.TimeStampCallbackData\n callback);\n\npublic void Batch(BmobBatch requests, BmobCallback\nList\nDictionary\nstring, object\n callback);\n\npublic void Push(PushParamter param, BmobCallback\ncn.bmob.response.EmptyCallbackData\n callback);\npublic void Thumbnail(ThumbnailParameter param, BmobCallback\ncn.bmob.response.ThumbnailCallbackData\n callback);\n\n\n\n\n针对C# 4.0+，SDK为每个接口对应添加了Task功能：\n\n\npublic Task\nCreateCallbackData\n CreateTaskAsync(string tablename, IBmobWritable data);\npublic Task\nCreateCallbackData\n CreateTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nUpdateCallbackData\n UpdateTaskAsync(string tablename, string objectId, IBmobWritable data);\npublic Task\nUpdateCallbackData\n UpdateTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nDeleteCallbackData\n DeleteTaskAsync(string tablename, string objectId);\npublic Task\nDeleteCallbackData\n DeleteTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nT\n GetTaskAsync\nT\n(string tablename, string objectId);\npublic Task\nT\n GetTaskAsync\nT\n(T data) where T : BmobTable;\npublic Task\nQueryCallbackData\nT\n FindTaskAsync\nT\n(string tablename, BmobQuery query);\n\npublic Task\nBmobUser\n SignupTaskAsync(BmobUser user);\npublic Task\nT\n SignupTaskAsync\nT\n(T user) where T : BmobUser;\npublic Task\nUpdateCallbackData\n UpdateUserTaskAsync(string objectId, BmobUser data, string sessionToken);\npublic Task\nUpdateCallbackData\n UpdateUserTaskAsync\nT\n(T data) where T : BmobUser;\npublic Task\nDeleteCallbackData\n DeleteUserTaskAsync(string objectId, string sessionToken);\npublic Task\nDeleteCallbackData\n DeleteUserTaskAsync\nT\n(T data) where T : BmobUser;\npublic Task\nEmptyCallbackData\n EmailVerifyTaskAsync(string email);\npublic Task\nEmptyCallbackData\n PhoneVerifyTaskAsync(string phone);\n\npublic Task\nEmptyCallbackData\n ResetTaskAsync(string email);\npublic Task\nEmptyCallbackData\n ResetTaskAsync(string phone, string smsCode, string newPassword);\n\npublic Task\nBmobUser\n LoginTaskAsync(string username, string pwd);\npublic Task\nT\n LoginTaskAsync\nT\n(string username, string pwd) where T : BmobUser;\n\npublic Task\nEmptyCallbackData\n PushTaskAsync(PushParamter param);\npublic Task\nTimeStampCallbackData\n TimestampTaskAsync();\n\npublic Task\nT\n EndpointTaskAsync\nT\n(string eMethod);\npublic Task\nT\n EndpointTaskAsync\nT\n(string eMethod, IDictionary\nstring, object\n parameters);\n\npublic Task\nUploadCallbackData\n FileUploadTaskAsync(BmobLocalFile file);\npublic Task\nUploadCallbackData\n FileUploadTaskAsync(string localPath);\npublic Task\nEmptyCallbackData\n FileDeleteTaskAsync(BmobFile file);\npublic Task\nEmptyCallbackData\n FileDeleteTaskAsync(string group, string url);\n\npublic Task\nList\nDictionary\nstring, object\n BatchTaskAsync(BmobBatch requests);\npublic Task\nThumbnailCallbackData\n ThumbnailTaskAsync(ThumbnailParameter param);\n\n\n\n\n关于接口方法的使用见详细开发文档。上面列表与实际可能有一点出错，可以查看最新版的源代码\nhttps://github.com/bmob/BmobSharp\n\n\n数据类型\n\n\n目前为止，我们支持的数据类型有String、int、Boolean、Array对象类型。同时Bmob也支持BmobDate、BmobGeoPoint、BmobFile数据类型。\n\n\n对象\n\n\n一个对象对应了数据表中的一条数据。C# SDK如果需要对数据进行操作，必须创建一个数据对象模型。\n\n\n数据对象模型\n\n\nBmob的数据操作是建立在表基础上的，SDK封装了BmobTable来处理，所以任何要操作的数据对象推荐继承自BmobTable类。BmobTable对象包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId为对象的唯一标识，可以理解为数据表中的主键，createdAt为数据的创建时间，updatedAt为数据的最后修改时间，ACL为数据的操作权限。例如，游戏中可能会用到的分数对象GameScore,它可能包含score、playerName、cheatMode等属性，那么，对应的数据对象模型的示例代码如下：\n\n\npublic class GameScore : BmobTable \n{\n    /// \nsummary\n\n    /// 玩家名称\n    /// \n/summary\n\n    public string playerName { get; set; }\n\n    /// \nsummary\n\n    /// 游戏分数\n    /// \n/summary\n\n    public BmobInt score { get; set; }\n\n    /// \nsummary\n\n    /// 是否作弊\n    /// \n/summary\n\n    public BmobBoolean cheatMode { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n        //读取属性值\n        this.playerName = input.getString(\nplayerName\n);\n        this.score = input.getInt(\nscore\n);\n        this.cheatMode = input.getBoolean(\ncheatMode\n);\n    }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n        //写到发送端\n        output.Put(\nplayerName\n, this.playerName);\n        output.Put(\nscore\n, this.score);\n        output.Put(\ncheatMode\n, this.cheatMode);\n    }\n}\n\n\n\n\n特殊对象\n\n\n为了提供更好的服务，BmobSDK中提供了BmobUser和BmobRole两个特殊的BmobTable对象来完成不同的功能，在这里我们统一称为特殊对象。\n\n\n\n\nBmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的用户部分。\n\n\nBmobRole对象主要用于角色管理中，它对应Web端的Role表。使用BmobRole对象可以方便的为不同的用户提供不同的角色控制权限。\n\n\n\n\n添加数据\n\n\n添加数据非常简单，任何BmobTable对象都具有Create方法可以用于将当前对象的内容保存到服务端。 例如，你现在要保存一条游戏分数的记录，可以这样做：\n\n\nvar data = new GameScore();\ndata.score = 25;\ndata.playerName = \nbmob\n;\ndata.cheatMode = false;\n\nbmobUnity.Create(TABLENAME, data, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n运行完以上代码后，数据即可保存到服务器端。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你应用程序的数据浏览项目中进行查看。你应该看到类似这样的结果：\n\n\nobjectId: \n0c6db13c\n, score: 25, playerName: \nbmob\n, cheatMode: false,createdAt:\n2013-09-27 10:32:54\n, updatedAt:\n2013-09-27 10:32:54\n\n\n\n\n\n这里需要注意几点：\n\n\n\n\n在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。\n\n\n如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。\n\n\n每个BmobTable对象都有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createdAt和updatedAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。ACL是数据的操作权限，这个在没有指定的情况下为空。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。\n\n\n\n\n查询数据\n\n\n数据的查询可能是每个应用都会频繁使用到的，BmobUnity SDK提供了BmobQuery类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。\n\n\n查询所有数据\n\n\n查询某个数据表中的所有数据是非常简单的查询操作，如查询玩家名字为“bmob”的所有数据的示例代码如下：\n\n\n//创建一个BmobQuery查询对象\nBmobQuery query = new BmobQuery();\n//查询playerName的值为bmob的记录\nquery.WhereEqualTo(\nplayerName\n, \nbmob\n);\nbmobUnity.Find\nGameScore\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nGameScore\n list = resp.results;\n    foreach (var game in list)\n    {\n        print(\n获取的对象为： \n + game.ToString());\n    }\n});\n\n\n\n\n这里需要注意一点的是： 默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可点击查看分页查询一节。\n\n\n查询单条数据\n\n\n当我们知道某条数据的objectId时，就可以根据objectId直接获取单条数据对象。例如：查询objectId为68ee8131ca的人员信息。\n\n\nbmobUnity.Get\nGameScore\n(TABLENAME, \n68ee8131ca\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    GameScore game = resp;\n    print(\n获取的对象为： \n + game.ToString());\n});\n\n\n\n\n条件查询\n\n\n上面我们已经看到了一个最简单的“字段值等于某个值”的简单条件的使用方法，BmobUnity为大家提供了更多的支持条件查询的方法。\n\n\n如果需要查询playerName不等于“Barbie”的数据时可以使用WhereNotEqualTo的查询语法，示例代码如下：\n\n\nquery.WhereNotEqualTo(\nplayerName\n, \nBarbie\n);\n\n\n\n\n你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据：\n\n\nquery.WhereNotEqualTo(\nplayerName\n, \nBarbie\n);     //名字不等于Barbie\nquery.WhereGreaterThan(\nscore\n, 60);      //分数大于60岁\n\n\n\n\n你还可以使用一些比较查询，示例代码如下：\n\n\n//分数 \n 50\nquery.WhereLessThan(\nscore\n, 50);\n//分数 \n= 50\nquery.WhereLessThanOrEqualTo(\nscore\n, 50);\n//分数 \n 50\nquery.WhereGreaterThan(\nscore\n, 50);\n//分数 \n= 50\nquery.WhereGreaterThanOrEqualTo(\nscore\n, 50);\n\n\n\n\n如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，可以使用WhereContainedIn方法（查询“字段的值在指定集合中”的记录列表）来实现，示例代码如下：\n\n\nquery.WhereContainedIn(\nplayerName\n, {\nBarbie\n, \nJoe\n, \nJulia\n});\n//或者使用下面的语句\nquery.WhereContainedIn(\nplayerName\n, \nBarbie\n, \nJoe\n, \nJulia\n);\n\n\n\n\n分页查询\n\n\n在数据比较多的情况下，你往往需要显示加载一部分数据就可以了，这样可以节省用户的流量和提升数据加载速度，提高用户体验。这时候，我们使用Limit方法就可以限制查询结果的数据条数。默认情况下Limit的值为10，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\n//设置最多返回20条记录\nquery.Limit(\n20\n);\n\n\n\n\n在Limit的基础上进行分页显示数据的一个比较合理的解决办法是：使用SKip方法，跳过前多少条数据。默认情况下Skip的值为10，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\n//忽略前20条数据\nquery.Skip(20);\n\n\n\n\n结果排序\n\n\n如果你想对游戏分数进行升序排序，示例代码可如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderBy(\nscore\n);\n\n\n\n\n如果你想对游戏分数进行降序排序，示例代码可如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderByDescending(\nscore\n);\n\n\n\n\n如果你想对两个或者以上的字段进行升序排序，如对score和cheatMode进行升序排序，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderBy(\nscore\n).ThenBy(\ncheatMode\n);\n\n\n\n\n如果你想对两个或者以上的字段进行降序排序，如对score和cheatMode进行降序排序，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.OrderByDescending(\nscore\n).ThenByDescending(\ncheatMode\n);\n\n\n\n\n这些排序的方法还可以混合使用，具体详细用法不再详述。\n\n\n统计对象数量\n\n\n如果你想查询一个特定玩家玩的游戏场数，那么，示例代码可如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.WhereEqualTo(\nplayerName\n, \nbmob\n);\nquery.Count ();\nbmobUnity.Find\nGameScore\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    List\nGameScore\n list = resp.results;\n    BmobInt count = resp.count;\n    print(\n满足条件的对象个数为： \n + count.Get());\n    foreach (var game in list)\n    {\n        print(\n获取的对象为： \n + game.ToString());\n    }\n});\n\n\n\n\n或\n查询\n\n\n上面提到的查询语句都是and作为连接词的条件查询，但很多时候你还需要使用到“或（Or）”查询，如，你想查找GameScore表中 score 大于 90 或者 cheatMode 等于 true 的记录，示例代码如下：\n\n\nBmobQuery q1 = new BmobQuery();\nq1.WhereGreaterThan(\nscore\n, 90);\n\nBmobQuery q2 = new BmobQuery();\nq2.WhereEqualTo(\ncheatMode\n, true);\n\n//Or查询\nq1 = q1.Or(q2);\n\n\n\n\nOr查询是可变参数方法，你可以在里面放更多的查询对象，当然了，在Or查询方法里面的参数连接词为and。\n\n\n查询指定列\n\n\n有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的Select方法来实现。如从GameScore表中查找playerName的值的示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\nquery.Select(\nplayerName\n);\nbmobUnity.Find\nGameScore\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    List\nGameScore\n list = resp.results;\n    foreach (var game in list)\n    {\n    }\n});\n\n\n\n\n指定多列时多次调用即可，如：\n\n\nBmobQuery query = new BmobQuery();\nquery.Select(\nplayerName\n, \nscore\n);\n\n\n\n\n删除与修改数据\n\n\n修改数据\n\n\n更新一个对象也是非常简单。例如：将GameScore表中objectId为0c6db13c的游戏分数修改为77.\n\n\nGameScore game = new GameScore();\ngame.score = 77;\nbmobUnity.Update(TABLENAME, \n68ee8131ca\n, game, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n修改失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n修改成功, @\n + resp.updatedAt);\n });\n\n\n\n\n删除数据\n\n\n从服务器删除对象。例如：将GameScore表中objectId为68ee8131ca的数据删除。\n\n\nbmobUnity.Delete(\nGameScore\n, \n68ee8131ca\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n删除失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n删除成功, @\n + resp.msg);\n});\n\n\n\n\n数据关联\n\n\n关联数据的对象模型\n\n\n数据可以和其他数据进行关联（使用BmobPointer关联类型），就像是传统数据库中的主外键关系一样，如：一条微博由一个用户发布，可以有多个用户评论，每条评论信息对应一个用户。这时候，微博表对应的对象模型就应该如下：\n\n\npublic class Weibo : BmobTable\n{\n    // 发布的微博\n    public string message { get; set; }\n    // 微博的作者\n    public BmobPointer\nBmobUser\n user { get; set; }\n    // 微博的图片地址\n    public string pic;\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.message = input.getString(\nmessage\n);\n        this.user = input.Get\nBmobPointer\nBmobUser\n(\nuser\n);\n        this.pic = input.getString(\npic\n);\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put(\nmessage\n, this.message);\n        output.Put(\nuser\n, this.user);\n        output.Put(\npic\n, this.pic);\n    }\n}\n\n\n\n\n评论表对应的对象模型就应该如下：\n\n\npublic class Comment : BmobTable\n{\n    // 用户的评论\n    public string comment { get; set; }\n    // 发布评论的用户\n    public BmobPointer\nBmobUser\n user { get; set; }\n    // 评论的微博\n    public BmobPointer\nWeibo\n weibo { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.comment = input.getString(\ncomment\n);\n        this.user = input.Get\nBmobPointer\nBmobUser\n(\nuser\n);\n        this.weibo = input.Get\nBmobPointer\nWeibo\n(\nweibo\n);\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put(\ncomment\n, this.comment);\n        output.Put(\nuser\n, this.user);\n        output.Put(\nweibo\n, this.weibo);\n    }\n}\n\n\n\n\n添加关联关系\n\n\n保存带有关联关系的评论表的数据的方法和保存其他数据模型的方法一样，还是使用BmobUnity对象的Create方法，示例代码如下：\n\n\n//获取当前登录用户信息\nGameUser user = BmobUser.CurrentUser();\nvar comment = new Comment();\n// 设定评论内容\ncomment.comment = \n发布的评论信息\n;\n// 设定评论人\ncomment.user = new BmobPointer\nBmobUser\n(user);\n// 设定评论对应的微博\nWeibo weibo = new Weibo();\nweibo.objectId = \nZGwboItm\n;\ncomment.weibo = new BmobPointer\nWeibo\n(weibo);;    \n\nbmobUnity.Create(TABLENAME, comment, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n添加失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n添加成功, @\n + resp.createAt);\n});\n\n\n\n\n修改关联对象\n\n\n关联对象的修改和普通BmobTable对象的修改一样，只需设置要更新的属性值，然后调用Update方法即可。下面假设将objectId为ef8e6agg28的评论记录的作者修改为其他人(这里是直接把当前用户的objectId设置为ZGwboItm)。\n\n\nGameUser user = BmobUser.CurrentUser();\nuser.objectId = \nZGwboItm\n;\nComment comment = new Comment();\n// SDK中有添加隐式转换，会把GameUser对象转换成BmobPointer\nGameUser\n\ncomment.user = user;\nbmobUnity.Update(TABLENAME, \nef8e6agg28\n, comment, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n修改失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n修改成功, @\n + resp.updatedAt);\n});\n\n\n\n\n查询关联对象\n\n\n如果你想要查询当前用户发表的所有评论信息，可以跟其他查询一样使用WhereEqualTo，示例代码如下：\n\n\nBmobQuery query = new BmobQuery();\n//按发布时间降序排列\nquery.OrderByDescending(\nupdatedAt\n);\n//获取当前用户信息\nGameUser user = BmobUser.CurrentUser();\n//查询当前用户的所有评论\nquery.WhereEqualTo(\nuser\n, new BmobPointer\nBmobUser\n(user));    \n// or use\n// query.WhereMatchesQuery(\nuser\n, user);\nbmobUnity.Find\nComment\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nComment\n commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print(\n获取的对象为： \n + comment.ToString());\n    }\n});\n\n\n\n\n如果你想要查询带有图片的微博的评论列表，即在Comment表中对Weibo表进行内部的查询，可以使用WhereMatchesQuery\n方法(DOC:查询的对象中的某个列符合另一个指针值)进行内部查询：\n\n\nWeibo wb = new Weibo();\n// Weibo对象赋值（条件赋值）\n\nBmobQuery query = new BmobQuery();\nquery.WhereMatchesQuery\nWeibo\n(\npic\n, new BmobPointer\nWeibo\n(wb)); \nbmobUnity.Find\nComment\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nComment\n commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print(\n获取的对象为： \n + comment.ToString());\n    }\n});\n\n\n\n\n反之，不想匹配某个子查询，你可以使用WhereDoesNotMatchQuery方法。 比如为了查询不带图片的微博的评论列表，就可以将上面的示例代码中的WhereMatchesQuery方法替换为WhereDoesNotMatchQuery方法。\n\n\n如果你想获取最新的10条评论，同时包含这些评论对应的微博，实现代码可以为如下：\n\n\nBmobQuery query = new BmobQuery();\n// 限制10条\nquery.Limit(10); \n//按创建时间排序\nquery.Order(\ncreatedAt\n); \n//同时将对应的微博信息也查询出来\nquery.Include(\nweibo\n);\n//执行查询\nbmobUnity.Find\nComment\n(TABLENAME, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nComment\n commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print(\n获取的对象为： \n + comment.ToString());\n    }\n});\n\n\n\n\n你可以使用\n.\n号（英语句号）操作符来并列获得 Include 中的内嵌的对象。比如，你同时想 Include 一个 Comment 的 weibo 和weibo的 user（微博发布者）对象，你可以这样做：\n\n\nquery.Include(\nweibo.user\n);\n\n\n\n\n用户\n\n\n用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。\n\n\n有了这个类，你就可以在你的应用程序中添加用户账户功能。\n\n\nBmobUser是BmobTable的一个子类，它继承了BmobTable所有的方法，具有BmobTable相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。\n\n\n属性\n\n\nBmobUser除了从BmobTable继承的属性外，还有几个特定的属性： \n\n\n\n\nusername: 用户的用户名（必需）。 \n\n\npassword: 用户的密码（必需）。 \n\n\nemail: 用户的电子邮件地址（可选）。\n\n\n\n\n创建用户对象\n\n\n创建用户对象如下：\n\n\nBmobUser user = new BmobUser();\n\n\n\n\n如果你需要扩展用户资料信息，如给用户表添加生命值life和攻击指数attack，那么需要创建一个新的用户类，继承自BmobUser。示例代码如下：\n\n\npublic class GameUser : BmobUser\n{\n    public BmobInt life { get; set; }\n    public BmobInt attack { get; set; }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put(\nlife\n, this.life);\n        output.Put(\nattack\n, this.attack);\n    }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.life = input.getInt(\nlife\n);\n        this.attack = input.getInt(\nattack\n);\n    }\n}\n\n\n\n\n注册用户\n\n\n你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：\n\n\nBmobUser user = new BmobUser();\nuser.username = \nbmob\n;\nuser.password = \n123456\n;\n//邮箱用于找回密码\nuser.email = \npartnet@bmob.cn\n;\n//如使用了GameUser表的话，以下注册语句需要更改为：bmobUnity.Signup\nMyBmobUser\n(user,(resp, exception) =\n\nbmobUnity.Signup(user,(resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n注册失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n    print(\n注册成功\n);\n});\n\n\n\n\n在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。\n\n\n如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。\n\n\n你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。\n\n\n这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。\n\n\n设置邮箱验证功能\n\n\n\n\n登录用户\n\n\n当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。\n\n\nbmobUnity.Login\nGameUser\n(\nbmob\n, \n123456\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n登录失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n登录成功, @\n + resp.username + \n(\n + resp.life + \n)$[\n + resp.sessionToken + \n]\n);\n    print(\n登录成功, 当前用户对象Session： \n + BmobUser.CurrentUser.sessionToken);\n});\n\n\n\n\n获取当前用户\n\n\n登录之后，你可以通过如下示例代码获取当前登录用户的信息：\n\n\nBmobUser buser = BmobUser.CurrentUser;\n// 或者\nGameUser user = BmobUser.CurrentUser as GameUser;\n\n\n\n\n更新用户\n\n\n很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，示例代码如下：\n\n\nGameUser user = new GameUser();\nuser.attack = 1000;\n//需要知道用户记录的objectId和sessionToken信息\nbmobUnity.UpdateUser(\nobjectid\n, user, \nsessionToken\n, (resp, exception) =\n\n{\n    if (updateException != null)\n    {\n        print(\n保存失败, 失败原因为： \n + updateException.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + updateResp.updatedAt);\n});\n\n\n\n\n在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。\n\n\n查询用户\n\n\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下查询用户名为bmob的用户：\n\n\nBmobQuery query = new BmobQuery();\nquery.WhereEqualTo(\nusername\n, \nbmob\n);\nbmobUnity.Find\nGameUser\n(BmobUser.TABLE, query, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    List\nGameUser\n list = resp.results;\n    foreach (var user in list)\n    {\n        print(\n获取的对象为： \n + user.ToString());\n    }\n});\n\n\n\n\n密码重置\n\n\n一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。\n\n\n重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可，示例代码如下：\n\n\nbmobUnity.Reset(\nsupport@bmob.cn\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n重置密码请求失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n重置密码请求发送成功！\n);\n});\n\n\n\n\n密码重置流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nemailVerified 字段有 3 种状态可以考虑：\n\n\n\n\ntrue : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。\n\n\nfalse : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。\n\n\nmissing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。\n\n\n\n\n请求验证Email\n\n\n发送给用户的邮箱验证邮件会在一周内失效，可以通过调用 EmailVerify 来强制重新发送：\n\n\nbmobUnity.EmailVerify(\nsupport@bmob.cn\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n邮箱验证请求失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n邮箱验证请求发送成功！\n);\n});\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看Bmob数据与安全页面，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。\n\n\n\n\n默认访问权限\n\n\n在没有显示指定的情况下，每一个BmobTable中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的ReadAccess方法和WriteAccess方法，如设置所有用户的读权限为true，写权限为false的示例代码如下：\n\n\nBmobACL acl = new BmobACL();\nacl.ReadAccess(\n*\n);\n\n\n\n\n这里说明一点的是： \n*\n号表示所有用户。ACL列为空表示所有用户可读可写；在不为空的情况下，读或写空缺表示没有对应权限。\n\n\n指定用户的访问权限\n\n\n如果你想对发表的微博设定一个权限：发表微博的作者有修改和删除的权限，其他用户只有读的权限，那么，可用如下的示例代码：\n\n\n//创建数据对象\nWeibo weibo = new Weibo();\nweibo.message = \n论电影的七个元素\n;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//设置所有人可读\nacl.ReadAccess(\n*\n);\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n如果要设定只有微博的作者有读写权限，其他人都没有读写权限，那么，可用如下的示例代码：\n\n\n//创建数据对象\nWeibo weibo = new Weibo();\nweibo.message = \n论电影的七个元素\n;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//参数是用户的objectId，这里设置为当前用户可读\nacl.ReadAccess(BmobUser.CurrentUser().objectId);\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n角色管理\n\n\n上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage = 100000;   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.ReadAccess(boos.objectId);    \nacl.ReadAccess(hr_zhang.objectId);\nacl.ReadAccess(cashier_xie.objectId);\nacl.ReadAccess(me.objectId);\n\n//设置老板和人事小张对这个工资的写权限\nacl.WriteAccess(boss.objectId);\nacl.WriteAccess(hr_zhang.objectId);\n\n//设置工资对象的ACL\nwageinfo.ACL =acl;\nbmobUnity.Create(TABLENAME, wageinfo, (resp, exception) =\n\n{\n    if(exception != null){\n        print(\n保存失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n保存成功, @\n + resp.createdAt);\n});\n\n\n\n\n但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：\n\n\n//这里创建四个用户对象指针，分别为老板、人事小张、出纳小谢和自己\n// just for test\nBmobPointer\nBmobUser\n boss = new BmobUser() { objectId = \n1\n };\nBmobPointer\nBmobUser\n hr_zhang = new BmobUser() { objectId = \n2\n };\nBmobPointer\nBmobUser\n hr_luo = new BmobUser() { objectId = \n3\n };\nBmobPointer\nBmobUser\n cashier_xie = new BmobUser() { objectId = \n4\n };\nBmobPointer\nBmobUser\n me = new BmobUser() { objectId = \n5\n };\n\n{\n    //创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\n    BmobRole hr = new BmobRole();\n    hr.name = \nHR\n;\n    var users = new BmobRelation\nBmobUser\n();\n    users.Add(hr_zhang);\n    users.Add(hr_luo);\n\n    //将hr_zhang和hr_luo归属到hr角色中\n    hr.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(hr);\n    FinishedCallback(future.Result, null);\n}\n\n{\n    BmobRole cashier = new BmobRole();\n    cashier.name = \nCashier\n;\n    var users = new BmobRelation\nBmobUser\n();\n    users.Add(cashier_xie);\n\n    //将cashier_xie归属到cashier角色中\n    cashier.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(cashier);\n    FinishedCallback(future.Result, null);\n}\n\n\n\n\n根据Role设置ACL：\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage =100000;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\n// 给hr角色设置读权限\nacl.RoleReadAccess(hr.name);\n// 给cashier角色设置读权限\nacl.RoleReadAccess(cashier.name);\n\n// 设置老板拥有写权限\nacl.RoleWriteAccess(boss.name);\n// 设置hr角色拥有写权限\nacl.RoleWriteAccess(hr.name);\n\n//设置工资对象的ACL\nwageinfo.ACL = acl;\n//添加数据\nbmobUnity.Create(TABLENAME, wageinfo, null);\n\n\n\n\n需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询，可以轻松实现查找出离当前用户最接近的信息或地点的功能。\n\n\n创建地理位置对象\n\n\n首先需要创建一个BmobGeoPoint对象。例如，创建一个北纬39.913768382429105度-东经116.39727786183357度的BmobGeoPoint对象：\n\n\nBmobGeoPoint point = new BmobGeoPoint(39.913768382429105, 116.39727786183357);\n\n\n\n\n查询地理位置信息\n\n\n现在，你的数据表中有了一定的地理坐标对象的数据， 就可以使用BmobQuery对象的WhereNear方法来找出最接近某个点的信息，示例代码如下（假设Person表中有一个名为area的地理坐标类型的字段）：\n\n\nBmobQuery query = new BmobQuery();\nbmobQuery.WhereNear(\narea\n, new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.Limit(10);    //获取最接近用户地点的10条数据\nbmobUnity.Find\nPerson\n(\nPerson\n, bmobQuery, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nPerson\n list = resp.results;\n    foreach (var p in list)\n    {\n        print(\n获取的对象为： \n + p.ToString());\n    }\n});\n\n\n\n\n要限制查询指定距离范围的数据可以使用WhereWithinDistance，即：\n\n\n//(112.934755, 24.52065)坐标点10公里内\nquery.WhereWithinDistance(\narea\n, new BmobGeoPoint(112.934755, 24.52065), 10);\n\n\n\n\n要查询一个矩形范围内的信息可以使用addWhereWithinGeoBox来实现：\n\n\nBmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery query = new BmobQuery();\nquery.WhereWithinGeoBox(\narea\n, southwestOfSF, northeastOfSF);\nbmobUnity.Find\nPerson\n(\nPerson\n, bmobQuery, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n查询失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List\nPerson\n list = resp.results;\n    foreach (var p in list)\n    {\n         print(\n获取的对象为： \n + p.ToString());\n    }\n});\n\n\n\n\n注意事项 目前有几个需要注意的地方：\n\n\n\n\n每个BmobTable数据对象中只能有一个BmobGeoPoint对象。\n\n\n地理位置的点不能超过规定的范围。纬度的范围应该是在-90.0到90.0之间。经度的范围应该是在-180.0到180.0之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n\n\n原子计数器\n\n\n很多游戏可能会有计数器功能的需求，比如某个玩家的比赛总分score。Bmob提供了非常便捷的方式来保证原子性的修改某一记录（这条记录的objectId为28dd44a271）某字段的值。示例代码如下：\n\n\nGameScore object = new GameScore();\nobject.Increment(\nscore\n, 1000);\n//28dd44a271为这条记录的objectId\nbmobUnity.Update(TABLENAME, \n28dd44a271\n, object, FinishedCallback);\n\n\n\n\n文件\n\n\nBmob可以让你将文件存储到服务器中，常见的文件类型，如图像文件、影像文件、音乐文件和任何其他二进制数据，都可以直接上传到云端文件系统中，示例代码如下：\n\n\nbmobUnity.FileUpload(\nC:/Intel/Logs/IntelGFXCoin.log\n, (resp, exception) =\n\n{\n    if (exception != null)\n    {\n        print(\n上传失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n    print(\n上传成功，返回数据： \n + resp.ToString());\n});\n\n\n\n\nresp的返回值为UploadCallbackData对象：\n\n\n// 文件名\npublic string filename { get; set; }\n/// 文件组名\npublic string group { get; set; }\n/// 相对于Bmob文件服务器的位置\npublic string url { get; set; }\n/// 文件请求的地址\npublic string getPath()\n\n\n\n\n这里需要说明一点的是：单个上传的文件大小不可超过10M。\n\n\n\n\n与结合用户表实例\n\n\n\n\n一些用户不知道上传的附件和其他表结合怎么使用。下面介绍实际的案例：上传用户的头像\n\n\n对象类：\n\n\n    public class GameUser : BmobUser\n    {\n        public BmobFile File{get; set;}\n\n        public override void readFields(BmobInput input)\n        {\n            base.readFields(input);\n\n            this.File = input.Get\nBmobFile\n(\nfile\n);\n        }\n\n        public override void write(BmobOutput output, Boolean all)\n        {\n            base.write(output, all);\n\n            output.Put(\nfile\n, this.File);\n        }\n\n    }\n\n\n\n\n上传图片，并把图片保存到新用户User记录：\n\n\n    Byte[] data = null;\n    using (var stream = File.OpenRead(\nC:/Users/winse/Desktop/1.png\n))\n    {\n        data = stream.ReadAsBytes();\n    }\n\n    var ffuture = Bmob.FileUploadTaskAsync(new BmobLocalFile(data, \n21.png\n));\n\n    GameUser user = new GameUser();\n    user.email = \n1324@qq.com\n;\n    user.phone = \n1234\n;\n    user.username = \n1234\n;\n    user.password = \n123\n;\n\n    user.File = ffuture.Result;\n\n    var future = Bmob.SignupTaskAsync(user);\n    var signResponse = future.Result;\n...\n\n\n\n\n云端代码\n\n\n云端代码的调用方法非常简单，如下为调用执行云端方法test的实现代码：\n\n\nBmob.Endpoint\nHashtable\n(\ntest\n, (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n调用失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n\n    print(\n返回对象为： \n + resp);\n});\n\n\n\n\n相关云端代码的编写方式，请参考云端代码开发文档。\n\n\nC#调用云端代码的返回值为json字符串，即不能只返回一个单值的对象！\n\n\n\n\n不正确的使用方式：\n\n\n\n\nfunction onRequest(request, response, modules) {\nresponse.end(\njust string...\n);\n}              \n\n\n\n\n\n\nC#中正确的方式：\n\n\n\n\n云端代码：\n\n\nfunction onRequest(request, response, modules) {\n    var res =  {\nvalue\n: \njust string...\n} ;\n    response.end(JSON.stringify(res));\n}                         \n\n\n\n\nC#调用代码：\n\n\n[TestMethod()]\npublic void EndpointParamAndStringTest()\n{\n    var p = new Dictionary\nString, Object\n();\n\n    var future = Bmob.EndpointTaskAsync\nObject\n(\ntestString\n, p);\n    FinishedCallback(future.Result, null);\n}\n\n\n\n\n\n\n带参数返回map和list的例子\n\n\n\n\n[TestMethod()]\npublic void EndPointTest()\n{\n    //var future = Bmob.EndpointTaskAsync\nQueryCallbackData\nObject\n(\nsecond\n, null);\n    //FinishedCallback(future.Result, null);\n\n    var future = Bmob.EndpointTaskAsync\nList\nobject\n(\ntestParam\n, new BmobKV().Put(\na\n, \nwinse\n));\n    FinishedCallback(future.Result, null);\n\n--\n\nfunction onRequest(request, response, modules) {\n\n    //获取数据库对象 \n    var db = modules.oData; \n\n    var name = request.body.a;\n    //获取\n    db.find({ \n        table:'StudentScore',\n        \nwhere\n:{\nname\n:name}  \n    },function(err,data){\n        response.send(JSON.parse(data).results);\n    }); \n\n}\n\n\n\n\n\n\n\n\n获取服务器时间\n\n\n在BmobWindows对象中提供了一个方法，用于获取服务器时间。\n\n\nBmobWindows bmobWindows = new BmobWindows();\nbmobWindows.Timestamp( (resp, exception) =\n \n{\n    if (exception != null)\n    {\n        print(\n请求失败, 失败原因为： \n + exception.Message);\n        return;\n    }\n    //返回服务器时间（单位：秒）\n    print(\n返回时间戳为： \n + resp.timestamp); \n    print(\n返回格式化的日期为： \n + resp.datetime); \n}\n);\n\n\n\n\n时间\n\n\nBmobDate对应服务端的Date类型。以\nyyyy-MM-dd HH:mm:ss\n的格式进行传输。\n\n\nSDK提供了DateTime到BmobDate的隐式转化，简化BmobDate的实例化。\n\n\n例如，查询在某个时间段内新增的数据，由于一个字段涉及到两个条件，需要使用符合查询功能：\n\n\nBmobDate start = new DateTime(2014, 10, 1);\nBmobDate end = new DateTime(2015, 1, 1);\n\nvar startQuery = new BmobQuery();\nstartQuery.WhereGreaterThanOrEqualTo(\ncreatedAt\n, start);\n\nvar endQuery = new BmobQuery();\nendQuery.WhereLessThan(\ncreatedAt\n, end);\n\nvar query = startQuery.And(endQuery);\nquery.Limit(0);\nquery.Count();\n\nvar future = Bmob.FindTaskAsync\nObject\n(TABLENAME, query);\n// 处理结果\n// var result = future.Result;\n\n\n\n\n\nFAQ\n\n\n\n\n请求信息查看\n\n\n\n\n在开发过程中，其实很多问题开发者自己多确认下就能解决问题。SDK提供了查看发送请求到服务端的开关，只需要注册一下调试信息的输出方法即可。\n\n\nBmobDebug.Register(msg =\n { Debug.WriteLine(msg); });\nBmobDebug.level = BmobDebug.Level.TRACE;\n\n\n\n\n在输出窗口，可以查看每次请求的appkey、请求数据。\n\n\n\n\n关于Task，以及Windowsphone开发UI线程问题\n\n\n\n\n新版本的SDK针对每个原有接口增加了对应Task接口方法，方便异步调用。这样就没有必要每次都callback回调，如果调用是多个线性的请求，那么使用callback代码会很难理解。\n\n\n如果是开发desktop的应用，还可以等待结果的返回，但是在手机端，系统不允许有长时间等待的，要么使用callback要么使用异步。\n\n\n使用回调： \n\n\n        private void create_Click(object sender, RoutedEventArgs e)\n        {\n            BmobApi table = new BmobApi();\n            table.name = \nhello wp\n;\n            Bmob.Create(TABLE_NAME, table, (resp, ex) =\n\n            {\n                string status = \nOK\n;\n                if (ex != null)\n                {\n                    status = \nERROR\n;\n                }\n\n                Dispatcher.BeginInvoke(() =\n\n                               {\n                                   updateStatus(create, status);\n                               });\n            });\n        }\n\n\n\n\n注意：在回调用如果需要更新UI，需要转到UI线程才行。\n\n\n使用异步：\n\n\n// async方式异步请求处理，非阻塞访问\n        private async void uploadBtn_Click(object sender, EventArgs e)\n        {\n            formstatus.Text = \n正在上传...\n;\n\n            var Result = await Bmob.FileUploadTaskAsync(fileText.Text);\n            FinishedCallback(Result, resultText);\n\n            bmobFile = Result;\n\n            enterDba.Enabled = true;\n            formstatus.Text = \n上传成功！\n;\n        }", 
            "title": "开发文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_2", 
            "text": "在Bmob平台注册后，每个账户可创建多个应用程序，创建的每个应用程序都有其独自的应用程序ID，此后所有的应用程序将凭其ID进行Bmob SDK的使用。即使只有一个应用程序，也可以以不同的版本进行测试和生产。", 
            "title": "应用程序"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bmob", 
            "text": "", 
            "title": "Bmob客户端初始化"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#unity", 
            "text": "要使用Bmob提供的服务，首先需要把BmobUnity附加到你应用程序的Camara，然后获取BmobUnity脚本组件，才能进行下一步的操作。(把图中的Application Id换成你应用的appkey)   public class HelloBmob : MonoBehaviour\n{\n    //BmobUnity脚本组件实例\n    private BmobUnity bmobUnity;\n\n    // 初始化\n    void Start()\n    {\n        //获取BmobUnity脚本组件\n        bmobUnity = gameObject.GetComponent BmobUnity ();\n    }", 
            "title": "Unity"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#deskstop", 
            "text": "BmobWindows Bmob = new BmobWindows();\nBmob.initialize( 4414150cb439afdf684d37dc184e0f9f ,  e1deb317442129c125b228ddf78e5f22 ); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =  { Debug.WriteLine(msg); }); // 用于调试输出请求参数", 
            "title": "Deskstop"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#windowsphone", 
            "text": "BmobWindowsPhone Bmob = new BmobWindowsPhone();\nBmob.initialize( 4414150cb439afdf684d37dc184e0f9f ,  e1deb317442129c125b228ddf78e5f22 ); // 替换成你的appkey/RestKey\nBmobDebug.Register(msg =  { Debug.WriteLine(msg); }); // 用于调试输出请求参数", 
            "title": "Windowsphone"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bmob_1", 
            "text": "SDK组件目前提供了如下的方法供大家使用：  // 初始化组件（可供动态切换appKey、restKey）\npublic void initialize(string appKey, string restKey);\n\n//////////////////////////////////////////////\n//\n// 数据处理\n//\n//////////////////////////////////////////////\n\npublic void Create(string tablename, IBmobWritable data, BmobCallback cn.bmob.response.CreateCallbackData  callback);\npublic void Create T (T data, BmobCallback cn.bmob.response.CreateCallbackData  callback) where T : BmobTable;\npublic void Delete(string tablename, string objectId, BmobCallback cn.bmob.response.DeleteCallbackData  callback);\npublic void Delete T (T data, BmobCallback cn.bmob.response.DeleteCallbackData  callback) where T : BmobTable;\npublic void Update(string tablename, string objectId, IBmobWritable data, BmobCallback cn.bmob.response.UpdateCallbackData  callback);\npublic void Update T (T data, BmobCallback cn.bmob.response.UpdateCallbackData  callback) where T : BmobTable;\npublic void Find T (string tablename, BmobQuery query, BmobCallback cn.bmob.response.QueryCallbackData T  callback);\npublic void Get T (string tablename, string objectId, BmobCallback T  callback);\npublic void Get T (T data, BmobCallback T  callback) where T : BmobTable;\n\n//////////////////////////////////////////////\n//\n// 用户处理\n//\n//////////////////////////////////////////////\n\n// 用户注册\npublic void Signup(BmobUser user, BmobCallback BmobUser  callback);\npublic void Signup T (T user, BmobCallback T  callback) where T : BmobUser;\npublic void DeleteUser(string objectId, string sessionToken, BmobCallback cn.bmob.response.DeleteCallbackData  callback);\npublic void DeleteUser T (T data, BmobCallback cn.bmob.response.DeleteCallbackData  callback) where T : BmobUser;\npublic void UpdateUser(string objectId, BmobUser data, string sessionToken, BmobCallback cn.bmob.response.UpdateCallbackData  callback);\npublic void UpdateUser T (T data, BmobCallback cn.bmob.response.UpdateCallbackData  callback) where T : BmobUser;\n\n// 发送邮箱验证\npublic void EmailVerify(string email, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\n\n// 重置密码\npublic void Reset(string email, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\n\npublic void Login(string username, string pwd, BmobCallback BmobUser  callback);\npublic void Login T (string username, string pwd, BmobCallback T  callback) where T : BmobUser;\n\n//////////////////////////////////////////////\n//\n// 其他功能\n//\n//////////////////////////////////////////////\n\n// 调用云端代码\npublic void Endpoint T (string eMethod, BmobCallback T  callback);\npublic void Endpoint T (string eMethod, IDictionary string, object  parameters, BmobCallback T  callback);\n\npublic void FileDelete(BmobFile file, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileDelete(string group, string url, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback cn.bmob.response.UploadCallbackData  callback);\npublic void FileUpload(string localPath, BmobCallback cn.bmob.response.UploadCallbackData  callback);\n\npublic void Endpoint T (string eMethod, BmobCallback T  callback);\npublic void Endpoint T (string eMethod, IDictionary string, object  parameters, BmobCallback T  callback);\n\npublic void FileDelete(BmobFile file, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileDelete(string group, string url, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void FileUpload(BmobLocalFile file, BmobCallback cn.bmob.response.UploadCallbackData  callback);\npublic void FileUpload(string localPath, BmobCallback cn.bmob.response.UploadCallbackData  callback);\n\n// 获取服务器时间戳\npublic void Timestamp(BmobCallback cn.bmob.response.TimeStampCallbackData  callback);\n\npublic void Batch(BmobBatch requests, BmobCallback List Dictionary string, object  callback);\n\npublic void Push(PushParamter param, BmobCallback cn.bmob.response.EmptyCallbackData  callback);\npublic void Thumbnail(ThumbnailParameter param, BmobCallback cn.bmob.response.ThumbnailCallbackData  callback);  针对C# 4.0+，SDK为每个接口对应添加了Task功能：  public Task CreateCallbackData  CreateTaskAsync(string tablename, IBmobWritable data);\npublic Task CreateCallbackData  CreateTaskAsync T (T data) where T : BmobTable;\npublic Task UpdateCallbackData  UpdateTaskAsync(string tablename, string objectId, IBmobWritable data);\npublic Task UpdateCallbackData  UpdateTaskAsync T (T data) where T : BmobTable;\npublic Task DeleteCallbackData  DeleteTaskAsync(string tablename, string objectId);\npublic Task DeleteCallbackData  DeleteTaskAsync T (T data) where T : BmobTable;\npublic Task T  GetTaskAsync T (string tablename, string objectId);\npublic Task T  GetTaskAsync T (T data) where T : BmobTable;\npublic Task QueryCallbackData T  FindTaskAsync T (string tablename, BmobQuery query);\n\npublic Task BmobUser  SignupTaskAsync(BmobUser user);\npublic Task T  SignupTaskAsync T (T user) where T : BmobUser;\npublic Task UpdateCallbackData  UpdateUserTaskAsync(string objectId, BmobUser data, string sessionToken);\npublic Task UpdateCallbackData  UpdateUserTaskAsync T (T data) where T : BmobUser;\npublic Task DeleteCallbackData  DeleteUserTaskAsync(string objectId, string sessionToken);\npublic Task DeleteCallbackData  DeleteUserTaskAsync T (T data) where T : BmobUser;\npublic Task EmptyCallbackData  EmailVerifyTaskAsync(string email);\npublic Task EmptyCallbackData  PhoneVerifyTaskAsync(string phone);\n\npublic Task EmptyCallbackData  ResetTaskAsync(string email);\npublic Task EmptyCallbackData  ResetTaskAsync(string phone, string smsCode, string newPassword);\n\npublic Task BmobUser  LoginTaskAsync(string username, string pwd);\npublic Task T  LoginTaskAsync T (string username, string pwd) where T : BmobUser;\n\npublic Task EmptyCallbackData  PushTaskAsync(PushParamter param);\npublic Task TimeStampCallbackData  TimestampTaskAsync();\n\npublic Task T  EndpointTaskAsync T (string eMethod);\npublic Task T  EndpointTaskAsync T (string eMethod, IDictionary string, object  parameters);\n\npublic Task UploadCallbackData  FileUploadTaskAsync(BmobLocalFile file);\npublic Task UploadCallbackData  FileUploadTaskAsync(string localPath);\npublic Task EmptyCallbackData  FileDeleteTaskAsync(BmobFile file);\npublic Task EmptyCallbackData  FileDeleteTaskAsync(string group, string url);\n\npublic Task List Dictionary string, object  BatchTaskAsync(BmobBatch requests);\npublic Task ThumbnailCallbackData  ThumbnailTaskAsync(ThumbnailParameter param);  关于接口方法的使用见详细开发文档。上面列表与实际可能有一点出错，可以查看最新版的源代码 https://github.com/bmob/BmobSharp", 
            "title": "Bmob接口方法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_3", 
            "text": "目前为止，我们支持的数据类型有String、int、Boolean、Array对象类型。同时Bmob也支持BmobDate、BmobGeoPoint、BmobFile数据类型。", 
            "title": "数据类型"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_4", 
            "text": "一个对象对应了数据表中的一条数据。C# SDK如果需要对数据进行操作，必须创建一个数据对象模型。", 
            "title": "对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_5", 
            "text": "Bmob的数据操作是建立在表基础上的，SDK封装了BmobTable来处理，所以任何要操作的数据对象推荐继承自BmobTable类。BmobTable对象包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId为对象的唯一标识，可以理解为数据表中的主键，createdAt为数据的创建时间，updatedAt为数据的最后修改时间，ACL为数据的操作权限。例如，游戏中可能会用到的分数对象GameScore,它可能包含score、playerName、cheatMode等属性，那么，对应的数据对象模型的示例代码如下：  public class GameScore : BmobTable \n{\n    ///  summary \n    /// 玩家名称\n    ///  /summary \n    public string playerName { get; set; }\n\n    ///  summary \n    /// 游戏分数\n    ///  /summary \n    public BmobInt score { get; set; }\n\n    ///  summary \n    /// 是否作弊\n    ///  /summary \n    public BmobBoolean cheatMode { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n        //读取属性值\n        this.playerName = input.getString( playerName );\n        this.score = input.getInt( score );\n        this.cheatMode = input.getBoolean( cheatMode );\n    }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n        //写到发送端\n        output.Put( playerName , this.playerName);\n        output.Put( score , this.score);\n        output.Put( cheatMode , this.cheatMode);\n    }\n}", 
            "title": "数据对象模型"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_6", 
            "text": "为了提供更好的服务，BmobSDK中提供了BmobUser和BmobRole两个特殊的BmobTable对象来完成不同的功能，在这里我们统一称为特殊对象。   BmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的用户部分。  BmobRole对象主要用于角色管理中，它对应Web端的Role表。使用BmobRole对象可以方便的为不同的用户提供不同的角色控制权限。", 
            "title": "特殊对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_7", 
            "text": "添加数据非常简单，任何BmobTable对象都具有Create方法可以用于将当前对象的内容保存到服务端。 例如，你现在要保存一条游戏分数的记录，可以这样做：  var data = new GameScore();\ndata.score = 25;\ndata.playerName =  bmob ;\ndata.cheatMode = false;\n\nbmobUnity.Create(TABLENAME, data, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});  运行完以上代码后，数据即可保存到服务器端。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你应用程序的数据浏览项目中进行查看。你应该看到类似这样的结果：  objectId:  0c6db13c , score: 25, playerName:  bmob , cheatMode: false,createdAt: 2013-09-27 10:32:54 , updatedAt: 2013-09-27 10:32:54   这里需要注意几点：   在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。  如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。  每个BmobTable对象都有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createdAt和updatedAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。ACL是数据的操作权限，这个在没有指定的情况下为空。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。", 
            "title": "添加数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_8", 
            "text": "数据的查询可能是每个应用都会频繁使用到的，BmobUnity SDK提供了BmobQuery类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。", 
            "title": "查询数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_9", 
            "text": "查询某个数据表中的所有数据是非常简单的查询操作，如查询玩家名字为“bmob”的所有数据的示例代码如下：  //创建一个BmobQuery查询对象\nBmobQuery query = new BmobQuery();\n//查询playerName的值为bmob的记录\nquery.WhereEqualTo( playerName ,  bmob );\nbmobUnity.Find GameScore (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List GameScore  list = resp.results;\n    foreach (var game in list)\n    {\n        print( 获取的对象为：   + game.ToString());\n    }\n});  这里需要注意一点的是： 默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可点击查看分页查询一节。", 
            "title": "查询所有数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_10", 
            "text": "当我们知道某条数据的objectId时，就可以根据objectId直接获取单条数据对象。例如：查询objectId为68ee8131ca的人员信息。  bmobUnity.Get GameScore (TABLENAME,  68ee8131ca , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    GameScore game = resp;\n    print( 获取的对象为：   + game.ToString());\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_11", 
            "text": "上面我们已经看到了一个最简单的“字段值等于某个值”的简单条件的使用方法，BmobUnity为大家提供了更多的支持条件查询的方法。  如果需要查询playerName不等于“Barbie”的数据时可以使用WhereNotEqualTo的查询语法，示例代码如下：  query.WhereNotEqualTo( playerName ,  Barbie );  你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据：  query.WhereNotEqualTo( playerName ,  Barbie );     //名字不等于Barbie\nquery.WhereGreaterThan( score , 60);      //分数大于60岁  你还可以使用一些比较查询，示例代码如下：  //分数   50\nquery.WhereLessThan( score , 50);\n//分数  = 50\nquery.WhereLessThanOrEqualTo( score , 50);\n//分数   50\nquery.WhereGreaterThan( score , 50);\n//分数  = 50\nquery.WhereGreaterThanOrEqualTo( score , 50);  如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，可以使用WhereContainedIn方法（查询“字段的值在指定集合中”的记录列表）来实现，示例代码如下：  query.WhereContainedIn( playerName , { Barbie ,  Joe ,  Julia });\n//或者使用下面的语句\nquery.WhereContainedIn( playerName ,  Barbie ,  Joe ,  Julia );", 
            "title": "条件查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_12", 
            "text": "在数据比较多的情况下，你往往需要显示加载一部分数据就可以了，这样可以节省用户的流量和提升数据加载速度，提高用户体验。这时候，我们使用Limit方法就可以限制查询结果的数据条数。默认情况下Limit的值为10，示例代码如下：  BmobQuery query = new BmobQuery();\n//设置最多返回20条记录\nquery.Limit( 20 );  在Limit的基础上进行分页显示数据的一个比较合理的解决办法是：使用SKip方法，跳过前多少条数据。默认情况下Skip的值为10，示例代码如下：  BmobQuery query = new BmobQuery();\n//忽略前20条数据\nquery.Skip(20);", 
            "title": "分页查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_13", 
            "text": "如果你想对游戏分数进行升序排序，示例代码可如下：  BmobQuery query = new BmobQuery();\nquery.OrderBy( score );  如果你想对游戏分数进行降序排序，示例代码可如下：  BmobQuery query = new BmobQuery();\nquery.OrderByDescending( score );  如果你想对两个或者以上的字段进行升序排序，如对score和cheatMode进行升序排序，示例代码如下：  BmobQuery query = new BmobQuery();\nquery.OrderBy( score ).ThenBy( cheatMode );  如果你想对两个或者以上的字段进行降序排序，如对score和cheatMode进行降序排序，示例代码如下：  BmobQuery query = new BmobQuery();\nquery.OrderByDescending( score ).ThenByDescending( cheatMode );  这些排序的方法还可以混合使用，具体详细用法不再详述。", 
            "title": "结果排序"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_14", 
            "text": "如果你想查询一个特定玩家玩的游戏场数，那么，示例代码可如下：  BmobQuery query = new BmobQuery();\nquery.WhereEqualTo( playerName ,  bmob );\nquery.Count ();\nbmobUnity.Find GameScore (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    List GameScore  list = resp.results;\n    BmobInt count = resp.count;\n    print( 满足条件的对象个数为：   + count.Get());\n    foreach (var game in list)\n    {\n        print( 获取的对象为：   + game.ToString());\n    }\n});", 
            "title": "统计对象数量"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_15", 
            "text": "上面提到的查询语句都是and作为连接词的条件查询，但很多时候你还需要使用到“或（Or）”查询，如，你想查找GameScore表中 score 大于 90 或者 cheatMode 等于 true 的记录，示例代码如下：  BmobQuery q1 = new BmobQuery();\nq1.WhereGreaterThan( score , 90);\n\nBmobQuery q2 = new BmobQuery();\nq2.WhereEqualTo( cheatMode , true);\n\n//Or查询\nq1 = q1.Or(q2);  Or查询是可变参数方法，你可以在里面放更多的查询对象，当然了，在Or查询方法里面的参数连接词为and。", 
            "title": "或查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_16", 
            "text": "有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的Select方法来实现。如从GameScore表中查找playerName的值的示例代码如下：  BmobQuery query = new BmobQuery();\nquery.Select( playerName );\nbmobUnity.Find GameScore (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    List GameScore  list = resp.results;\n    foreach (var game in list)\n    {\n    }\n});  指定多列时多次调用即可，如：  BmobQuery query = new BmobQuery();\nquery.Select( playerName ,  score );", 
            "title": "查询指定列"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_17", 
            "text": "", 
            "title": "删除与修改数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_18", 
            "text": "更新一个对象也是非常简单。例如：将GameScore表中objectId为0c6db13c的游戏分数修改为77.  GameScore game = new GameScore();\ngame.score = 77;\nbmobUnity.Update(TABLENAME,  68ee8131ca , game, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 修改失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 修改成功, @  + resp.updatedAt);\n });", 
            "title": "修改数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_19", 
            "text": "从服务器删除对象。例如：将GameScore表中objectId为68ee8131ca的数据删除。  bmobUnity.Delete( GameScore ,  68ee8131ca , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 删除失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 删除成功, @  + resp.msg);\n});", 
            "title": "删除数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_20", 
            "text": "", 
            "title": "数据关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_21", 
            "text": "数据可以和其他数据进行关联（使用BmobPointer关联类型），就像是传统数据库中的主外键关系一样，如：一条微博由一个用户发布，可以有多个用户评论，每条评论信息对应一个用户。这时候，微博表对应的对象模型就应该如下：  public class Weibo : BmobTable\n{\n    // 发布的微博\n    public string message { get; set; }\n    // 微博的作者\n    public BmobPointer BmobUser  user { get; set; }\n    // 微博的图片地址\n    public string pic;\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.message = input.getString( message );\n        this.user = input.Get BmobPointer BmobUser ( user );\n        this.pic = input.getString( pic );\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put( message , this.message);\n        output.Put( user , this.user);\n        output.Put( pic , this.pic);\n    }\n}  评论表对应的对象模型就应该如下：  public class Comment : BmobTable\n{\n    // 用户的评论\n    public string comment { get; set; }\n    // 发布评论的用户\n    public BmobPointer BmobUser  user { get; set; }\n    // 评论的微博\n    public BmobPointer Weibo  weibo { get; set; }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.comment = input.getString( comment );\n        this.user = input.Get BmobPointer BmobUser ( user );\n        this.weibo = input.Get BmobPointer Weibo ( weibo );\n    }\n\n    public override void write(BmobOutput output, Boolean all)\n    {\n        base.write(output, all);\n\n        output.Put( comment , this.comment);\n        output.Put( user , this.user);\n        output.Put( weibo , this.weibo);\n    }\n}", 
            "title": "关联数据的对象模型"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_22", 
            "text": "保存带有关联关系的评论表的数据的方法和保存其他数据模型的方法一样，还是使用BmobUnity对象的Create方法，示例代码如下：  //获取当前登录用户信息\nGameUser user = BmobUser.CurrentUser();\nvar comment = new Comment();\n// 设定评论内容\ncomment.comment =  发布的评论信息 ;\n// 设定评论人\ncomment.user = new BmobPointer BmobUser (user);\n// 设定评论对应的微博\nWeibo weibo = new Weibo();\nweibo.objectId =  ZGwboItm ;\ncomment.weibo = new BmobPointer Weibo (weibo);;    \n\nbmobUnity.Create(TABLENAME, comment, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 添加失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 添加成功, @  + resp.createAt);\n});", 
            "title": "添加关联关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_23", 
            "text": "关联对象的修改和普通BmobTable对象的修改一样，只需设置要更新的属性值，然后调用Update方法即可。下面假设将objectId为ef8e6agg28的评论记录的作者修改为其他人(这里是直接把当前用户的objectId设置为ZGwboItm)。  GameUser user = BmobUser.CurrentUser();\nuser.objectId =  ZGwboItm ;\nComment comment = new Comment();\n// SDK中有添加隐式转换，会把GameUser对象转换成BmobPointer GameUser \ncomment.user = user;\nbmobUnity.Update(TABLENAME,  ef8e6agg28 , comment, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 修改失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 修改成功, @  + resp.updatedAt);\n});", 
            "title": "修改关联对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_24", 
            "text": "如果你想要查询当前用户发表的所有评论信息，可以跟其他查询一样使用WhereEqualTo，示例代码如下：  BmobQuery query = new BmobQuery();\n//按发布时间降序排列\nquery.OrderByDescending( updatedAt );\n//获取当前用户信息\nGameUser user = BmobUser.CurrentUser();\n//查询当前用户的所有评论\nquery.WhereEqualTo( user , new BmobPointer BmobUser (user));    \n// or use\n// query.WhereMatchesQuery( user , user);\nbmobUnity.Find Comment (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Comment  commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print( 获取的对象为：   + comment.ToString());\n    }\n});  如果你想要查询带有图片的微博的评论列表，即在Comment表中对Weibo表进行内部的查询，可以使用WhereMatchesQuery 方法(DOC:查询的对象中的某个列符合另一个指针值)进行内部查询：  Weibo wb = new Weibo();\n// Weibo对象赋值（条件赋值）\n\nBmobQuery query = new BmobQuery();\nquery.WhereMatchesQuery Weibo ( pic , new BmobPointer Weibo (wb)); \nbmobUnity.Find Comment (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Comment  commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print( 获取的对象为：   + comment.ToString());\n    }\n});  反之，不想匹配某个子查询，你可以使用WhereDoesNotMatchQuery方法。 比如为了查询不带图片的微博的评论列表，就可以将上面的示例代码中的WhereMatchesQuery方法替换为WhereDoesNotMatchQuery方法。  如果你想获取最新的10条评论，同时包含这些评论对应的微博，实现代码可以为如下：  BmobQuery query = new BmobQuery();\n// 限制10条\nquery.Limit(10); \n//按创建时间排序\nquery.Order( createdAt ); \n//同时将对应的微博信息也查询出来\nquery.Include( weibo );\n//执行查询\nbmobUnity.Find Comment (TABLENAME, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Comment  commentList = resp.results;\n    foreach (var comment in commentList)\n    {\n        print( 获取的对象为：   + comment.ToString());\n    }\n});  你可以使用 . 号（英语句号）操作符来并列获得 Include 中的内嵌的对象。比如，你同时想 Include 一个 Comment 的 weibo 和weibo的 user（微博发布者）对象，你可以这样做：  query.Include( weibo.user );", 
            "title": "查询关联对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_25", 
            "text": "用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。  有了这个类，你就可以在你的应用程序中添加用户账户功能。  BmobUser是BmobTable的一个子类，它继承了BmobTable所有的方法，具有BmobTable相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。", 
            "title": "用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_26", 
            "text": "BmobUser除了从BmobTable继承的属性外，还有几个特定的属性：    username: 用户的用户名（必需）。   password: 用户的密码（必需）。   email: 用户的电子邮件地址（可选）。", 
            "title": "属性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_27", 
            "text": "创建用户对象如下：  BmobUser user = new BmobUser();  如果你需要扩展用户资料信息，如给用户表添加生命值life和攻击指数attack，那么需要创建一个新的用户类，继承自BmobUser。示例代码如下：  public class GameUser : BmobUser\n{\n    public BmobInt life { get; set; }\n    public BmobInt attack { get; set; }\n\n    public override void write(BmobOutput output, bool all)\n    {\n        base.write(output, all);\n\n        output.Put( life , this.life);\n        output.Put( attack , this.attack);\n    }\n\n    public override void readFields(BmobInput input)\n    {\n        base.readFields(input);\n\n        this.life = input.getInt( life );\n        this.attack = input.getInt( attack );\n    }\n}", 
            "title": "创建用户对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_28", 
            "text": "你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：  BmobUser user = new BmobUser();\nuser.username =  bmob ;\nuser.password =  123456 ;\n//邮箱用于找回密码\nuser.email =  partnet@bmob.cn ;\n//如使用了GameUser表的话，以下注册语句需要更改为：bmobUnity.Signup MyBmobUser (user,(resp, exception) = \nbmobUnity.Signup(user,(resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 注册失败, 失败原因为：   + exception.Message);\n        return;\n    }\n    print( 注册成功 );\n});  在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。  如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。  你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。  这里需要注意一点的是，有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。", 
            "title": "注册用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_29", 
            "text": "", 
            "title": "设置邮箱验证功能"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_30", 
            "text": "当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。  bmobUnity.Login GameUser ( bmob ,  123456 , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 登录失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 登录成功, @  + resp.username +  (  + resp.life +  )$[  + resp.sessionToken +  ] );\n    print( 登录成功, 当前用户对象Session：   + BmobUser.CurrentUser.sessionToken);\n});", 
            "title": "登录用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_31", 
            "text": "登录之后，你可以通过如下示例代码获取当前登录用户的信息：  BmobUser buser = BmobUser.CurrentUser;\n// 或者\nGameUser user = BmobUser.CurrentUser as GameUser;", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_32", 
            "text": "很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，示例代码如下：  GameUser user = new GameUser();\nuser.attack = 1000;\n//需要知道用户记录的objectId和sessionToken信息\nbmobUnity.UpdateUser( objectid , user,  sessionToken , (resp, exception) = \n{\n    if (updateException != null)\n    {\n        print( 保存失败, 失败原因为：   + updateException.Message);\n        return;\n    }\n\n    print( 保存成功, @  + updateResp.updatedAt);\n});  在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。", 
            "title": "更新用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_33", 
            "text": "查询用户和查询普通对象一样，只需指定BmobUser类即可，如下查询用户名为bmob的用户：  BmobQuery query = new BmobQuery();\nquery.WhereEqualTo( username ,  bmob );\nbmobUnity.Find GameUser (BmobUser.TABLE, query, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    List GameUser  list = resp.results;\n    foreach (var user in list)\n    {\n        print( 获取的对象为：   + user.ToString());\n    }\n});", 
            "title": "查询用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_34", 
            "text": "一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。  重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可，示例代码如下：  bmobUnity.Reset( support@bmob.cn , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 重置密码请求失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 重置密码请求发送成功！ );\n});  密码重置流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "密码重置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_35", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  emailVerified 字段有 3 种状态可以考虑：   true : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。  false : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。  missing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#email", 
            "text": "发送给用户的邮箱验证邮件会在一周内失效，可以通过调用 EmailVerify 来强制重新发送：  bmobUnity.EmailVerify( support@bmob.cn , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 邮箱验证请求失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 邮箱验证请求发送成功！ );\n});", 
            "title": "请求验证Email"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看Bmob数据与安全页面，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。  用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_36", 
            "text": "在没有显示指定的情况下，每一个BmobTable中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的ReadAccess方法和WriteAccess方法，如设置所有用户的读权限为true，写权限为false的示例代码如下：  BmobACL acl = new BmobACL();\nacl.ReadAccess( * );  这里说明一点的是：  * 号表示所有用户。ACL列为空表示所有用户可读可写；在不为空的情况下，读或写空缺表示没有对应权限。", 
            "title": "默认访问权限"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_37", 
            "text": "如果你想对发表的微博设定一个权限：发表微博的作者有修改和删除的权限，其他用户只有读的权限，那么，可用如下的示例代码：  //创建数据对象\nWeibo weibo = new Weibo();\nweibo.message =  论电影的七个元素 ;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//设置所有人可读\nacl.ReadAccess( * );\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});  如果要设定只有微博的作者有读写权限，其他人都没有读写权限，那么，可用如下的示例代码：  //创建数据对象\nWeibo weibo = new Weibo();\nweibo.message =  论电影的七个元素 ;\n//创建一个ACL对象\nBmobACL acl = new BmobACL();    \n//参数是用户的objectId，这里设置为当前用户可读\nacl.ReadAccess(BmobUser.CurrentUser().objectId);\n//参数是用户的objectId，这里设置为当前用户可写    \nacl.WriteAccess(BmobUser.CurrentUser().objectId);   \n//设置这条数据的ACL信息\nweibo.ACL = acl;    \nbmobUnity.Create(TABLENAME, weibo, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});", 
            "title": "指定用户的访问权限"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_38", 
            "text": "上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：  //创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage = 100000;   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.ReadAccess(boos.objectId);    \nacl.ReadAccess(hr_zhang.objectId);\nacl.ReadAccess(cashier_xie.objectId);\nacl.ReadAccess(me.objectId);\n\n//设置老板和人事小张对这个工资的写权限\nacl.WriteAccess(boss.objectId);\nacl.WriteAccess(hr_zhang.objectId);\n\n//设置工资对象的ACL\nwageinfo.ACL =acl;\nbmobUnity.Create(TABLENAME, wageinfo, (resp, exception) = \n{\n    if(exception != null){\n        print( 保存失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 保存成功, @  + resp.createdAt);\n});  但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：  //这里创建四个用户对象指针，分别为老板、人事小张、出纳小谢和自己\n// just for test\nBmobPointer BmobUser  boss = new BmobUser() { objectId =  1  };\nBmobPointer BmobUser  hr_zhang = new BmobUser() { objectId =  2  };\nBmobPointer BmobUser  hr_luo = new BmobUser() { objectId =  3  };\nBmobPointer BmobUser  cashier_xie = new BmobUser() { objectId =  4  };\nBmobPointer BmobUser  me = new BmobUser() { objectId =  5  };\n\n{\n    //创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\n    BmobRole hr = new BmobRole();\n    hr.name =  HR ;\n    var users = new BmobRelation BmobUser ();\n    users.Add(hr_zhang);\n    users.Add(hr_luo);\n\n    //将hr_zhang和hr_luo归属到hr角色中\n    hr.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(hr);\n    FinishedCallback(future.Result, null);\n}\n\n{\n    BmobRole cashier = new BmobRole();\n    cashier.name =  Cashier ;\n    var users = new BmobRelation BmobUser ();\n    users.Add(cashier_xie);\n\n    //将cashier_xie归属到cashier角色中\n    cashier.AddUsers(users);\n\n    //保存到云端角色表中（web端可以查看Role表）\n    var future = Bmob.CreateTaskAsync(cashier);\n    FinishedCallback(future.Result, null);\n}  根据Role设置ACL：  //创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.Wage =100000;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\n// 给hr角色设置读权限\nacl.RoleReadAccess(hr.name);\n// 给cashier角色设置读权限\nacl.RoleReadAccess(cashier.name);\n\n// 设置老板拥有写权限\nacl.RoleWriteAccess(boss.name);\n// 设置hr角色拥有写权限\nacl.RoleWriteAccess(hr.name);\n\n//设置工资对象的ACL\nwageinfo.ACL = acl;\n//添加数据\nbmobUnity.Create(TABLENAME, wageinfo, null);  需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。", 
            "title": "角色管理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_39", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询，可以轻松实现查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_40", 
            "text": "首先需要创建一个BmobGeoPoint对象。例如，创建一个北纬39.913768382429105度-东经116.39727786183357度的BmobGeoPoint对象：  BmobGeoPoint point = new BmobGeoPoint(39.913768382429105, 116.39727786183357);", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_41", 
            "text": "现在，你的数据表中有了一定的地理坐标对象的数据， 就可以使用BmobQuery对象的WhereNear方法来找出最接近某个点的信息，示例代码如下（假设Person表中有一个名为area的地理坐标类型的字段）：  BmobQuery query = new BmobQuery();\nbmobQuery.WhereNear( area , new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.Limit(10);    //获取最接近用户地点的10条数据\nbmobUnity.Find Person ( Person , bmobQuery, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Person  list = resp.results;\n    foreach (var p in list)\n    {\n        print( 获取的对象为：   + p.ToString());\n    }\n});  要限制查询指定距离范围的数据可以使用WhereWithinDistance，即：  //(112.934755, 24.52065)坐标点10公里内\nquery.WhereWithinDistance( area , new BmobGeoPoint(112.934755, 24.52065), 10);  要查询一个矩形范围内的信息可以使用addWhereWithinGeoBox来实现：  BmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery query = new BmobQuery();\nquery.WhereWithinGeoBox( area , southwestOfSF, northeastOfSF);\nbmobUnity.Find Person ( Person , bmobQuery, (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 查询失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    //对返回结果进行处理\n    List Person  list = resp.results;\n    foreach (var p in list)\n    {\n         print( 获取的对象为：   + p.ToString());\n    }\n});  注意事项 目前有几个需要注意的地方：   每个BmobTable数据对象中只能有一个BmobGeoPoint对象。  地理位置的点不能超过规定的范围。纬度的范围应该是在-90.0到90.0之间。经度的范围应该是在-180.0到180.0之间。如果您添加的经纬度超出了以上范围，将导致程序错误。", 
            "title": "查询地理位置信息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_42", 
            "text": "很多游戏可能会有计数器功能的需求，比如某个玩家的比赛总分score。Bmob提供了非常便捷的方式来保证原子性的修改某一记录（这条记录的objectId为28dd44a271）某字段的值。示例代码如下：  GameScore object = new GameScore();\nobject.Increment( score , 1000);\n//28dd44a271为这条记录的objectId\nbmobUnity.Update(TABLENAME,  28dd44a271 , object, FinishedCallback);", 
            "title": "原子计数器"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_43", 
            "text": "Bmob可以让你将文件存储到服务器中，常见的文件类型，如图像文件、影像文件、音乐文件和任何其他二进制数据，都可以直接上传到云端文件系统中，示例代码如下：  bmobUnity.FileUpload( C:/Intel/Logs/IntelGFXCoin.log , (resp, exception) = \n{\n    if (exception != null)\n    {\n        print( 上传失败, 失败原因为：   + exception.Message);\n        return;\n    }\n    print( 上传成功，返回数据：   + resp.ToString());\n});  resp的返回值为UploadCallbackData对象：  // 文件名\npublic string filename { get; set; }\n/// 文件组名\npublic string group { get; set; }\n/// 相对于Bmob文件服务器的位置\npublic string url { get; set; }\n/// 文件请求的地址\npublic string getPath()  这里需要说明一点的是：单个上传的文件大小不可超过10M。   与结合用户表实例   一些用户不知道上传的附件和其他表结合怎么使用。下面介绍实际的案例：上传用户的头像  对象类：      public class GameUser : BmobUser\n    {\n        public BmobFile File{get; set;}\n\n        public override void readFields(BmobInput input)\n        {\n            base.readFields(input);\n\n            this.File = input.Get BmobFile ( file );\n        }\n\n        public override void write(BmobOutput output, Boolean all)\n        {\n            base.write(output, all);\n\n            output.Put( file , this.File);\n        }\n\n    }  上传图片，并把图片保存到新用户User记录：      Byte[] data = null;\n    using (var stream = File.OpenRead( C:/Users/winse/Desktop/1.png ))\n    {\n        data = stream.ReadAsBytes();\n    }\n\n    var ffuture = Bmob.FileUploadTaskAsync(new BmobLocalFile(data,  21.png ));\n\n    GameUser user = new GameUser();\n    user.email =  1324@qq.com ;\n    user.phone =  1234 ;\n    user.username =  1234 ;\n    user.password =  123 ;\n\n    user.File = ffuture.Result;\n\n    var future = Bmob.SignupTaskAsync(user);\n    var signResponse = future.Result;\n...", 
            "title": "文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_44", 
            "text": "云端代码的调用方法非常简单，如下为调用执行云端方法test的实现代码：  Bmob.Endpoint Hashtable ( test , (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 调用失败, 失败原因为：   + exception.Message);\n        return;\n    }\n\n    print( 返回对象为：   + resp);\n});  相关云端代码的编写方式，请参考云端代码开发文档。  C#调用云端代码的返回值为json字符串，即不能只返回一个单值的对象！   不正确的使用方式：   function onRequest(request, response, modules) {\nresponse.end( just string... );\n}                 C#中正确的方式：   云端代码：  function onRequest(request, response, modules) {\n    var res =  { value :  just string... } ;\n    response.end(JSON.stringify(res));\n}                           C#调用代码：  [TestMethod()]\npublic void EndpointParamAndStringTest()\n{\n    var p = new Dictionary String, Object ();\n\n    var future = Bmob.EndpointTaskAsync Object ( testString , p);\n    FinishedCallback(future.Result, null);\n}   带参数返回map和list的例子   [TestMethod()]\npublic void EndPointTest()\n{\n    //var future = Bmob.EndpointTaskAsync QueryCallbackData Object ( second , null);\n    //FinishedCallback(future.Result, null);\n\n    var future = Bmob.EndpointTaskAsync List object ( testParam , new BmobKV().Put( a ,  winse ));\n    FinishedCallback(future.Result, null);\n\n--\n\nfunction onRequest(request, response, modules) {\n\n    //获取数据库对象 \n    var db = modules.oData; \n\n    var name = request.body.a;\n    //获取\n    db.find({ \n        table:'StudentScore',\n         where :{ name :name}  \n    },function(err,data){\n        response.send(JSON.parse(data).results);\n    }); \n\n}", 
            "title": "云端代码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_45", 
            "text": "在BmobWindows对象中提供了一个方法，用于获取服务器时间。  BmobWindows bmobWindows = new BmobWindows();\nbmobWindows.Timestamp( (resp, exception) =  \n{\n    if (exception != null)\n    {\n        print( 请求失败, 失败原因为：   + exception.Message);\n        return;\n    }\n    //返回服务器时间（单位：秒）\n    print( 返回时间戳为：   + resp.timestamp); \n    print( 返回格式化的日期为：   + resp.datetime); \n}\n);", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_46", 
            "text": "BmobDate对应服务端的Date类型。以 yyyy-MM-dd HH:mm:ss 的格式进行传输。  SDK提供了DateTime到BmobDate的隐式转化，简化BmobDate的实例化。  例如，查询在某个时间段内新增的数据，由于一个字段涉及到两个条件，需要使用符合查询功能：  BmobDate start = new DateTime(2014, 10, 1);\nBmobDate end = new DateTime(2015, 1, 1);\n\nvar startQuery = new BmobQuery();\nstartQuery.WhereGreaterThanOrEqualTo( createdAt , start);\n\nvar endQuery = new BmobQuery();\nendQuery.WhereLessThan( createdAt , end);\n\nvar query = startQuery.And(endQuery);\nquery.Limit(0);\nquery.Count();\n\nvar future = Bmob.FindTaskAsync Object (TABLENAME, query);\n// 处理结果\n// var result = future.Result;", 
            "title": "时间"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#faq", 
            "text": "请求信息查看   在开发过程中，其实很多问题开发者自己多确认下就能解决问题。SDK提供了查看发送请求到服务端的开关，只需要注册一下调试信息的输出方法即可。  BmobDebug.Register(msg =  { Debug.WriteLine(msg); });\nBmobDebug.level = BmobDebug.Level.TRACE;  在输出窗口，可以查看每次请求的appkey、请求数据。   关于Task，以及Windowsphone开发UI线程问题   新版本的SDK针对每个原有接口增加了对应Task接口方法，方便异步调用。这样就没有必要每次都callback回调，如果调用是多个线性的请求，那么使用callback代码会很难理解。  如果是开发desktop的应用，还可以等待结果的返回，但是在手机端，系统不允许有长时间等待的，要么使用callback要么使用异步。  使用回调：           private void create_Click(object sender, RoutedEventArgs e)\n        {\n            BmobApi table = new BmobApi();\n            table.name =  hello wp ;\n            Bmob.Create(TABLE_NAME, table, (resp, ex) = \n            {\n                string status =  OK ;\n                if (ex != null)\n                {\n                    status =  ERROR ;\n                }\n\n                Dispatcher.BeginInvoke(() = \n                               {\n                                   updateStatus(create, status);\n                               });\n            });\n        }  注意：在回调用如果需要更新UI，需要转到UI线程才行。  使用异步：  // async方式异步请求处理，非阻塞访问\n        private async void uploadBtn_Click(object sender, EventArgs e)\n        {\n            formstatus.Text =  正在上传... ;\n\n            var Result = await Bmob.FileUploadTaskAsync(fileText.Text);\n            FinishedCallback(Result, resultText);\n\n            bmobFile = Result;\n\n            enterDba.Enabled = true;\n            formstatus.Text =  上传成功！ ;\n        }", 
            "title": "FAQ"
        }, 
        {
            "location": "/module/example/README/index.html", 
            "text": "快速入门相关源码\nhttp://www.bmob.cn/static/Bmob_unity_quickstart.zip\n\n\n有关C#相关的案例源码大家可以移步Github代码仓库：\nhttps://github.com/bmob/bmob-demo-csharp", 
            "title": "示例和功能"
        }
    ]
}