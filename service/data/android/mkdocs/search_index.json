{
    "docs": [
        {
            "location": "/index.html", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID后，下载SDK（下载地址：\nhttp://www.bmob.cn/site/sdk#android_sdk\n）。\n\n\n\n\nSDK导入\n\n\nAndroidStudio配置\n\n\n鉴于目前Google官方推荐使用 \nAndroid Studio\n 进行Android项目开发，自 \nV3.4.2\n 开始，Bmob Android SDK 可以使用Gradle来进行包依赖管理，如果你使用Android Studio来进行基于BmobSDK的项目开发，有两种方式：\n\n\n自动导入(推荐)\n\n\n请按照如下两个步骤进行：\n\n\n\n\n在 \nProject\n 的 \nbuild.gradle\n 文件中添加 \nBmob的maven仓库地址\n，示例如下：（\n注意文字说明部分\n）：\n\n\n\n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:1.2.3'\n        }\n    }\n\n    allprojects {\n        repositories {\n            jcenter()\n            //Bmob的maven仓库地址--必填\n            maven { url \nhttps://raw.github.com/bmob/bmob-android-sdk/master\n }\n        }\n    }\n\n\n\n\n\n\n在\napp\n的\nbuild.gradle\n文件中添加\ncompile依赖文件\n,示例如下：（\n注意文字说明部分\n）：\n\n\n\n\n    apply plugin: 'com.android.application'\n\n    android {\n        compileSdkVersion 22\n        buildToolsVersion '22.0.1'\n\n        **兼容Android6.0系统所需，如果这句话报错，可在dependencies标签下使用compile 'cn.bmob.android:http-legacy:1.0'**\n        useLibrary 'org.apache.http.legacy'\n\n        ...\n    }\n\n\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n\n        //以下SDK开发者请根据需要自行选择\n        //bmob-sdk：Bmob的android sdk包，包含了Bmob的数据存储、文件等服务，以下是最新的bmob-sdk:\n        //3.5.5：请务必查看下面注释[1]\n        compile 'cn.bmob.android:bmob-sdk:3.5.5'\n\n        //bmob-push：Bmob的推送包\n        compile 'cn.bmob.android:bmob-push:0.8'\n\n        //bmob-im：Bmob的即时通讯包，注意每个版本的im依赖特定版本的bmob-sdk，具体的依赖关系可查看下面注释[2]\n        compile 'cn.bmob.android:bmob-im:2.0.5@aar'\n        compile 'cn.bmob.android:bmob-sdk:3.4.7-aar'\n\n        //bmob-sms ：Bmob单独为短信服务提供的包\n        compile 'cn.bmob.android:bmob-sms:1.0.1'\n\n        //如果你想应用能够兼容Android6.0，请添加此依赖(org.apache.http.legacy.jar)\n        compile 'cn.bmob.android:http-legacy:1.0'\n    }\n\n\n\n\n\n注：\n\n\n[1]、为了降低开发者的使用成本，自v3.4.7开始，同步提供\naar\n格式的文件，此aar包含\nlibbmob.so、依赖jar包(okhttp、okio、rx、gson等)及自动更新组件所需要的资源文件\n。开发者再也不需要配置libbmob.so,不需要添加依赖jar，也不需要复制自动更新组件的资源文件啦，只需要添加以下依赖即可。\n\n\ncompile 'cn.bmob.android:bmob-sdk:3.5.0'\n\n\n\n注：由于\nPermissionManager权限管理类\n需要依赖\nsupport-v4:23.2.1\n的jar包,导致开发者认为SDK依赖文件较多，故分离出SDK。开发者如果需要兼容Android6.0系统，可以在下载的SDK的官方Demo的\ncom.example.bmobexample.permission\n包下面查看该类源码。\n\n\n[2]、每个版本的im依赖特定版本的bmob-sdk：\n\n\n\n\nbmob-im:1.1.8---\nbmob-sdk:3.3.5\n\n\nbmob-im:1.1.9---\nbmob-sdk:3.4.3\n\n\nbmob-im:2.0.1---\nbmob-sdk:3.4.6-0304\n\n\nbmob-im:2.0.2---\nbmob-sdk:3.4.6-0304\n\n\nbmob-im:2.0.3---\nbmob-sdk:3.4.6\n\n\nbmob-im:2.0.4---\nbmob-sdk:3.4.6\n \n\n\nbmob-im:2.0.5---\nbmob-sdk:3.4.7-aar\n\n\nbmob-im:2.0.6---\nbmob-sdk:3.5.0\n\n\n\n\n其中\n\n\n\n\nbmob-sdk:3.4.6-0304\n是Bmob Android SDK的过渡版本，主要用于NewIM_v2.0.1及v2.0.2\n\n\nbmob-sdk:3.4.6\n的相关依赖包可见注释[3]\n\n\n\n\n[3]、bmob-sdk:3.4.6依赖以下包：\n\n\ncompile 'cn.bmob.android:bmob-sdk:3.4.6'\ncompile 'com.squareup.okhttp:okhttp:2.4.0'//CDN文件服务使用okhttp相关包进行文件的上传和下载（必填）\ncompile 'com.squareup.okio:okio:1.4.0'\n\n\n\n如果需要兼容Android6.0系统，请添加以下两项：\n\n\ncompile 'com.android.support:support-v4:23.2.1'\ncompile 'cn.bmob.android:http-legacy:1.0'\n\n\n\n[4]、bmob-sms适用于只需要使用Bmob短信功能的开发者，而bmob-sdk内部包含了bmob-sms的短信功能,请不要重复添加。\n\n\n[5]、BmobSDK的官方仓库：\nbmob-android-sdk\n，开发者可到此仓库查看最新发布的各版本SDK，我们会尽量与官网发布的SDK保持同步更新。\n\n\n手动导入\n\n\n\n\n\n\n开发者到\nSDK下载中心\n下载 \n数据服务\n 的Android 版本的SDK，并将下载下来的\nlibs\n文件夹里面的文件根据需要复制到工程的libs目录下(注意，自\nv3.4.7\n开始提供\nlibbmob.so\n文件)； \n\n\n\n\n\n\n在\napp\n的\nbuid.gradle\n文件中添加SO库目录配置：\n\n\nandroid {\n    sourceSets {\n        main.jniLibs.srcDirs = ['libs']\n   }\n}\n\n\n\n\n\n\n\n点击Sync，同步配置。\n\n\n\n\n\n\nEclipse导入\n\n\n开发者到 \nSDK下载中心\n 下载 \n数据服务\n 的Android 版本的SDK，在Eclipse工程的项目根目录中新建\nlibs\n文件夹，将下载的jar包添加到此文件夹即可。\n\n\n注：\n\n\n1、若配置不成功，则需要额外增加以下步骤：\n\n\n右键工程根目录，选择\nProperties -\n Java Build Path -\n Libraries\n，然后点击\nAdd External JARs...\n 选择指向该libs文件夹下的jar的路径，点击OK即可\n\n\n2、BmobSDK_v3.5.0需要依赖\nrxjava（1.1.6）、rxandroid(1.2.0)、gson(2.6.2)、okhttp3（3.3.1）、okio（1.7.0）\n及\nlibbmob.so\n库；\n\n\n3、BmobSDK_v3.4.7需要依赖\nokhttp3（3.2.0）、okio（1.7.0）\n及\nlibbmob.so\n库；\n\n\n4、BmobSDK_v3.4.6需要依赖\nokhttp（2.4.0）、okio（1.4.0）\n，如果需要兼容Android6.0系统，则还需要添加support-v4（23.2.1）及org.apache.http.legacy依赖包。\n\n\n配置AndroidManifest.xml\n\n\n在你的应用程序的\nAndroidManifest.xml\n文件中添加相应的权限：\n\n\n\n\n!--允许联网 --\n \n\nuses-permission android:name=\nandroid.permission.INTERNET\n /\n \n\n!--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息  --\n \n\nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n \n\n!--获取wifi网络状态的信息 --\n \n\nuses-permission android:name=\nandroid.permission.ACCESS_WIFI_STATE\n /\n \n\n!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --\n\n\nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n \n\n!--获取sd卡写的权限，用于文件上传和下载--\n\n\nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n /\n\n\n!--允许读取手机状态 用于创建BmobInstallation--\n \n\nuses-permission android:name=\nandroid.permission.READ_PHONE_STATE\n /\n\n\n\n\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n    \nmanifest xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n        package=\ncn.bmob.example\n\n        android:versionCode=\n1\n\n        android:versionName=\n1.0\n\n\n    \nuses-sdk android:minSdkVersion=\n8\n android:targetSdkVersion=\n17\n/\n\n\n    \nuses-permission android:name=\nandroid.permission.INTERNET\n /\n \n    \nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n /\n \n    \nuses-permission android:name=\nandroid.permission.ACCESS_WIFI_STATE\n /\n \n    \nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n \n    \nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n /\n\n    \nuses-permission android:name=\nandroid.permission.READ_PHONE_STATE\n /\n\n\n    \napplication\n        android:allowBackup=\ntrue\n\n        android:icon=\n@drawable/ic_launcher\n\n        android:label=\n@string/app_name\n\n        android:theme=\n@style/AppTheme\n\n        \nactivity\n            android:name=\ncn.bmob.example.MainActivity\n\n            android:screenOrientation=\nportrait\n\n            android:label=\n@string/app_name\n\n\n                \naction android:name=\nandroid.intent.action.MAIN\n/\n\n                \ncategory android:name=\nandroid.intent.category.LAUNCHER\n/\n\n\n\n        \nactivity\n            android:name=\n.CreateActivity\n\n            android:screenOrientation=\nportrait\n\n        \nactivity\n            android:name=\n.DeleteActivity\n\n            android:screenOrientation=\nportrait\n\n        \nactivity\n            android:name=\n.UpdateActivity\n\n            android:screenOrientation=\nportrait\n\n        \nactivity\n            android:name=\n.FindActivity\n\n            android:screenOrientation=\nportrait\n\n    \n/application\n\n\n/manifest\n\n\n\n\n\n初始化BmobSDK\n\n\n在你应用程序启动的Activity的onCreate()方法中初始化Bmob功能。代码如下所示：\n\n\npackage com.bmob.example;\nimport cn.bmob.v3.Bmob;\nimport android.app.Activity;\nimport android.os.Bundle;\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n         // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n         //提供以下两种方式进行初始化操作：\n\n        //第一：默认初始化\n        Bmob.initialize(this, \nYour Application ID\n);\n        // 注:自v3.5.2开始，数据sdk内部缝合了统计sdk，开发者无需额外集成，传渠道参数即可，不传默认没开启数据统计功能\n        //Bmob.initialize(this, \nYour Application ID\n,\nbmob\n);\n\n        //第二：自v3.4.7版本开始,设置BmobConfig,允许设置请求超时时间、文件分片上传时每片的大小、文件的过期时间(单位为秒)，\n        //BmobConfig config =new BmobConfig.Builder(this)\n        ////设置appkey\n        //.setApplicationId(\nYour Application ID\n)\n        ////请求超时时间（单位为秒）：默认15s\n        //.setConnectTimeout(30)\n        ////文件分片上传时每片的大小（单位字节），默认512*1024\n        //.setUploadBlockSize(1024*1024)\n        ////文件的过期时间(单位为秒)：默认1800s\n        //.setFileExpiration(2500)\n        //.build();\n        //Bmob.initialize(config);\n    }\n}\n\n\n\n\n添加一行数据\n\n\n首先创建JavaBean（对应为Bmob后台的数据表，更详细的解释请\n查看Android开发文档\n）\n\n\npublic class Person extends BmobObject {\n    private String name;\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n\n\n\n\n添加数据\n\n\nPerson p2 = new Person();\np2.setName(\nlucky\n);\np2.setAddress(\n北京海淀\n);\np2.save(new SaveListener\nString\n() {\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            toast(\n添加数据成功，返回objectId为：\n+objectId);\n        }else{\n            toast(\n创建数据失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n如果toast出添加数据成功的消息，你会在Bmob对应Application Id的数据表中看到有一行新增的数据，如下图所示：\n\n\n\n\n获取一行数据\n\n\n//查找Person表里面id为6b6c11c537的数据\nBmobQuery\nPerson\n bmobQuery = new BmobQuery\nPerson\n();\nbmobQuery.getObject(\n6b6c11c537\n, new \nQueryListener\nPerson\n() {\n    @Override\n    public void done(Person object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功\n);\n        }else{\n            toast(\n查询失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n修改一行数据\n\n\n//更新Person表里面id为6b6c11c537的数据，address内容更新为“北京朝阳”\nPerson p2 = new Person();\np2.setAddress(\n北京朝阳\n);\np2.update(\n6b6c11c537\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n更新成功:\n+p2.getUpdatedAt());\n        }else{\n            toast(\n更新失败：\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n删除一行数据\n\n\nPerson p2 = new Person();\np2.setObjectId(\n6b6c11c537\n);\np2.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n删除成功:\n+p2.getUpdatedAt());\n        }else{\n            toast(\n删除失败：\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载\n\n\n案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的\n案例教程和源码\n，欢迎大家下载和查看。\n\n\n为方便大家更好的理解Bmob SDK能够做的事情，我们还特意为大家提供了一些源码，大家可以下载之后，\n嵌入Bmob的AppKey\n，再打包运行。\n\n\n阅读源码是一种良好的习惯！！\n\n\n即时聊天案例源码：\nhttps://github.com/bmob/BmobIMSDK4Android\n\n\n图文社区案例源码：\nhttps://git.oschina.net/v7/Wonderful\n  这个案例是猿圈媛圈开发团队提供的。\n\n\n校园小菜案例源码：\nhttps://github.com/bmob/Shop\n 这个案例是湖工大的朋友提供的。\n\n\n社交分享案例源码：\nhttps://github.com/bmob/bmob-android-social-share\n 这个是金刚锁开发者提供的\n\n\n第三方登录案例源码：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n  包含第三方登录和登录后获取用户信息的源码\n\n\n阅读更多的文档\n\n\n\n\n快速入门只是提供了最最基本的介绍，如果你想了解更多的功能，请查看我们的详细开发文档：\nhttp://docs.bmob.cn/data/Android/b_developdoc/doc/index.html\n\n\n如果想看下SDK的类库文档，可以移步\n这里", 
            "title": "快速入门"
        }, 
        {
            "location": "/index.html#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/index.html#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/index.html#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID后，下载SDK（下载地址： http://www.bmob.cn/site/sdk#android_sdk ）。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/index.html#sdk_1", 
            "text": "", 
            "title": "SDK导入"
        }, 
        {
            "location": "/index.html#androidstudio", 
            "text": "鉴于目前Google官方推荐使用  Android Studio  进行Android项目开发，自  V3.4.2  开始，Bmob Android SDK 可以使用Gradle来进行包依赖管理，如果你使用Android Studio来进行基于BmobSDK的项目开发，有两种方式：", 
            "title": "AndroidStudio配置"
        }, 
        {
            "location": "/index.html#_2", 
            "text": "请按照如下两个步骤进行：   在  Project  的  build.gradle  文件中添加  Bmob的maven仓库地址 ，示例如下：（ 注意文字说明部分 ）：       buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:1.2.3'\n        }\n    }\n\n    allprojects {\n        repositories {\n            jcenter()\n            //Bmob的maven仓库地址--必填\n            maven { url  https://raw.github.com/bmob/bmob-android-sdk/master  }\n        }\n    }   在 app 的 build.gradle 文件中添加 compile依赖文件 ,示例如下：（ 注意文字说明部分 ）：       apply plugin: 'com.android.application'\n\n    android {\n        compileSdkVersion 22\n        buildToolsVersion '22.0.1'\n\n        **兼容Android6.0系统所需，如果这句话报错，可在dependencies标签下使用compile 'cn.bmob.android:http-legacy:1.0'**\n        useLibrary 'org.apache.http.legacy'\n\n        ...\n    }\n\n\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n\n        //以下SDK开发者请根据需要自行选择\n        //bmob-sdk：Bmob的android sdk包，包含了Bmob的数据存储、文件等服务，以下是最新的bmob-sdk:\n        //3.5.5：请务必查看下面注释[1]\n        compile 'cn.bmob.android:bmob-sdk:3.5.5'\n\n        //bmob-push：Bmob的推送包\n        compile 'cn.bmob.android:bmob-push:0.8'\n\n        //bmob-im：Bmob的即时通讯包，注意每个版本的im依赖特定版本的bmob-sdk，具体的依赖关系可查看下面注释[2]\n        compile 'cn.bmob.android:bmob-im:2.0.5@aar'\n        compile 'cn.bmob.android:bmob-sdk:3.4.7-aar'\n\n        //bmob-sms ：Bmob单独为短信服务提供的包\n        compile 'cn.bmob.android:bmob-sms:1.0.1'\n\n        //如果你想应用能够兼容Android6.0，请添加此依赖(org.apache.http.legacy.jar)\n        compile 'cn.bmob.android:http-legacy:1.0'\n    }  注：  [1]、为了降低开发者的使用成本，自v3.4.7开始，同步提供 aar 格式的文件，此aar包含 libbmob.so、依赖jar包(okhttp、okio、rx、gson等)及自动更新组件所需要的资源文件 。开发者再也不需要配置libbmob.so,不需要添加依赖jar，也不需要复制自动更新组件的资源文件啦，只需要添加以下依赖即可。  compile 'cn.bmob.android:bmob-sdk:3.5.0'  注：由于 PermissionManager权限管理类 需要依赖 support-v4:23.2.1 的jar包,导致开发者认为SDK依赖文件较多，故分离出SDK。开发者如果需要兼容Android6.0系统，可以在下载的SDK的官方Demo的 com.example.bmobexample.permission 包下面查看该类源码。  [2]、每个版本的im依赖特定版本的bmob-sdk：   bmob-im:1.1.8--- bmob-sdk:3.3.5  bmob-im:1.1.9--- bmob-sdk:3.4.3  bmob-im:2.0.1--- bmob-sdk:3.4.6-0304  bmob-im:2.0.2--- bmob-sdk:3.4.6-0304  bmob-im:2.0.3--- bmob-sdk:3.4.6  bmob-im:2.0.4--- bmob-sdk:3.4.6    bmob-im:2.0.5--- bmob-sdk:3.4.7-aar  bmob-im:2.0.6--- bmob-sdk:3.5.0   其中   bmob-sdk:3.4.6-0304 是Bmob Android SDK的过渡版本，主要用于NewIM_v2.0.1及v2.0.2  bmob-sdk:3.4.6 的相关依赖包可见注释[3]   [3]、bmob-sdk:3.4.6依赖以下包：  compile 'cn.bmob.android:bmob-sdk:3.4.6'\ncompile 'com.squareup.okhttp:okhttp:2.4.0'//CDN文件服务使用okhttp相关包进行文件的上传和下载（必填）\ncompile 'com.squareup.okio:okio:1.4.0'  如果需要兼容Android6.0系统，请添加以下两项：  compile 'com.android.support:support-v4:23.2.1'\ncompile 'cn.bmob.android:http-legacy:1.0'  [4]、bmob-sms适用于只需要使用Bmob短信功能的开发者，而bmob-sdk内部包含了bmob-sms的短信功能,请不要重复添加。  [5]、BmobSDK的官方仓库： bmob-android-sdk ，开发者可到此仓库查看最新发布的各版本SDK，我们会尽量与官网发布的SDK保持同步更新。", 
            "title": "自动导入(推荐)"
        }, 
        {
            "location": "/index.html#_3", 
            "text": "开发者到 SDK下载中心 下载  数据服务  的Android 版本的SDK，并将下载下来的 libs 文件夹里面的文件根据需要复制到工程的libs目录下(注意，自 v3.4.7 开始提供 libbmob.so 文件)；     在 app 的 buid.gradle 文件中添加SO库目录配置：  android {\n    sourceSets {\n        main.jniLibs.srcDirs = ['libs']\n   }\n}    点击Sync，同步配置。", 
            "title": "手动导入"
        }, 
        {
            "location": "/index.html#eclipse", 
            "text": "开发者到  SDK下载中心  下载  数据服务  的Android 版本的SDK，在Eclipse工程的项目根目录中新建 libs 文件夹，将下载的jar包添加到此文件夹即可。  注：  1、若配置不成功，则需要额外增加以下步骤：  右键工程根目录，选择 Properties -  Java Build Path -  Libraries ，然后点击 Add External JARs...  选择指向该libs文件夹下的jar的路径，点击OK即可  2、BmobSDK_v3.5.0需要依赖 rxjava（1.1.6）、rxandroid(1.2.0)、gson(2.6.2)、okhttp3（3.3.1）、okio（1.7.0） 及 libbmob.so 库；  3、BmobSDK_v3.4.7需要依赖 okhttp3（3.2.0）、okio（1.7.0） 及 libbmob.so 库；  4、BmobSDK_v3.4.6需要依赖 okhttp（2.4.0）、okio（1.4.0） ，如果需要兼容Android6.0系统，则还需要添加support-v4（23.2.1）及org.apache.http.legacy依赖包。", 
            "title": "Eclipse导入"
        }, 
        {
            "location": "/index.html#androidmanifestxml", 
            "text": "在你的应用程序的 AndroidManifest.xml 文件中添加相应的权限：   !--允许联网 --   uses-permission android:name= android.permission.INTERNET  /   !--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息  --   uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  /   !--获取wifi网络状态的信息 --   uses-permission android:name= android.permission.ACCESS_WIFI_STATE  /   !--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --  uses-permission android:name= android.permission.WAKE_LOCK  /   !--获取sd卡写的权限，用于文件上传和下载--  uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE  /  !--允许读取手机状态 用于创建BmobInstallation--   uses-permission android:name= android.permission.READ_PHONE_STATE  /   ?xml version= 1.0  encoding= utf-8 ? \n     manifest xmlns:android= http://schemas.android.com/apk/res/android \n        package= cn.bmob.example \n        android:versionCode= 1 \n        android:versionName= 1.0 \n\n     uses-sdk android:minSdkVersion= 8  android:targetSdkVersion= 17 / \n\n     uses-permission android:name= android.permission.INTERNET  /  \n     uses-permission android:name= android.permission.ACCESS_NETWORK_STATE  /  \n     uses-permission android:name= android.permission.ACCESS_WIFI_STATE  /  \n     uses-permission android:name= android.permission.WAKE_LOCK  /  \n     uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE  / \n     uses-permission android:name= android.permission.READ_PHONE_STATE  / \n\n     application\n        android:allowBackup= true \n        android:icon= @drawable/ic_launcher \n        android:label= @string/app_name \n        android:theme= @style/AppTheme \n         activity\n            android:name= cn.bmob.example.MainActivity \n            android:screenOrientation= portrait \n            android:label= @string/app_name \n\n                 action android:name= android.intent.action.MAIN / \n                 category android:name= android.intent.category.LAUNCHER / \n\n\n         activity\n            android:name= .CreateActivity \n            android:screenOrientation= portrait \n         activity\n            android:name= .DeleteActivity \n            android:screenOrientation= portrait \n         activity\n            android:name= .UpdateActivity \n            android:screenOrientation= portrait \n         activity\n            android:name= .FindActivity \n            android:screenOrientation= portrait \n     /application  /manifest", 
            "title": "配置AndroidManifest.xml"
        }, 
        {
            "location": "/index.html#bmobsdk", 
            "text": "在你应用程序启动的Activity的onCreate()方法中初始化Bmob功能。代码如下所示：  package com.bmob.example;\nimport cn.bmob.v3.Bmob;\nimport android.app.Activity;\nimport android.os.Bundle;\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n         // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n         //提供以下两种方式进行初始化操作：\n\n        //第一：默认初始化\n        Bmob.initialize(this,  Your Application ID );\n        // 注:自v3.5.2开始，数据sdk内部缝合了统计sdk，开发者无需额外集成，传渠道参数即可，不传默认没开启数据统计功能\n        //Bmob.initialize(this,  Your Application ID , bmob );\n\n        //第二：自v3.4.7版本开始,设置BmobConfig,允许设置请求超时时间、文件分片上传时每片的大小、文件的过期时间(单位为秒)，\n        //BmobConfig config =new BmobConfig.Builder(this)\n        ////设置appkey\n        //.setApplicationId( Your Application ID )\n        ////请求超时时间（单位为秒）：默认15s\n        //.setConnectTimeout(30)\n        ////文件分片上传时每片的大小（单位字节），默认512*1024\n        //.setUploadBlockSize(1024*1024)\n        ////文件的过期时间(单位为秒)：默认1800s\n        //.setFileExpiration(2500)\n        //.build();\n        //Bmob.initialize(config);\n    }\n}", 
            "title": "初始化BmobSDK"
        }, 
        {
            "location": "/index.html#_4", 
            "text": "首先创建JavaBean（对应为Bmob后台的数据表，更详细的解释请 查看Android开发文档 ）  public class Person extends BmobObject {\n    private String name;\n    private String address;\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}  添加数据  Person p2 = new Person();\np2.setName( lucky );\np2.setAddress( 北京海淀 );\np2.save(new SaveListener String () {\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            toast( 添加数据成功，返回objectId为： +objectId);\n        }else{\n            toast( 创建数据失败：  + e.getMessage());\n        }\n    }\n});  如果toast出添加数据成功的消息，你会在Bmob对应Application Id的数据表中看到有一行新增的数据，如下图所示：", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/index.html#_5", 
            "text": "//查找Person表里面id为6b6c11c537的数据\nBmobQuery Person  bmobQuery = new BmobQuery Person ();\nbmobQuery.getObject( 6b6c11c537 , new  QueryListener Person () {\n    @Override\n    public void done(Person object,BmobException e) {\n        if(e==null){\n            toast( 查询成功 );\n        }else{\n            toast( 查询失败：  + e.getMessage());\n        }\n    }\n});", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/index.html#_6", 
            "text": "//更新Person表里面id为6b6c11c537的数据，address内容更新为“北京朝阳”\nPerson p2 = new Person();\np2.setAddress( 北京朝阳 );\np2.update( 6b6c11c537 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 更新成功: +p2.getUpdatedAt());\n        }else{\n            toast( 更新失败：  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/index.html#_7", 
            "text": "Person p2 = new Person();\np2.setObjectId( 6b6c11c537 );\np2.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 删除成功: +p2.getUpdatedAt());\n        }else{\n            toast( 删除失败：  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/index.html#_8", 
            "text": "快速入门相关源码下载  案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的 案例教程和源码 ，欢迎大家下载和查看。  为方便大家更好的理解Bmob SDK能够做的事情，我们还特意为大家提供了一些源码，大家可以下载之后， 嵌入Bmob的AppKey ，再打包运行。  阅读源码是一种良好的习惯！！  即时聊天案例源码： https://github.com/bmob/BmobIMSDK4Android  图文社区案例源码： https://git.oschina.net/v7/Wonderful   这个案例是猿圈媛圈开发团队提供的。  校园小菜案例源码： https://github.com/bmob/Shop  这个案例是湖工大的朋友提供的。  社交分享案例源码： https://github.com/bmob/bmob-android-social-share  这个是金刚锁开发者提供的  第三方登录案例源码： https://github.com/bmob/bmob-android-demo-thirdpartylogin   包含第三方登录和登录后获取用户信息的源码", 
            "title": "源码下载"
        }, 
        {
            "location": "/index.html#_9", 
            "text": "快速入门只是提供了最最基本的介绍，如果你想了解更多的功能，请查看我们的详细开发文档： http://docs.bmob.cn/data/Android/b_developdoc/doc/index.html  如果想看下SDK的类库文档，可以移步 这里", 
            "title": "阅读更多的文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n快速入门\n\n\n建议您在阅读本开发文档之前，先阅读我们提供的 \nAndroid快速入门文档\n，便于您后续的开发。\n\n如果开发者想使用不同历史版本的SDK，可以移步\n历史版本的github仓库\n，选择使用各个历史版本。\n\n\n模板代码\n\n\n在使用SDK过程中，如果一些Api如查询是高频代码，可以把一些重复的样板代码抽出来，并在AndroidStudio中设置模板，即可实现快速输入，能提高编码效率，效果如下：\n\n\n\n\n数据迁移\n\n\n从v3.5.5开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：\n\n\n    Bmob.resetDomain(\"http://demo.bmob.cn/\");\n\n\n\n其中，参数为开发者的域名，调用后的所有请求都指向新的域名。\n\n\n统计SDK\n\n\n从v3.5.2开始，把统计SDK集成到了数据服务SDK，上传应用不再需要额外集成统计SDK，低于此版本的可以去控制台的应用官网下载。\n\n\n添加方法\n\n\n\n\n\n\n确保项目有\nINTERNET\n和\nREAD_PHONE_STATE\n权限\n\n\nuses-permission android:name=\"android.permission.INTERNET\" /\n\n\nuses-permission android:name=\"android.permission.READ_PHONE_STATE\" /\n\n\n\n\n\n\n\n\n在初始化方法中传一个渠道参数(不传默认没开启统计功能)\n\n\nBmob.initialize(this,APPID,\"Bmob\");\n\n\n\n\n\n将libs文件夹内的BmobStat.jar文件添加进项目（AS选择远程依赖可以忽略，本地依赖需要指定libs文件夹，Eclipse中放进libs即可）；\n\n\n\n\n\n\n\n\n兼容Android6.0系统\n\n\n自\nv3.4.6\n版本开始，Bmob提供了一些新的方法和工具类来帮助开发者为自己的应用兼容Android6.0系统。\n\n\n添加对Apache的HTTP-client支持\n\n\nAndroid6.0版本移除了对Appache的HTTP client的支持，因此，需要添加\norg.apache.http.legacy.jar\n包，请参照如下方式添加：\n\n\n1.Eclipse\n\n\n你需要在Eclipse工程的项目根目录中新建libs文件夹，将org.apache.http.legacy.jar包，添加到libs文件夹中\n\n\n\n2.AndroidStudio\n\n\n你需要在\napp\n的\nbuild.gradle\n文件添加配置信息useLibrary 'org.apache.http.legacy'声明编译时依赖\n\n\n    android {\n        compileSdkVersion 23\n        buildToolsVersion \"23.0.2\"\n        useLibrary 'org.apache.http.legacy'\n    }\n\n\n\n注：如果在build.gradle文件中\nuseLibrary 'org.apache.http.legacy'\n这句话报错，可将该jar直接放到libs目录下即可。\n\n\n运行时权限管理\n\n\nAndroid6.0中对特定的权限进行了动态授权的方式，需要在运行时用户手动授予，如果用户拒绝后再次申请还可以向用户弹框说明权限的作用，用户点击确认后再去申请。\n\n\n因此，我们提供了一个权限管理的工具类\nPermissionManager(cn.bmob.v3.helper)\n，具体使用如下：\n\n\n注：在\nv3.4.6\n的BmobSDK内部集成\nPermissionManager\n类，自\nv3.4.7\n以后的SDK内部将不再提供该类，开发者可以在下载的配套官方Demo的\ncom.example.bmobexample.permission\n包下面查看该类源码。\n\n\n1.构建\nPermissionManager\n对象\n\n\nPermissionManager helper;\nhelper = PermissionManager.with(MainActivity.this)\n        //添加权限请求码\n        .addRequestCode(MainActivity.REQUEST_CODE_CAMERA)\n        //设置权限，可以添加多个权限\n        .permissions(Manifest.permission.CAMERA)\n        //设置权限监听器\n        .setPermissionsListener(new PermissionListener() {\n\n            @Override\n            public void onGranted() {\n                //当权限被授予时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission granted\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onDenied() {\n                //用户拒绝该权限时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission denied\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onShowRationale(String[] permissions) {\n                //当用户拒绝某权限时并点击`不再提醒`的按钮时，下次应用再请求该权限时，需要给出合适的响应（比如,给个展示对话框来解释应用为什么需要该权限）\n                Snackbar.make(btn_camera, \"需要相机权限去拍照\", Snackbar.LENGTH_INDEFINITE)\n                        .setAction(\"ok\", new View.OnClickListener() {\n                            @Override\n                            public void onClick(View v) {\n                                //必须调用该`setIsPositive(true)`方法\n                                helper.setIsPositive(true);\n                                helper.request();\n                            }\n                        }).show();\n            }\n        })\n        //请求权限\n        .request();\n\n\n\n注：\n\n\n\n\nwith\n方法可以传入Activity或者Fragment；\n\n\naddRequestCode\n方法传入请求码，用于区分各种不同的权限申请；\n\n\npermissions\n方法传入的是你所要请求的权限，支持可变参数，可以批量申请权限；\n\n\nPermissionListener\n接口回调的三个方法：\n\n\nonGranted()会在权限申请通过后被调用；\n\n\nonDenied()在权限申请被拒绝时被调用\n\n\nonShowRationale()方法中你可以弹对话框向用户解释权限的作用，不过记得要调用\nsetIsPositive(true)\n。\n\n\nrequest\n方法用来请求权限申请\n\n\n\n\n2.覆写\nonRequestPermissionsResult\n方法\n\n\n@Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    switch (requestCode) {\n        case REQUEST_CODE_CAMERA:\n            helper.onPermissionResult(permissions, grantResults);\n            break;\n    }\n}\n\n\n\nNotification变更\n\n\nAndroid6.0中，\nNotification.setLatestEventInfo()\n方法被移除，替代的方案是用Notification.Builder来构建通知，对此SDK提供了\nNotificationCompat(cn.bmob.v3.helper)\n类来做版本兼容（与\nandroid.support.v4.app\n包下的NotificationCompat用法一样）。\n\n\n参照代码如下：\n\n\n    NotificationManager notificationManager = (NotificationManager) mContext\n            .getSystemService(Context.NOTIFICATION_SERVICE);\n    PendingIntent pi = PendingIntent.getActivity(mContext, 0,\n            new Intent(MainActivity.this, MainActivity.class), 0);\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)\n            .setTicker(\n更新啦\n)\n            .setContentTitle(\n标题\n)\n            .setContentText(\n内容\n)\n            .setSmallIcon(R.drawable.ic_launcher);\n    Notification notification = builder.build();\n    notificationManager.notify(0, notification);\n\n\n\n\n对象\n\n\n一个数据对象（APP中创建的BmobObject类的子类）对应于Bmob后台的一个数据表。\n\n\n数据对象\n\n\nBmob存储的数据是建立在BmobObject基础上的，所以任何要保存的数据对象必须继承自BmobObject类(不建议用抽象类去继承BmobObject或者定义父类然后在子类中写bean，这样也解析不了，一般不会这么用，一个bean类对应一张表，类似使用ORM库)。BmobObject类本身包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId是数据的唯一标示，相当于数据库中表的主键，createdAt是数据的创建时间，updatedAt是数据的最后修改时间，ACL是数据的操作权限。\n\n\n如，你的游戏中使用GameScore表来记录玩家的比分信息，其中表的字段有：score（分数）、playerName（玩家名字）、isPay(是否付费玩家)、pic（玩家头像）属性，那么这个数据对象为如下定义：\n\n\n//必须要继承自BmobObject类\npublic class GameScore extends BmobObject{\n\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public String getPlayerName() {\n        return playerName;\n    }\n\n    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n\n    public Integer getScore() {\n        return score;\n    }\n\n    public void setScore(Integer score) {\n        this.score = score;\n    }\n\n    public Boolean getIsPay() {\n        return isPay;\n    }\n\n    public void setIsPay(Boolean isPay) {\n        this. isPay = isPay;\n    }\n\n    public BmobFile getPic() {\n        return pic;\n    }\n\n    public void setPic(BmobFile pic) {\n        this.pic = pic;\n    }\n}\n\n\n\n\n需要注意的是：\n\n\n\n\nJavaBean不需要对\nobjectId、createdAt、updatedAt、ACL\n四个属性进行定义。\n\n\n不少开发者会没有注意到createdAt和updatedAt属性中的字母d，写成createAt和updateAt。\n\n\n尽可能使用Integer、Boolean，而不是int、boolean，也就是选择包装类，而不是使用基本数据类型（这两者的区别大家可以看这篇文章：http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html）\n\n\n\n\n特殊对象\n\n\n为了提供更好的服务，BmobSDK中提供了\nBmobUser、BmobInstallation、BmobRole\n三个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。\n\n\n\n\n\n\nBmobUser\n对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的\n用户管理\n部分。\n\n\n\n\n\n\nBmobInstallation\n对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的\n消息推送\n部分。\n\n\n\n\n\n\nBmobRole\n对象主要用于角色管理，对应用于Web端的Role表，具体的使用方法可查看文档的\nACL和角色\n部分。\n\n\n\n\n\n\n数据类型\n\n\n目前为止，Bmob支持的数据类型：String、Integer、Float、Short、Byte、Double、Character、Boolean、Object、Array。\n同时也支持BmobObject、BmobDate、BmobGeoPoint、BmobFile特有的数据类型。\n\n\n以下为Web端类型与SDK端支持的JAVA类型对应表：\n\n\n\n\n\n\n\n\nWeb端类型\n\n\n支持的JAVA类型\n\n\n说明\n\n\n\n\n\n\n\n\n\n\nNumber\n\n\nInteger、Float、Short、Byte、Double、Character\n\n\n对应数据库的Number类型\n\n\n\n\n\n\nArray\n\n\nList\n\n\n数组类型\n\n\n\n\n\n\nFile\n\n\nBmobFile\n\n\nBmob特有类型，用来标识文件类型\n\n\n\n\n\n\nGeoPoint\n\n\nBmobGeoPoint\n\n\nBmob特有类型，用来标识地理位置\n\n\n\n\n\n\nDate\n\n\nBmobDate\n\n\nBmob特有类型，用来标识日期类型\n\n\n\n\n\n\nPointer\n\n\n特定对象\n\n\nBmob特有类型，用来标识指针类型\n\n\n\n\n\n\nRelation\n\n\nBmobRelation\n\n\nBmob特有类型，用来标识数据关联\n\n\n\n\n\n\n\n\n注：不能使用int、float、short byte、double、character等基本数据类型。`\n\n\n类名和表名的关系\n\n\n\n\nBmob官方推荐类名和表名完全一致的映射使用方式， 即如，上面的GameScore类，它在后台对应的表名也是GameScore（区分大小写）。\n\n\n如果你希望表名和类名并不相同，如表名为T_a_b，而类名还是GameScore，那么你可以使用BmobObject提供的setTableName(\"表名\")的方法，\n\n\n\n\n示例代码如下：\n\n\n//这时候实际操作的表是T_a_b\npublic class GameScore extends BmobObject{\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public GameScore() {\n        this.setTableName(\nT_a_b\n);\n    }\n\n    public String getPlayerName() {\n        return playerName;\n    }\n    //其他方法，见上面的代码\n}\n\n\n\n\n当然了，除了在构造函数中直接调用setTableName方法之外，你还可以在GameScore的实例中动态调用setTableName方法。\n\n\n查询自定义表名的数据\n\n\n如果您使用了setTableName方法来自定义表名，那么在对该表进行数据查询的时候必须使用以下方法。\n需要注意的是查询的结果是JSONArray,需要自行解析JSONArray中的数据\n。\n\n\n/**\n * 查询数据\n */\npublic void queryData(){\n    BmobQuery query =new BmobQuery(\nPerson\n);\n    query.addWhereEqualTo(\nage\n, 25);\n    query.setLimit(2);\n    query.order(\ncreatedAt\n);\n    //v3.5.0版本提供`findObjectsByTable`方法查询自定义表名的数据\n    query.findObjectsByTable(new QueryListener\nJSONArray\n() {\n        @Override\n        public void done(JSONArray ary, BmobException e) {\n            if(e==null){\n                Log.i(\nbmob\n,\n查询成功：\n+ary.toString());\n            }else{\n                Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n            }\n        }\n    });\n}\n\n\n\n\n自定义表名情况下的更新、删除数据和普通的更新、删除数据方式一样，没有变化。为方便大家了解学习，我们提供了一个关于自定义表名情况下增删改查数据的Demo，下载地址是：\nhttps://github.com/bmob/bmob-android-demo-dynamic-tablename\n。\n\n\n添加数据\n\n\n添加数据使用BmobObject对象的\nsave\n方法，就可以将当前对象的内容保存到Bmob服务端。\n例如，你现在要保存一条游戏分数的记录，代码如下：\n\n\nGameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId(\n)方法\ngameScore.setPlayerName(\n比目\n);\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        if(e==null){\n            toast(\n创建数据成功：\n + objectId);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n})\n\n\n\n\n运行以上代码，如果添加成功，你可以在Bmob提供的后台的数据浏览中看到类似这样的结果：\n\n\nobjectId: \n0c6db13c\n, score: 89, playerName: \n比目\n, isPay: false,createdAt:\n2013-09-27 10:32:54\n, updatedAt:\n2013-09-27 10:32:54\n\n\n\n\n\n这里需要注意的是：\n\n1. 如果服务器端不存在GameScore表，那么系统将自动建表，并插入数据。\n2. 如果服务器端已经存在GameScore表，和相应的score、playerName、isPay字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则会保存数据失败。\n3. 每个BmobObject对象都有几个默认的键(数据列)是不需要开发者指定的，\nobjectId\n是每个保存成功数据的唯一标识符。\ncreatedAt\n和\nupdatedAt\n代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。\n因此，使用save和insert方法时,不需要调用setObjectId方法，否则会出现提示：“It is a reserved field: objectId(105)”--表明objectId为系统保留字段，不允许修改。\n。\n\n\n更新数据\n\n\n更新一个对象也是非常简单。例如：将GameScore表中objectId为\n0c6db13c\n的游戏分数修改为77.\n\n\nGameScore gameScore = new GameScore();\ngameScore.setScore(77);\ngameScore.update(\n0c6db13c\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n更新成功\n);\n        }else{\n            Log.i(\nbmob\n,\n更新失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n自\nV3.4.4\n版本开始，SDK提供了另一种方法来更新数据，通过调用\nBmobobject\n类中的\nsetValue（key，value）\n方法，只需要传入key及想要更新的值即可\n\n\n举例，说明如下：\n\n\npublic class Person extends BmobObject {\n    private BmobUser user;  //BmobObject类型\n    private BankCard cards; //Object类型\n    private Integer age;    //Integer类型\n    private Boolean gender; //Boolean类型\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\n\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}\n\n\n\n\n\nPerson p2=new Person();\n//更新BmobObject的值\n//  p2.setValue(\nuser\n, BmobUser.getCurrentUser(this, MyUser.class));\n//更新Object对象\np2.setValue(\nbankCard\n,new BankCard(\n农行\n, \n农行账号\n));\n//更新Object对象的值\n//p2.setValue(\nbankCard.bankName\n,\n建行\n);\n//更新Integer类型\n//p2.setValue(\nage\n,11);\n//更新Boolean类型\n//p2.setValue(\ngender\n, true);\np2.update(objectId, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n更新成功\n);\n        }else{\n            Log.i(\nbmob\n,\n更新失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n\n});\n\n\n\n\n\n注意：修改数据只能通过objectId来修改，目前不提供查询条件方式的修改方法。\n\n\n原子计数器\n\n\n很多应用可能会有计数器功能的需求，比如文章点赞的功能，如果大量用户并发操作，用普通的更新方法操作的话，会存在数据不一致的情况。\n\n\n为此，Bmob提供了原子计数器来保证原子性的修改某一\n数值字段\n的值。注意：原子计数器只能对应用于Web后台的Number类型的字段，即JavaBeans数据对象中的Integer对象类型（\n不要用int类型\n）。\n\n\ngameScore.increment(\nscore\n); // 分数递增1\ngameScore.update(updateListener);\n\n\n\n\n您还可以通过\nincrement(key, amount)\n方法来递增或递减任意幅度的数字\n\n\ngameScore.increment(\nscore\n, 5); // 分数递增5\n//gameScore.increment(\nscore\n, -5); // 分数递减5\ngameScore.update(updateListener);\n\n\n\n\n删除数据\n\n\n从服务器删除对象。例如：将GameScore表中objectId为\ndd8e6aff28\n的数据删除。\n\n\nGameScore gameScore = new GameScore();\ngameScore.setObjectId(\ndd8e6aff28\n);\ngameScore.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n注意：删除数据只能通过objectId来删除，目前不提供查询条件方式的删除方法。\n\n\n删除字段的值\n\n\n你可以在一个对象中删除一个字段的值，通过\nremove\n操作：\n\n\nGameScore gameScore = new GameScore();\ngameScore.setObjectId(\ndd8e6aff28\n);\ngameScore.remove(\nscore\n);  // 删除GameScore对象中的score字段\ngameScore.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n批量数据操作\n\n\n自2017年04月起，为了提供更稳定的服务，后端启用了QPS限制，所以推荐采用批量数据操作来解决如果需要在循环里多次提交请求但是后端返回QPS达到限制的报错。\n\n\n自\nv3.5.0\n开始,新增\nBmobBatch\n批量操作类，\n支持批量添加、批量更新、批量删除的三种操作的同步提交\n，且批量添加的请求返回objectId字段。\n\n\n在BmobObject对象中提供了三种用于批量操作的方法，分别是\ninsertBatch\n、\nupdateBatch\n、\ndeleteBatch\n,批量添加、更新、删除。\n\n\n批量添加\n\n\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nfor (int i = 0; i \n 3; i++) {\n    Person person = new Person();\n    person.setName(\n张三 \n+i);\n    persons.add(person);\n}\n//第一种方式:v3.5.0之前的版本\nnew BmobObject().insertBatch(this, persons, new SaveListener() {\n    @Override\n    public void onSuccess() {\n        toast(\n批量添加成功\n);\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast(\n批量添加失败:\n+msg);\n    }\n});\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().insertBatch(persons).doBatch(new QueryListListener\nBatchResult\n() {\n\n            @Override\n            public void done(List\nBatchResult\n o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i\no.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log(\n第\n+i+\n个数据批量添加成功：\n+result.getCreatedAt()+\n,\n+result.getObjectId()+\n,\n+result.getUpdatedAt());\n                        }else{\n                            log(\n第\n+i+\n个数据批量添加失败：\n+ex.getMessage()+\n,\n+ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n                }\n            }\n        });\n\n\n\n\n批量更新\n\n\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nPerson p1 = new Person();\np1.setObjectId(\ne51d651c22\n);\np1.setAge(25);\nPerson p2 = new Person();\np2.setObjectId(\n3f70a922c4\n);\np2.setAge(26);\np2.setGender(false);\nPerson p3 = new Person();\np3.setObjectId(\n08fdd55765\n);\np3.setAge(27);\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().updateBatch(this, persons, new UpdateListener() {\n    @Override\n    public void onSuccess() {\n        toast(\n批量更新成功\n);\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast(\n批量更新失败:\n+msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().updateBatch(persons).doBatch(new QueryListListener\nBatchResult\n() {\n\n            @Override\n            public void done(List\nBatchResult\n o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i\no.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log(\n第\n+i+\n个数据批量更新成功：\n+result.getUpdatedAt());\n                        }else{\n                            log(\n第\n+i+\n个数据批量更新失败：\n+ex.getMessage()+\n,\n+ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n                }\n            }\n        });\n\n\n\n\n批量删除\n\n\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nPerson p1 = new Person();\np1.setObjectId(\n38ea274d0c\n);\nPerson p2 = new Person();\np2.setObjectId(\n01e29165bc\n);\nPerson p3 = new Person();\np3.setObjectId(\nd8226c4828\n);\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().deleteBatch(this, persons, new DeleteListener() {\n    @Override\n    public void onSuccess() {\n        toast(\n批量删除成功\n);\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast(\n批量删除失败:\n+msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().deleteBatch(persons).doBatch(new QueryListListener\nBatchResult\n() {\n\n            @Override\n            public void done(List\nBatchResult\n o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i\no.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log(\n第\n+i+\n个数据批量删除成功\n);\n                        }else{\n                            log(\n第\n+i+\n个数据批量删除失败：\n+ex.getMessage()+\n,\n+ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n                }\n            }\n        });\n\n\n\n\n批量添加、批量更新、批量删除同步提交（v3.5.0开始提供）\n\n\nBmobBatch batch =new BmobBatch();\n//批量添加\nList\nBmobObject\n persons = new ArrayList\nBmobObject\n();\nPerson person = new Person();\nperson.setName(\n张三 \n);\npersons.add(person);\nbatch.insertBatch(persons);\n\n//批量更新\nList\nBmobObject\n persons1=new ArrayList\nBmobObject\n();\nPerson p1 = new Person();\np1.setObjectId(\n3388eb6caf\n);\np1.setAge(35);\npersons1.add(p1);\nbatch.updateBatch(persons1);\n\n//批量删除\nList\nBmobObject\n persons2 = new ArrayList\nBmobObject\n();\nPerson p2 = new Person();\np2.setObjectId(\n9af452ebd\n);\npersons2.add(p2);\nbatch.deleteBatch(persons2);\n//执行批量操作\nbatch.doBatch(new QueryListListener\nBatchResult\n(){\n\n    @Override\n    public void done(List\nBatchResult\n results, BmobException ex) {\n        if(ex==null){\n            //返回结果的results和上面提交的顺序是一样的，请一一对应\n            for(int i=0;i\nresults.size();i++){\n                BatchResult result= results.get(i);\n                if(result.isSuccess()){//只有批量添加才返回objectId\n                    log(\n第\n+i+\n个成功：\n+result.getObjectId()+\n,\n+result.getUpdatedAt());\n                }else{\n                    BmobException error= result.getError();\n                    log(\n第\n+i+\n个失败：\n+error.getErrorCode()+\n,\n+error.getMessage());\n                }\n            }\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n\n注：\n\n\n\n\n批量操作每次只支持最大50条记录的操作。\n\n\n批量操作不支持对User表的操作。\n\n\n\n\n查询数据\n\n\n数据的查询可能是每个应用都会频繁使用到的，BmobSDK中提供了\nBmobQuery\n类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。\n\n\n查询单条数据\n\n\n当我们知道某条数据的\nobjectId\n时，就可以根据\nobjectId\n直接获取单条数据对象。例如：查询\nobjectId\n为\na203eba875\n的人员信息。\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.getObject(\na203eba875\n, new QueryListener\nGameScore\n() {\n\n    @Override\n    public void done(GameScore object, BmobException e) {\n        if(e==null){\n            //获得playerName的信息\n            object.getPlayerName();\n            //获得数据的objectId信息\n            object.getObjectId();\n            //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n            object.getCreatedAt();\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n\n});\n\n\n\n\n查询多条数据\n\n\n查询某个数据表中的所有数据是非常简单的查询操作，例如：查询GameScore表中playerName为“比目”的50条数据记录。\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\n//查询playerName叫“比目”的数据\nquery.addWhereEqualTo(\nplayerName\n, \n比目\n);\n//返回50条数据，如果不加上这条语句，默认返回10条数据\nquery.setLimit(50);\n//执行查询方法\nquery.findObjects(new FindListener\nGameScore\n() {\n    @Override\n    public void done(List\nGameScore\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n+object.size()+\n条数据。\n);\n            for (GameScore gameScore : object) {\n               //获得playerName的信息\n               gameScore.getPlayerName();\n               //获得数据的objectId信息\n               gameScore.getObjectId();\n               //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n               gameScore.getCreatedAt();\n            }\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n查询的结果不需要进行任何处理，BmobSDK已经为你封装成相应的JavaBean集合了，你直接使用即可。\n\n\n注：\n\n1 通过setLimit方法设置返回的记录数量。更多细节可查看下一节(查询条件)中的分页查询。\n\n2 v3.5.2开始可以对查询条件等提供链式调用的写法，如下：\n\n\nBmobQuery\nBook\n query = new BmobQuery\n();\n        query.setLimit(8).setSkip(1).order(\n-createdAt\n)\n                .findObjects(new FindListener\nBook\n() {\n                    @Override\n                    public void done(List\nBook\n object, BmobException e) {\n                        if (e == null) {\n                            // ...\n                        } else {\n                            // ...\n                        }\n                    }\n                }); \n\n\n\n\n查询条件\n\n\n在查询的使用过程中，基于不同条件的查询是非常常见的，BmobQuery同样也支持不同条件的查询。\n\n\n比较查询\n\n\n如果要查询特定键的特定值，可以使用\naddWhereEqualTo\n方法，如果要过滤掉特定键的值可以使用\naddWhereNotEqualTo\n方法。\n\n\n比如需要查询playerName不等于“Barbie”的数据时可以这样写：\n\n\nquery.addWhereNotEqualTo(\nplayerName\n, \nBarbie\n);\n\n\n\n\n当然，你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。\n\n\nquery.addWhereNotEqualTo(\nplayerName\n, \nBarbie\n);     //名字不等于Barbie\nquery.addWhereGreaterThan(\nscore\n, 60);               //条件：分数大于60岁\n\n\n\n\n各种不同条件的比较查询：\n\n\n// 分数 \n 50\nquery.addWhereLessThan(\nscore\n, 50);\n//分数 \n= 50\nquery.addWhereLessThanOrEqualTo(\nscore\n, 50);\n//分数 \n 50\nquery.addWhereGreaterThan(\nscore\n, 50);\n//分数 \n= 50\nquery.addWhereGreaterThanOrEqualTo(\nscore\n, 50);\n\n\n\n\n子查询\n\n\n如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，你可以使用\naddWhereContainedIn\n方法来实现。\n\n\nString[] names = {\nBarbie\n, \nJoe\n, \nJulia\n};\nquery.addWhereContainedIn(\nplayerName\n, Arrays.asList(names));\n\n\n\n\n相反，如果你想查询排除“Barbie”,“Joe”,“Julia”这三个人的其他同学的信息，你可以使用\naddWhereNotContainedIn\n方法来实现。\n\n\nString[] names = {\nBarbie\n, \nJoe\n, \nJulia\n};\nquery.addWhereNotContainedIn(\nplayerName\n, Arrays.asList(names));\n\n\n\n\n时间查询\n\n\n时间查询\n比较特殊，我们需要结合\nBmobDate\n这个类来查询某个指定日期时间前后的数据，这里也给出示例供大家参考：\n\n\n比如:\n如果想查询指定日期之前的数据，则可以使用\naddWhereLessThan\n或者\naddWhereLessThanOrEqualTo\n（包含当天）来查询。\n如果想查询指定日期之后的数据，则可以使用\naddWhereGreaterThan\n或\naddWhereGreaterThanOrEqualTo\n（包含当天）来查询。\n如果想查询指定时间当天的数据，则需要使用\n复合与查询\n来查询，例如，想\n查询2015年5月1号当天的Person数据\n,示例代码如下：\n\n\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nList\nBmobQuery\nPerson\n and = new ArrayList\nBmobQuery\nPerson\n();\n//大于00：00：00\nBmobQuery\nPerson\n q1 = new BmobQuery\nPerson\n();\nString start = \n2015-05-01 00:00:00\n;  \nSimpleDateFormat sdf = new SimpleDateFormat(\nyyyy-MM-dd HH:mm:ss\n);  \nDate date  = null;\ntry {\ndate = sdf.parse(start);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq1.addWhereGreaterThanOrEqualTo(\ncreatedAt\n,new BmobDate(date));\nand.add(q1);\n//小于23：59：59\nBmobQuery\nPerson\n q2 = new BmobQuery\nPerson\n();\nString end = \n2015-05-01 23:59:59\n; \nSimpleDateFormat sdf1 = new SimpleDateFormat(\nyyyy-MM-dd HH:mm:ss\n);  \nDate date1  = null;\ntry {\ndate1 = sdf1.parse(end);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq2.addWhereLessThanOrEqualTo(\ncreatedAt\n,new BmobDate(date1));\nand.add(q2);\n//添加复合与查询\nquery.and(and);\n\n\n\n\n注：\n\n由于createdAt、updatedAt是服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以，基于时间类型的比较的值要加1秒。\n\n\n数组查询\n\n\n对于字段类型为数组的情况，需要查找字段中的数组值包含有xxx的对象，可以使用\naddWhereContainsAll\n方法：\n\n\n比如我想查询有阅读和唱歌爱好的人，可以这样：\n\n\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nString [] hobby = {\n阅读\n,\n唱歌\n};\nquery.addWhereContainsAll(\nhobby\n, Arrays.asList(hobby));\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            ...\n        }else{\n            ...\n        }\n    }\n\n});\n\n\n\n\n模糊查询\n\n\n对字符串值的模糊查询 比如 查询包含字符串的值，有几种方法。\n\n\n你可以使用任何正确的正则表达式来检索相匹配的值，使用\naddWhereMatches\n方法：\n\n\nquery.addWhereMatches((\nusername\n, \n^[A-Z]\\\\d\n);\n\n\n\n\n还可以使用如下方法：\n\n\n//查询username字段的值含有“sm”的数据\nquery.addWhereContains(\nusername\n, \nsm\n);\n\n//查询username字段的值是以“sm“字开头的数据\nquery.whereStartsWith(\nusername\n, \nsm\n);\n\n// 查询username字段的值是以“ile“字结尾的数据\nquery.whereEndsWith(\nusername\n, \nile\n);\n\n\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n列值是否存在\n\n\n如果你想查询某个列的值存在，那么可以使用\naddWhereExists\n方法：\n\n\n//查询username有值的数据\nquery.addWhereExists(\nusername\n);\n\n\n\n\n如果想查询某个列的值不存在，则可以用\naddWhereDoesNotExists\n方法\n\n\n//查询username字段没有值的数据\nquery.addWhereDoesNotExists(\nusername\n);\n\n\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用\nsetLimit\n方法来限制查询结果的数据条数来进行分页。\n\n\n默认情况下，Limit的值为\n100\n，最大有效设置值\n1000\n（设置的数值超过1000还是视为1000）。\n\n\nquery.setLimit(10); // 限制最多10条数据结果作为一页\n\n\n\n\n在数据较多的情况下，在\nsetLimit\n的基础上分页显示数据是比较合理的解决办法。\n\nsetSKip\n方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为10。\n\n\nquery.setSkip(10); // 忽略前10条数据（即第一页数据结果）\n\n\n\n\n大家也可以直接下载我们提供的Demo源码（\nhttps://github.com/bmob/bmob-android-demo-paging\n），查看如何使用分页查询，结合ListView开发下拉刷新查看更多内容的应用。\n\n\n排序\n\n\n对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：\n\n\n// 根据score字段升序显示数据\nquery.order(\nscore\n);\n// 根据score字段降序显示数据\nquery.order(\n-score\n);\n// 多个排序字段可以用（，）号分隔\nquery.order(\n-score,createdAt\n);\n\n\n\n\n说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。\n\n\n复合查询\n\n\n与查询(and)\n\n\n有些查询需要使用到复合“与”的查询条件，例如：你想查询出Person表中年龄在6-29岁之间且姓名以\"y\"或者\"e\"结尾的人，那么，可以采用and查询，示例代码如下：\n\n\n//查询年龄6-29岁之间的人，每一个查询条件都需要New一个BmobQuery对象\n//--and条件1\nBmobQuery\nPerson\n eq1 = new BmobQuery\nPerson\n();\neq1.addWhereLessThanOrEqualTo(\nage\n, 29);//年龄\n=29\n//--and条件2\nBmobQuery\nPerson\n eq2 = new BmobQuery\nPerson\n();\neq2.addWhereGreaterThanOrEqualTo(\nage\n, 6);//年龄\n=6\n\n//查询姓名以\ny\n或者\ne\n结尾的人--这个需要使用到复合或查询（or）\n//--and条件3\nBmobQuery\nPerson\n eq3 = new BmobQuery\nPerson\n();\neq3.addWhereEndsWith(\nname\n, \ny\n);\nBmobQuery\nPerson\n eq4 = new BmobQuery\nPerson\n();\neq4.addWhereEndsWith(\nname\n, \ne\n);\nList\nBmobQuery\nPerson\n queries = new ArrayList\nBmobQuery\nPerson\n();\nqueries.add(eq3);\nqueries.add(eq4);\nBmobQuery\nPerson\n mainQuery = new BmobQuery\nPerson\n();\nBmobQuery\nPerson\n or = mainQuery.or(queries);\n\n//最后组装完整的and条件\nList\nBmobQuery\nPerson\n andQuerys = new ArrayList\nBmobQuery\nPerson\n();\nandQuerys.add(eq1);\nandQuerys.add(eq2);\nandQuerys.add(or);\n//查询符合整个and条件的人\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nquery.and(andQuerys);\nquery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数：\n+object.size());\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n或查询(or)\n\n\n有些情况，在查询的时候需要使用到复合的“或”的查询条件。例如，你想查出 Person 表中 age 等于 29 或者 age 等于 6 的人，可以这样：\n\n\nBmobQuery\nPerson\n eq1 = new BmobQuery\nPerson\n();\neq1.addWhereEqualTo(\nage\n, 29);\nBmobQuery\nPerson\n eq2 = new BmobQuery\nPerson\n();\neq2.addWhereEqualTo(\nage\n, 6);\nList\nBmobQuery\nPerson\n queries = new ArrayList\nBmobQuery\nPerson\n();\nqueries.add(eq1);\nqueries.add(eq2);\nBmobQuery\nPerson\n mainQuery = new BmobQuery\nPerson\n();\nmainQuery.or(queries);\nmainQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数：\n+object.size());\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n你还可以在此基础上添加更多的约束条件到新创建的 BmobQuery 对象上，表示一个 and 查询操作。\n\n\n查询结果计数\n\n\n如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配对象的具体数据信息，可以直接使用\ncount\n替代\nfindObjects\n。例如，查询一个特定玩家玩的游戏场数：\n\n\nBmobQuery\nGameSauce\n query = new BmobQuery\nGameSauce\n();\nquery.addWhereEqualTo(\nplayerName\n, \nBarbie\n);\nquery.count(GameSauce.class, new CountListener() {\n    @Override\n    public void done(Integer count, BmobException e) {\n        if(e==null){\n            toast(\ncount对象个数为：\n+count);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n查询指定列\n\n\n有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的\naddQueryKeys\n方法来实现。如下所示：\n\n\n//只返回Person表的objectId这列的值\nBmobQuery\nPerson\n bmobQuery = new BmobQuery\nPerson\n();\nbmobQuery.addQueryKeys(\nobjectId\n);\nbmobQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object, BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n + object.size() + \n条数据。\n);\n            //注意：这里的Person对象中只有指定列的数据。\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n});\n\n\n\n\n指定多列时用\n,\n号分隔每列，如：\naddQueryKeys(\"objectId,name,age\")\n;\n\n\n统计查询\n\n\n从\nBmobSDKV3.3.6\n开始，Bmob为开发者提供了以下关键字或其组合的统计查询操作,分别用于计算\n总和、平均值、最大值、最小值\n，同时支持分组和过滤条件。\n\n\n\n\n\n\n\n\n方法名\n\n\n参数说明\n\n\n方法说明\n\n\n\n\n\n\n\n\n\n\nsum\n\n\nString[] sumKeys（多个列名）\n\n\n求某列或多列的和\n\n\n\n\n\n\naverage\n\n\nString[] aveKeys（多个列名）\n\n\n求某列或多列的平均值\n\n\n\n\n\n\nmax\n\n\nString[] maxKeys（多个列名）\n\n\n求某列或多列的最大值\n\n\n\n\n\n\nmin\n\n\nString[] minKeys（多个列名）\n\n\n求某列或多列的最小值\n\n\n\n\n\n\ngroupby\n\n\nString[] groupKeys（多个列名）\n\n\n分组\n\n\n\n\n\n\nhaving\n\n\nHashMap map(键（String）值(Object)对的形式)\n\n\n分组的过滤条件\n\n\n\n\n\n\nsetHasGroupCount\n\n\nboolean hasCount\n\n\n是否返回每个分组的记录数\n\n\n\n\n\n\n\n\n注：\n1、为避免和用户创建的列名称冲突，Bmob约定以上查询返回的字段采用\n_(关键字)+首字母大写的列名\n 的格式：\n例：\n计算玩家得分表（GameScore）中列名为score的总和，那么返回的结果集会有一个列名为\n_sumScore\n，\n若设置了setHasGroupCount（true）,则结果集中会返回\n_count\n。\n2、以上方法可自由组合且与之前的查询语句中的where, order, limit, skip等组合一起使用。 \n3、因为返回格式不固定，故使用\nfindStatistics\n来专门处理统计查询。\n\n\n统计查询方法\n\n\n例如，如果要计算所有玩家的得分总和，那么代码如下：\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] { \nplayScore\n });\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){//\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n                    int sum = obj.getInt(\n_sumPlayScore\n);//_(关键字)+首字母大写的列名\n                    showToast(\n游戏总得分：\n + sum);\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            }else{\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{  \n            Log.i(\nbmob\n,\n失败：\n+e.getMessage()+\n,\n+e.getErrorCode());\n        }\n    }\n\n});\n\n\n\n\n\n注：\nsum方法的参数只能查询Number类型的列名（对应Java的Integer类型）\n，即要计算哪个列的值的总和。\n\n\n查询平均值、最大、最小和上面的求和类似，在这里也一并提示下：\n\n\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\n//query.average(new String[]{\nplayScore\n});//查询某列的平均值\nquery.min(new String[]{\nplayScore\n});//查询最小值\n//query.max(new String[]{\nplayScore\n});//查询最大值\nquery.groupby(new String[]{\ncreatedAt\n});\nquery.findStatistics(GameScore.class, new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            JSONArray ary = (JSONArray) result;\n            if (ary!=null) {\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n    //              int playscore = obj.getInt(\n_avgPlayScore\n);\n                    int minscore = obj.getInt(\n_minPlayScore\n);\n    //              int maxscore = obj.getInt(\n_maxPlayScore\n);\n                    String createDate = obj.getString(\ncreatedAt\n);\n                    showToast(\nminscore = \n + minscore+ \n,统计时间 = \n+ createDate);\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n        } else {\n            showToast(\n查询成功，无数据\n);\n        }\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n\n分组统计\n\n\n如果你需要对查询结果进行分组，可使用\ngroupby\n方法，支持根据多个列名进行分组。\n\n\n//我们以创建时间按天和游戏分别统计玩家的得分，并按时间降序\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] { \nplayScore\n, \nsignScore\n });//求多个列的总和\nquery.groupby(new String[] { \ncreatedAt\n, \ngame\n });//按照时间和游戏名进行分组\nquery.order(\n-createdAt\n);//降序排列\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i \n length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt(\n_sumPlayScore\n);\n                        int signscore = obj.getInt(\n_sumSignScore\n);\n                        String createDate = obj.getString(\ncreatedAt\n);\n                        String game = obj.getString(\ngame\n);\n                        showToast(\n游戏总得分：\n + playscore + \n,签到得分：\n\n                                + signscore + \n,时间:\n + createDate+\n,game:\n+game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n有时候，我们需要知道分组统计时每个分组有多少条记录，可使用\nsetHasGroupCount（true）\n,如下：\n\n\n// 查询创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] { \nplayScore\n });    // 统计总得分\nquery.groupby(new String[] { \ncreatedAt\n });// 按照时间分组\nquery.order(\n-createdAt\n);                  // 降序排列\nquery.setHasGroupCount(true);              // 统计每一天有多少个玩家的得分记录，默认不返回分组个数\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if (ary!=null) {\n                int length = ary.length();\n                try {\n                    for (int i = 0; i \n length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt(\n_sumPlayScore\n);\n                        String createDate = obj.getString(\ncreatedAt\n);\n                        int count = obj.getInt(\n_count\n);//setHasGroupCount设置为true时，返回的结果中含有\n_count\n字段\n                        showToast(\n游戏总得分：\n + playscore + \n,总共统计了\n\n                                + count + \n条记录,统计时间 = \n+ createDate);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n添加过滤条件\n\n\n如果需要对分组计算后的结果再进行过滤，可使用\nhaving\n来继续过滤部分结果。\n\n\n//我们按游戏名统计所有玩家的总得分，并只返回总得分大于100的记录，并按时间降序\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.sum(new String[] {\nplayScore\n});//计算总得分数\nquery.groupby(new String[] {\ngame\n});//分组条件：按游戏名进行分组\nquery.order(\n-createdAt\n);// 降序排列\nHashMap\nString, Object\n map = new HashMap\nString, Object\n();\nJSONObject js = new JSONObject();\ntry {\n    js.put(\n$gt\n, 100);\n} catch (JSONException e1) {\n}\nmap.put(\n_sumPlayScore\n, js);//过滤条件：总得分数大于100\nquery.having(map);\nquery.setLimit(100);\nquery.findStatistics(GameScore.class,new QueryListener\nJSONArray\n() {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i \n length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt(\n_sumPlayScore\n);//过滤条件的key是什么，返回的数据中就有什么\n                        String game = obj.getString(\ngame\n);//返回的数据中同样包含groupby里面的列名\n                        showToast(\n游戏得分：\n + playscore + \n,游戏名 = \n+ game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            loge(e);\n        }\n    }\n\n});\n\n\n\n\n\n缓存查询\n\n\n缓存查询通常是将查询结果缓存在磁盘上。\n当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。\n或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。\n这样可以让用户不必在按下某个按钮后进行枯燥的等待。\n默认的查询操作是没有启用缓存的，开发者可以使用\nsetCachePolicy\n方法来启用缓存功能。\n例如：优先从缓存获取数据，如果获取失败再从网络获取数据。\n\n\nbmobQuery.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 先从缓存获取数据，如果没有，再从网络获取。\nbmobQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n+object.size()+\n条数据。\n);\n        }else{\n            toast(\n查询失败：\n+msg);\n        }\n    }\n\n});\n\n\n\n\n缓存策略\n\n\nBmob SDK提供了几种不同的缓存策略，以适应不同应用场景的需求：\n\n\n\n\nIGNORE_CACHE\n     :只从网络获取数据，且不会将数据缓存在本地，这是默认的缓存策略。\n\n\nCACHE_ONLY\n        :只从缓存读取数据，如果缓存没有数据会导致一个BmobException,可以忽略不处理这个BmobException.\n\n\nNETWORK_ONLY\n      :只从网络获取数据，同时会在本地缓存数据。\n\n\nNETWORK_ELSE_CACHE\n:先从网络读取数据，如果没有，再从缓存中获取。\n\n\nCACHE_ELSE_NETWORK\n:先从缓存读取数据，如果没有，再从网络获取。\n\n\nCACHE_THEN_NETWORK\n:先从缓存取数据，无论结果如何都会再次从网络获取数据。也就是说会产生2次调用。\n\n\n\n\n建议的做法：\n\n\n第一次进入应用的时候，设置其查询的缓存策略为\nCACHE_ELSE_NETWORK\n,当用户执行上拉或者下拉刷新操作时，设置查询的缓存策略为\nNETWORK_ELSE_CACHE\n。\n\n\n缓存方法\n\n\n如果需要操作缓存内容，可以使用BmobQuery提供的方法做如下操作：\n\n\n\n\n检查是否存在当前查询条件的缓存数据\n\n\n\n\nboolean isInCache = query.hasCachedResult(Class\n?\n clazz);\n\n\n\n\n注：缓存和查询条件有关，此方法必须放在所有的查询条件（where、limit、order、skip、include等）都设置完之后，否则会得不到缓存数据。\n\n\n\n\n清除当前查询的缓存数据\n\n\n\n\nquery.clearCachedResult(Class\n?\n clazz);\n\n\n\n\n\n\n清除所有查询结果的缓存数据\n\n\n\n\nBmobQuery.clearAllCachedResults(Class\n?\n clazz);\n\n\n\n\n\n\n设置缓存的最长时间（以毫秒为单位）\n\n\n\n\nquery.setMaxCacheAge(TimeUnit.DAYS.toMillis(1));//此表示缓存一天\n\n\n\n\n示例如下：\n\n\nBmobQuery\nPerson\n query  = new BmobQuery\nPerson\n();\nquery.addWhereEqualTo(\nage\n, 25);\nquery.setLimit(10);\nquery.order(\ncreatedAt\n);\n//判断是否有缓存，该方法必须放在查询条件（如果有的话）都设置完之后再来调用才有效，就像这里一样。\nboolean isCache = query.hasCachedResult(Person.class);\nif(isCache){--此为举个例子，并不一定按这种方式来设置缓存策略\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n+object.size()+\n条数据。\n);\n        }else{\n            toast(\n查询失败：\n+msg);\n        }\n    }\n});\n\n\n\n\n注：\n\n\n1、只有当缓存查询的条件一模一样时才会获取到缓存到本地的缓存数据。\n\n\n2、设置的默认的最大缓存时长为5小时。\n\n\nBQL查询\n\n\nBmob Query Language\n（简称 BQL） 是 Bmob 自 \nBmobSDKV3.3.7\n 版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。 \n\n\n具体的 BQL 语法，请参考 \nBmob Query Language 详细指南\n。\n\n\n基本BQL查询\n\n\n可以通过以下方法来进行SQL查询：\n例如：需要查询所有的游戏得分记录\n\n\nString bql =\nselect * from GameScore\n;//查询所有的游戏得分记录\nnew BmobQuery\nGameScore\n().doSQLQuery(bql,new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n上面的示例也等价于(\n此方法自BmobV3.3.8版本提供\n)：\n\n\n//查询所有的游戏得分记录\nString bql =\nselect * from GameScore\n;\nBmobQuery\nGameScore\n query=new BmobQuery\nGameScore\n();\n//设置查询的SQL语句\nquery.setSQL(bql);\nquery.doSQLQuery(new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n如果需要查询个数，则可以这样：\n\n\nString bql = \nselect count(*),* from GameScore\n;//查询GameScore表中总记录数并返回所有记录信息\nnew BmobQuery\nGameScore\n().doSQLQuery(bql, new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            int count = result.getCount();//这里得到符合条件的记录数\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线 \n_\n。\n\n\n比如，你想查询的是用户\nsmile\n的信息，则：\n\n\nselect * from _User where username = smile\n\n\n\n\n统计BQL查询\n\n\n由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用\ndoStatisticQuery\n方法来进行：\n\n\n//按照姓名分组求和,并将结果按时间降序排列\nString bql = \nselect sum(playScore) from GameScore group by name order by -createdAt\n;\nnew BmobQuery\nGameScore\n().doStatisticQuery(bql,new QueryListener\nJSONArray\n(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        if(e ==null){\n            JSONArray ary = (JSONArray) result;\n            if(ary!=null){//开发者需要根据返回结果自行解析数据\n                ...\n            }else{\n                showToast(\n查询成功，无数据\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n占位符查询\n\n\n在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的 \nPreparedStatement\n 使用占位符查询的语法结构。\n\n\n普通查询\n\n\nString bql=\nselect * from GameScore where player = ? and game = ?\n;//查询玩家1的地铁跑酷的GameScore信息\nnew BmobQuery\nGameScore\n().doSQLQuery(bql,new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n},\n玩家1\n,\n地铁跑酷\n);\n\n\n\n\n最后的可变参数 \n玩家1\n 和 \n地铁跑酷\n 会自动替换查询语句中的问号位置（按照问号的先后出现顺序）。\n\n\n上面的示例也等价于如下代码（\n此方法自BmobV3.3.8版本提供\n）：\n\n\nString bql=\nselect * from GameScore where player = ? and game = ?\n;\nBmobQuery\nGameScore\n query=new BmobQuery\nGameScore\n();\n//设置SQL语句\nquery.setSQL(bql);\n//设置占位符参数\nquery.setPreparedParams(new Object[]{\n玩家1\n,\n地铁跑酷\n});\nquery.doSQLQuery(new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n内置函数\n\n\n对于包含\n内置函数\n的占位符查询，比较特殊，请使用\nBmob Query Language 详细指南\n中的\n内置函数\n中\n占位符查询用到的内置函数\n列出的形式进行查询操作：\n\n\n举例：我想查询当前用户在2015年5月12日之后，在特定地理位置附近的游戏记录，可以这样：\n\n\nString sql = \nselect * from GameScore where createdAt \n date(?) and player = pointer(?,?) and gps near geopoint(?,?)\n;\nnew BmobQuery\nGameScore\n().doSQLQuery(sql,new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            List\nGameScore\n list = (List\nGameScore\n) result.getResults();\n            if(list!=null \n list.size()\n0){\n                ...\n            }else{\n                Log.i(\nsmile\n, \n查询成功，无数据返回\n);\n            }\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n},\n2015-05-12 00:00:00\n,\n_User\n,user.getObjectId(),112.934755,24.52065);\n\n\n\n\n注\n\n\n1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；\n\n\n2、最后的可变参数会自动替换查询语句中的问号位置（按照问号的先后出现顺序），有多少个问号，最后的可变参数就应该有多少个；\n\n\n3、同样的，统计查询也支持占位符,只需要将\ndoSQLQuery\n替换成\ndoStatisticQuery\n方法即可；\n\n\n4、只有查询条件\nwhere``limit\n子句支持占位符查询，和统计查询有关的\ngroup by\n、\norder by\n、\nhaving\n等字句是不支持占位符的。\n\n\n例如：\n\n正确\n查询：\n\n\n//按照游戏名进行分组并获取总得分数大于200的统计信息，同时统计各分组的记录数\nString bql = \nselect sum(playScore),count(*) from GameScore group by game having _sumPlayScore\n200\n;\nnew BmobQuery\nGameScore\n().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n});\n\n\n\n\n错误\n查询：\n\n\nString bql = \nselect sum(playScore),count(*) from GameScore group by ? having ?\n;\nnew BmobQuery\nGameScore\n().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n},\ngame\n,\n_sumPlayScore\n200\n);\n\n\n\n\nBQL缓存查询\n\n\nBQL查询同步支持\n缓存查询\n，只需要调用BmobQuery的\nsetCachePolicy\n方法设置缓存策略即可，\n建议使用如下方式进行BQL缓存查询\n：\n\n\nString sql = \nselect * from GameScore order by playScore,signScore desc\n;\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\n//设置sql语句\nquery.setSQL(sql);\n//判断此查询本地是否存在缓存数据\nboolean isCache = query.hasCachedResult(GameScore.class);\nif(isCache){\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.doSQLQuery(new SQLQueryListener\nGameScore\n(){\n\n    @Override\n    public void done(BmobQueryResult\nGameScore\n result, BmobException e) {\n        if(e ==null){\n            Log.i(\nsmile\n, \n查询到：\n+result.getResults().size()+\n符合条件的数据\n);\n        }else{\n            Log.i(\nsmile\n, \n错误码：\n+e.getErrorCode()+\n，错误描述：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n注：\n\n\ndoSQLQuery目前有三种查询方式进行SQL查询，分别是：\n\n\n1、doSQLQuery（Context context,SQLQueryListener\n listener)\n\n\n2、doSQLQuery（Context context, String bql, SQLQueryListener\n listener)----基本BQL查询\n\n\n3、doSQLQuery（Context context, String bql, SQLQueryListener\n listener,Object... params)----占位符查询\n\n\n只有\n第一种查询方式\n才能和\nquery.hasCachedResult(context,class)\n或者\nquery.clearCachedResult(context,class)\n并列使用。\n\n\n建议使用\n第一种查询方式\n进行BQL缓存查询。\n\n\n数组\n\n\n对于数组类型数据，BmobSDK提供了3种操作来原子性地修改一个数组字段的值：\n\n\n\n\nadd、addAll\n 在一个数组字段的后面添加一些指定的对象(包装在一个数组内)\n\n\naddUnique、addAllUnique\n 只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置随机\n\n\nremoveAll\n 从一个数组字段的值内移除指定数组中的所有对象\n\n\n\n\n举例子：\n\n\npublic class Person extends BmobObject {\n    private List\nString\n hobbys;        // 爱好-对应服务端Array类型：String类型的集合\n    private List\nBankCard\n cards;       // 银行卡-对应服务端Array类型:Object类型的集合\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}\n\n\n\n\n添加数组数据\n\n\n给\nPerson\n对象中的数组类型字段添加数据,有以下两种方式：\n\n\n使用add、addAll添加\n\n\nPerson p = new Person();\np.setObjectId(\nd32143db92\n);\n//添加String类型的数组\np.add(\nhobbys\n, \n唱歌\n);                              // 添加单个String\n//p.addAll(\nhobbys\n, Arrays.asList(\n游泳\n, \n看书\n));    // 添加多个String\n//添加Object类型的数组\np.add(\ncards\n,new BankCard(\n工行卡\n, \n工行卡账号\n))   //添加单个Object\nList\nBankCard\n cards =new ArrayList\nBankCard\n();\nfor(int i=0;i\n2;i++){\n    cards.add(new BankCard(\n建行卡\n+i, \n建行卡账号\n+i));\n}\n//p.addAll(\ncards\n, cards);                         //添加多个Object值\np.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n保存成功\n);\n        }else{\n            Log.i(\nbmob\n,\n保存失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n 注：此类方法不管这些数据之前是否已添加过，都会再次添加。\n\n\n使用addUnique、addAllUnique添加\n\n\nPerson p = new Person();\n//添加String类型的数组\np.addUnique(\nhobbys\n, \n唱歌\n);                                // 添加单个String\n//p.addAllUnique(\nhobbys\n, Arrays.asList(\n游泳\n, \n看书\n));  // 添加多个String\n//添加Object类型的数组\np.addUnique(\ncards\n,new BankCard(\n工行卡\n, \n工行卡账号\n))     //添加单个Object\nList\nBankCard\n cards =new ArrayList\nBankCard\n();\nfor(int i=0;i\n2;i++){\n    cards.add(new BankCard(\n建行卡\n+i, \n建行卡账号\n+i));\n}\n//p.addAllUnique(\ncards\n, cards);                           //添加多个Object\np.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功:\n+objectId);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n 注： 只有在这些数据之前未添加过的情况下才会被添加。\n\n\n更新数组数据\n\n\n数组更新比较特殊，自\nV3.4.4\n版本开始提供\nBmobObject\n的\nsetValue\n方法来更新数组，例：\n\n\nPerson p2 = new Person();\n//更新String类型数组中的值\np2.setValue(\nhobbys.0\n,\n爬山\n);                             //将hobbys中第一个位置的爱好（上面添加成功的唱歌）修改为爬山\n//更新Object类型数组中的某个位置的对象值(0对应集合中第一个元素)\np2.setValue(\ncards.0\n, new BankCard(\n中行\n, \n中行卡号\n));    //将cards中第一个位置银行卡修改为指定BankCard对象\n//更新Object类型数组中指定对象的指定字段的值\n//  p2.setValue(\ncards.0.bankName\n, \n农行卡\n);             //将cards中第一个位置的银行卡名称修改为农行卡\n//  p2.setValue(\ncards.1.cardNumber\n, \n农行卡账号\n);         //将cards中第二个位置的银行卡账号修改为农行卡账号\np2.update(objectId, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n删除数组数据\n\n\n同理我们也可以使用removeAll从数组字段中移除某些值：\n\n\nPerson p = new Person();\np.removeAll(\nhobby\n, Arrays.asList(\n阅读\n,\n唱歌\n,\n游泳\n));\np.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n查询数组数据\n\n\n对于字段类型为数组的情况，可以以数组字段中包含有xxx的数据为条件进行查询：\n\n\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nString [] hobby = {\n阅读\n,\n唱歌\n};\nquery.addWhereContainsAll(\nhobby\n, Arrays.asList(hobby));\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n查询成功：共\n + object.size() + \n条数据。\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n数据关联性\n\n\n关联关系描述\n\n\n在程序设计中，不同类型的数据之间可能存在某种关系。\n比如：帖子和作者的关系，一篇帖子只属于某个作者，这是\n一对一的关系\n。\n比如：帖子和评论的关系，一条评论只属于某一篇帖子，而一篇帖子对应有很多条评论，这是\n一对多的关系\n。\n比如：学生和课程的关系，一个学生可以选择很多课程，一个课程也可以被很多学生所选择，这是\n多对多的关系\n。\n\n\nBmob提供了\nPointer（一对一、一对多）\n和\nRelation（多对多）\n两种数据类型来解决这种业务需求。\n\n\n关联关系案例详解\n\n\n由于关联关系讲解起来比较复杂，以下用一个简单的案例来说明在Bmob中是如何使用关联关系的。\n\n\n场景：\n用户发表帖子，同时又可对帖子进行评论留言。\n\n\n在这个场景中涉及到三个表：用户表（\n_User\n）、帖子表（\nPost\n）、评论表（\nComment\n）,以下是各个表的字段：\n\n\n_User\n字段如下：\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nString\n\n\n用户ID\n\n\n\n\n\n\nusername\n\n\nString\n\n\n用户名(可以既发帖子又发评论)\n\n\n\n\n\n\nage\n\n\nInteger\n\n\n年龄\n\n\n\n\n\n\n\n\nPost\n字段如下：\n\n\n\n\n\n\n\n\n字段\n\n\n含义\n\n\n类型\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nString\n\n\n帖子ID\n\n\n\n\n\n\ntitle\n\n\nString\n\n\n帖子标题\n\n\n\n\n\n\ncontent\n\n\nString\n\n\n帖子内容\n\n\n\n\n\n\nauthor\n\n\nPointer\n\n\n帖子作者\n\n\n\n\n\n\nlikes\n\n\nRelation\n\n\n喜欢帖子的读者\n\n\n\n\n\n\n\n\nComment\n字段如下：\n\n\n\n\n\n\n\n\n字段\n\n\n含义\n\n\n类型\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nString\n\n\n评论ID\n\n\n\n\n\n\ncontent\n\n\nString\n\n\n评论内容\n\n\n\n\n\n\npost\n\n\nPointer\n\n\n评论对应的帖子\n\n\n\n\n\n\nauthor\n\n\nPointer\n\n\n评论该帖子的人\n\n\n\n\n\n\n\n\nWeb端创建关联字段\n\n\n如果你需要在Web端创建上述表的话，那么当选择的字段类型为\nPointer或Relation\n时，会提示你选择该字段所指向或关联的数据表。\n\n\n如下图所示：\n\n\n\n\n创建数据对象\n\n\npublic class MyUser extends BmobUser {\n\n    private Integer age;//为用户表新增一个age字段，注意其必须为`Integer`类型，而不是int\n\n    //自行实现getter和setter方法\n}\n\n\n\n\n\n1、扩展BmobUser的时，不需要再加上\nobjectId、username、password、createAt、updateAt\n等系统字段，因为BmobUser中已经实现了，如果再次声明的话，会导致编译性的错误。\n\n\n2、类名可以自定义，这个跟其他表的命名方式有所不同。\n\n\n\npublic class Post extends BmobObject {\n\n    private String title;//帖子标题\n\n    private String content;// 帖子内容\n\n    private MyUser author;//帖子的发布者，这里体现的是一对一的关系，该帖子属于某个用户\n\n    private BmobFile image;//帖子图片\n\n    private BmobRelation likes;//多对多关系：用于存储喜欢该帖子的所有用户\n\n    //自行实现getter和setter方法\n\n}\n\n\n\n\n\n\npublic class Comment extends BmobObject {\n\n    private String content;//评论内容  \n\n    private MyUser user;//评论的用户，Pointer类型，一对一关系\n\n    private Post post; //所评论的帖子，这里体现的是一对多的关系，一个评论只能属于一个微博\n\n    //自行实现getter和setter方法\n}\n\n\n\n\n\n注：\n\n\n1、类名要和数据表名保持一致。\n\n\n2、MyUser属性对应为Pointer的指针类型。\n\n\n以下举例均假定A用户已注册并登陆\n\n\n\n\n一对一关系\n\n\n用户发表帖子，一篇帖子也只能属于某个用户，那么帖子和用户之间的关系是\n一对一关系\n，建议使用\nPointer\n类型来表示。\n\n\nPointer\n本质上可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针来获得其指向的关联对象。\n\n\n用户A写了一篇帖子，需要在\nPost\n表中生成一条记录，并将该帖子关联到用户A这条记录，表明该帖子是A所发表的。\n\n\n示例如下：\n\n\n添加一对一关联\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\n// 创建帖子信息\nPost post = new Post();\npost.setContent(content);\n//添加一对一关联\npost.setAuthor(user);\npost.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n保存成功\n);\n        }else{\n            Log.i(\nbmob\n,\n保存失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n添加成功后，在后台的\nPost\n表中，你就会看到有一条记录生成，并且该帖子的\nauthor\n字段的值指向了\n_User\n表中的\n用户A\n这条记录。\n\n\n\n\n查询一对一关联\n\n\n如果想查询\n用户A\n(当前用户)所发表的所有帖子，那么可以这样：\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobQuery\nPost\n query = new BmobQuery\nPost\n();\nquery.addWhereEqualTo(\nauthor\n, user);  // 查询当前用户的所有帖子\nquery.order(\n-updatedAt\n);\nquery.include(\nauthor\n);// 希望在查询帖子信息的同时也把发布人的信息查询出来\nquery.findObjects(new FindListener\nPost\n() {\n\n    @Override\n    public void done(List\nPost\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n注：如果想查询某个用户所发表的所有帖子，则将该用户查询出来，然后使用上述代码查询指定用户所发表的所有帖子。\n\n\n更新一对一关联\n\n\n如果希望将刚刚这条帖子的作者修改成\n用户B\n,示例：\n\n\nPost p = new Post();\n//构造用户B，如果你知道用户B的objectId的话，可以使用这种方式进行关联，如果不知道的话，你需要将用户B查询出来\n// 这里假设已知用户B的objectId为aJyG2224\nMyUser userB =new MyUser();\nuserB.setObjectId(\naJyG2224\n);\np.setAuthor(userB);//重新设置帖子作者\np.update(\nESIt3334\n, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n修改成功后，在后台可查看到这个帖子的作者已经变更为用户B\n\n\n\n\n删除一对一关联\n\n\n如果你想和\nESIt3334\n这个帖子解除关联关系，可以这样：\n\n\nPost p = new Post();\np.remove(\nauthor\n);\np.update(\nESIt3334\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n删除成功后，在后台的\nPost\n表中，你就会看到\nESIt3334\n这个帖子的\nauthor\n字段的值已经被置空了。\n\n\n\n\n一对多关系\n\n\n一条评论只能属于某一篇帖子，一篇帖子可以有很多用户对其进行评论，那么帖子和评论之间的关系就是\n一对多关系\n，推荐使用\npointer\n类型来表示\n。\n\n\n因为使用方法和上面的一对一关联基本相同，只是查询一对多关联的时候有些区别，故只举添加和查询两个例子：\n\n\n添加一对多关联\n\n\n将评论和微博进行关联，并同时和当前用户进行关联，表明是当前用户对该帖子进行评论，示例如下：\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\nfinal Comment comment = new Comment();\ncomment.setContent(content);\ncomment.setPost(post);\ncomment.setUser(user);\ncomment.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n评论发表成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n查询一对多关联\n\n\n我想\n查询出某个帖子（objectId为ESIt3334）的所有评论,同时将该评论的作者的信息也查询出来\n，那么可以使用\naddWhereEqualTo\n方法进行查询：\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\n//用此方式可以构造一个BmobPointer对象。只需要设置objectId就行\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\nquery.addWhereEqualTo(\npost\n,new BmobPointer(post));        \n//希望同时查询该评论的发布者的信息，以及该帖子的作者的信息，这里用到上面`include`的并列对象查询和内嵌对象的查询\nquery.include(\nuser,post.author\n);\nquery.findObjects(new FindListener\nComment\n() {\n\n    @Override\n    public void done(List\nComment\n objects,BmobException e) {\n        ...\n    }\n});\n\n\n\n\n\n注：\naddWhereEqualTo\n对\nBmobPonter\n类型的一对多的关联查询是\nBmobSDKV3.3.8\n开始支持的，因此使用时，请更新SDK版本。\n\n\n多对多关系\n\n\n一个帖子可以被很多用户所喜欢，一个用户也可能会喜欢很多帖子，那么可以使用\nRelation\n类型来表示这种\n多对多关联关系\n。\n\n\nRelation\n本质上可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。\n\n\n添加多对多关联\n\n\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\n//将当前用户添加到Post表中的likes字段值中，表明当前用户喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//将当前用户添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n多对多关联添加成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n添加成功后，在后台的\nPost\n表中就能查看到\nlikes\n字段已经生成并对应到了\n_User\n\n\n\n\n点击红框中的\n关联关系\n按钮展开后，可查看刚才所添加的喜欢该帖子的用户A：\n\n\n\n\n查询多对多关联\n\n\n如果希望\n查询喜欢该帖子（objectId为ESIt3334）的所有用户\n,那么就需要用到\naddWhereRelatedTo\n方法进行多对多关联查询。\n\n\n示例代码：\n\n\n// 查询喜欢这个帖子的所有用户，因此查询的是用户表\nBmobQuery\nMyUser\n query = new BmobQuery\nMyUser\n();\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\n//likes是Post表中的字段，用来存储所有喜欢该帖子的用户\nquery.addWhereRelatedTo(\nlikes\n, new BmobPointer(post));    \nquery.findObjects(new FindListener\nMyUser\n() {\n\n    @Override\n    public void done(List\nMyUser\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n查询个数：\n+object.size());\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n修改多对多关联\n\n\n如果\n用户B也喜欢该帖子（objectId为ESIt3334）\n，此时需要为该帖子(Post)的\nlikes\n字段多添加一个用户,示例如下：\n\n\nPost post = new Post();\npost.setObjectId(\nESIt3334\n);\n//将用户B添加到Post表中的likes字段值中，表明用户B喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//构造用户B\nMyUser user = new MyUser();\nuser.setObjectId(\naJyG2224\n);\n//将用户B添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n用户B和该帖子关联成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n修改成功后，你在点击该帖子的\nlikes\n字段下面的\n关联关系\n按钮展开后，可查看刚才所添加的喜欢该帖子的用户B：\n\n\n\n\n删除多对多关联\n\n\n如果\n想对该帖子进行取消喜欢的操作\n，此时，需要删除之前的多对多关联，具体代码：\n\n\nPost post = new Post();\npost.setObjectId(\n83ce274594\n);\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobRelation relation = new BmobRelation();\nrelation.remove(user);\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n关联关系删除成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n1 例子中的Comment和Post表请大家注意下在后端控制台建表的数据类型是Pointer还是Relation 否则返回类型不匹配的111错误，表的结构和字段类型如下：\n\n\n\n\n\n\n2 为方便大家了解学习，我们提供了一个关于数据关联的Demo，下载地址是：https://github.com/bmob/RelationDemo\n\n\ninclude用法\n\n\n在某些情况下，你想在一个查询内获取\nPointer\n类型的关联对象。\n\n\n比如上述示例中，如果希望在查询帖子信息的同时也把该帖子的作者的信息查询出来，可以使用\ninclude\n方法\n\n\nquery.include(\nauthor\n);\n\n\n\n\n你可以使用\n,\n号(逗号)操作符来\ninclude并列查询\n两个对象\n\n\n比如，查询评论表的同时将该评论用户的信息和所评论的帖子信息也一并查询出来（因为Comment表有两个\nPointer类型\n的字段），那么可以这样做：\n\n\nquery.include(\nuser,post\n);\n\n\n\n\n但不能如下的做法：\n\n\nquery.include(\nuser\n);\nquery.include(\npost\n);\n\n\n\n\n你同时还可以使用 \n.\n号（英语句号）操作符来进行\ninclude中的内嵌对象查询\n\n\n比如，你想在查询评论信息的同时将该评论\nComment\n对应的帖子\npost\n以及该帖子的作者信息\nauthor\n一并查询出来，你可以这样做：\n\n\nquery.include(\npost.author\n);\n\n\n\n\n另外，include还可以指定返回的字段：\n\n\nquery.include(\npost[likes].author[username|email]\n);\n\n\n\n\n其中，post和author都是Pointer类型，post指向的表只返回likes字段，author指向的表只返回username和email字段。\n\n\n注：include的查询对象只能为BmobPointer类型，而不能是BmobRelation类型。\n\n\n内部查询\n\n\n如果你在查询某个对象列表时，它们的某个字段是BmobObject类型，并且这个BmobObject匹配一个不同的查询，这种情况下可使用\naddWhereMatchesQuery\n方法。\n\n\n请注意，默认的 limit 限制 100 也同样作用在内部查询上。因此如果是大规模的数据查询，你可能需要仔细构造你的查询对象来获取想要的行为。\n\n\n例如：\n查询带有图片的帖子的评论列表\n:\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\nBmobQuery\nPost\n innerQuery = new BmobQuery\nPost\n();\ninnerQuery.addWhereExists(\nimage\n, true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用\nPost\n字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery(\npost\n, \nPost\n, innerQuery);\nquery.findObjects(new FindListener\nComment\n() {\n\n    @Override\n    public void done(List\nComment\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n反之，不想匹配某个子查询，你可以使用\naddWhereDoesNotMatchQuery\n方法。 \n\n\n比如\n查询不带图片的帖子的评论列表\n：\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\nBmobQuery\nPost\n innerQuery = new BmobQuery\nPost\n();\ninnerQuery.addWhereExists(\nimage\n, true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用\nPost\n字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereDoesNotMatchQuery(\npost\n, \nPost\n, innerQuery);\nquery.findObjects(new FindListener\nComment\n() {\n    @Override\n    public void done(List\nComment\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n注：\n\n\n当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线\n_\n。\n\n\n比如，你想查询出用户\nsmile\n和\nsmile\n好友的所有帖子，则可以这样：\n\n\n\nBmobQuery\nUser\n innerQuery = new BmobQuery\nUser\n();\nString[] friendIds={\nssss\n,\naaaa\n};//好友的objectId数组\ninnerQuery.addWhereContainedIn(\nobjectId\n, Arrays.asList(friendIds));\n//查询帖子\nBmobQuery\nPost\n query = new BmobQuery\nPost\n();\n`query.addWhereMatchesQuery(\nauthor\n, \n_User\n, innerQuery);`\nquery.findObjects(new FindListener\nPost\n() {\n    @Override\n    public void done(List\nPost\n object,BmobException e) {\n        if(e==null){\n            Log.i(\nbmob\n,\n成功\n);\n        }else{\n            Log.i(\nbmob\n,\n失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n用户管理\n\n\n用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。\n\n\n有了这个类，你就可以在你的应用程序中添加用户账户功能。\n\n\nBmobUser是BmobObject的一个子类，它继承了BmobObject所有的方法，具有BmobObject相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。\n\n\n属性\n\n\nBmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\nusername: 用户的用户名\n（必需）\n。\npassword: 用户的密码\n（必需）\n。\nemail: 用户的电子邮件地址\n（可选）\n。\nemailVerified:邮箱认证状态\n（可选）\n。\nmobilePhoneNumber：手机号码\n（可选）\n。\nmobilePhoneNumberVerified：手机号码的认证状态\n（可选）\n。\n\n\n扩展用户类\n\n\n很多时候，你的用户表还会有很多其他字段，如性别、年龄、头像等。那么，你需要对BmobUser类进行扩展，添加一些新的属性。示例代码如下所示：\n\n\npublic class MyUser extends BmobUser {\n\n    private Boolean sex;\n    private String nick;\n    private Integer age;\n\n    public boolean getSex() {\n        return this.sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getNick() {\n        return this.nick;\n    }\n\n    public void setNick(String nick) {\n        this.nick = nick;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n\n\n\n\n更多代码实现大家可以下载SDK，在里面的\nBmobExample\n中查找\nMyUser\n类，参考它的用法。\n\n\n创建用户\n\n\n创建用户对象如下：\n\n\nBmobUser user = new BmobUser();\n\n\n\n\n注册\n\n\n你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：\n\n\nBmobUser bu = new BmobUser();\nbu.setUsername(\nsendi\n);\nbu.setPassword(\n123456\n);\nbu.setEmail(\nsendi@163.com\n);\n//注意：不能用save方法进行注册\nbu.signUp(new SaveListener\nMyUser\n() {\n    @Override\n    public void done(MyUser s, BmobException e) {\n        if(e==null){\n            toast(\n注册成功:\n +s.toString());\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。\n\n\n如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。\n\n\n你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。\n\n\n注：\n\n\n\n\n有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。\n\n\n\n\n\n\n\n\nusername字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。\n\n\n\n\n登录\n\n\n当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。\n\n\nBmobUser bu2 = new BmobUser();\nbu2.setUsername(\nlucky\n);\nbu2.setPassword(\n123456\n);\nbu2.login(new SaveListener\nBmobUser\n() {\n\n    @Override\n    public void done(BmobUser bmobUser, BmobException e) {\n        if(e==null){\n            toast(\n登录成功:\n);\n            //通过BmobUser user = BmobUser.getCurrentUser()获取登录成功后的本地用户信息\n            //如果是自定义用户对象MyUser，可通过MyUser user = BmobUser.getCurrentUser(MyUser.class)获取自定义用户信息\n        }else{\n            loge(e);\n        }\n    }\n});\n\n\n\n\n也可使用如下方式完成\n用户名+密码\n的登录：\n\n\nBmobUser.loginByAccount(\nusername\n, \n用户密码\n, new LogInListener\nMyUser\n() {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i(\nsmile\n,\n用户登陆成功\n);\n                }\n            }\n        });\n\n\n\n\n\n当前用户\n\n\n如果用户在每次打开你的应用程序时都要登录，这将会直接影响到你应用的用户体验。为了避免这种情况，你可以使用缓存的CurrentUser对象。缓存的用户有效期为1年。\n\n\n每当你应用的用户注册成功或是第一次登录成功，都会在本地磁盘中有一个缓存的用户对象，这样，你可以通过获取这个缓存的用户对象来进行登录：\n\n\nBmobUser bmobUser = BmobUser.getCurrentUser();\nif(bmobUser != null){\n    // 允许用户使用应用\n}else{\n    //缓存用户对象为空时， 可打开用户注册界面…\n}\n\n\n\n\n在扩展了用户类的情况下获取当前登录用户，可以使用如下的示例代码（\nMyUser\n类可参看上面）：\n\n\nMyUser userInfo = BmobUser.getCurrentUser(MyUser.class);\n\n\n\n\n\n自\nV3.4.5\n版本开始，SDK新增了\ngetObjectByKey(context,key)\n方法从本地缓存中获取当前登陆用户某一列的值。其中\nkey\n为用户表的指定列名。\n\n\n//BmobUser中的特定属性\nString username = (String) BmobUser.getObjectByKey(\nusername\n);\n//MyUser中的扩展属性\nInteger age = (Integer) BmobUser.getObjectByKey(\nage\n);\nBoolean sex = (Boolean) BmobUser.getObjectByKey(\nsex\n);\n\n\n\n\n更新用户\n\n\n很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，Bmob提供的用户更新方式有两种写法：\n\n\n第一种：\n新建一个用户对象，并调用update(objectId,updateListener)方法来更新（推荐使用）\n，示例：\n\n\nBmobUser newUser = new BmobUser();\nnewUser.setEmail(\nxxx@163.com\n);\nBmobUser bmobUser = BmobUser.getCurrentUser(context);\nnewUser.update(bmobUser.getObjectId(),new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n更新用户信息成功\n);\n        }else{\n            toast(\n更新用户信息失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n第二种：获取本地的用户对象，并调用update（updateListener）方法来更新（\n不推荐使用\n），示例：\n\n\nBmobUser bmobUser = BmobUser.getCurrentUser();\n// 修改用户的邮箱为xxx@163.com\nbmobUser.setEmail(\nxxx@163.com\n);\nbmobUser.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n更新用户信息成功\n);\n        }else{\n            toast(\n更新用户信息失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n1、开发者在进行用户更新操作的时候，推荐使用\n第一种\n方式来进行用户的更新操作,因为此方法只会更新你提交的用户信息（比如只会向服务器提交当前用户的email值），而不会将本地存储的用户信息也提交到后台更新。\n\n\n2、在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。\n\n\n3、需要先登录后才能更新用户信息 否则会返回206 User cannot be altered without sessionToken Error错误。\n\n\n查询用户\n\n\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：\n\n\nBmobQuery\nBmobUser\n query = new BmobQuery\nBmobUser\n();\nquery.addWhereEqualTo(\nusername\n, \nlucky\n);\nquery.findObjects(new FindListener\nBmobUser\n() {\n    @Override\n    public void done(List\nBmobUser\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询用户成功:\n+object.size());\n        }else{\n            toast(\n更新用户信息失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n浏览器中查看用户表\n\n\nUser表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。\n\n\n\n\n退出登录\n\n\n退出登录非常简单，可以使用如下的代码：\n\n\nBmobUser.logOut();   //清除缓存用户对象\nBmobUser currentUser = BmobUser.getCurrentUser(); // 现在的currentUser是null了\n\n\n\n\n密码修改\n\n\n自\nV3.4.3\n版本开始，SDK为开发者提供了直接修改当前用户登录密码的方法，只需要传入旧密码和新密码，然后调用\nBmobUser\n提供的静态方法\nupdateCurrentUserPassword\n即可，以下是示例：\n\n\nBmobUser.updateCurrentUserPassword(\n旧密码\n, \n新密码\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n密码修改成功，可以用新密码进行登录啦\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n\n邮箱\n\n\n邮箱登录\n\n\n新增\n邮箱+密码\n登录方式,可以通过\nloginByAccount\n方法来操作：\n\n\nBmobUser.loginByAccount(account, password, new LogInListener\nMyUser\n() {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i(\nsmile\n,\n用户登陆成功\n);\n                }\n            }\n        });\n\n\n\n\n\n邮箱验证\n\n\n设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nemailVerified 字段有 3 种状态可以考虑：\n\n\n\n\ntrue : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。\n\n\nfalse : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。\n\n\nmissing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。\n\n\n\n\n请求验证Email\n\n\n发送给用户的邮箱验证邮件会在一周内失效，可以通过调用 \nrequestEmailVerify\n 来强制重新发送：\n\n\nfinal String email = \nxxx@qq.com\n;\nBmobUser.requestEmailVerify(email, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n请求验证邮件成功，请到\n + email + \n邮箱中进行激活。\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n邮箱重置密码\n\n\n开发者只需要求用户输入注册时的电子邮件地址即可：\n\n\nfinal String email = \nxxx@163.com\n;\nBmobUser.resetPasswordByEmail(email, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n重置密码请求成功，请到\n + email + \n邮箱进行密码重置操作\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n邮箱重置密码的流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置链接的电子邮件。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n手机号相关功能\n\n\n手机号码登录\n\n\n在手机号码被验证后，用户可以使用该手机号码进行登录操作。\n\n\n手机号码登录包括两种方式：\n手机号码＋密码\n、\n手机号码＋短信验证码\n。\n\n\n手机号码+密码\n\n\nBmobUser.loginByAccount(\n11位手机号码\n, \n用户密码\n, new LogInListener\nMyUser\n() {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i(\nsmile\n,\n用户登陆成功\n);\n        }\n    }\n});\n\n\n\n\n\n手机号码+短信验证码\n\n\n先请求登录的短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n,\n模板名称\n, new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于后续的查询本次短信发送状态\n        }\n    }\n});\n\n\n\n\n\n最后调用\nloginBySMSCode\n方法进行手机号码登录:\n\n\nBmobUser.loginBySMSCode(\n11位手机号码\n, code, new LogInListener\nMyUser\n() {\n\n        @Override\n        public void done(MyUser user, BmobException e) {\n            if(user!=null){\n                Log.i(\nsmile\n,\n用户登陆成功\n);\n            }\n        }\n    });\n}\n\n\n\n\n\n手机号码一键注册或登录\n\n\nBmob同样支持手机号码一键注册或登录，以下是一键登录的流程：\n\n\n1、请求登录操作的短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n,\n模板名称\n, new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n    });\n\n\n\n\n\n2、用户收到短信验证码之后，就可以调用\nsignOrLoginByMobilePhone\n方法来实现一键登录:\n\n\nBmobUser.signOrLoginByMobilePhone(\n11位手机号码\n, \n验证码\n, new LogInListener\nMyUser\n() {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i(\nsmile\n,\n用户登陆成功\n);\n        }\n    }\n});\n\n\n\n\n\n如果，你想在一键注册或登录的同时保存其他字段的数据的时，你可以使用\nsignOrLogin\n方法（此方法\nV3.4.3\n版本提供）。\n\n\n比如，你想在手机号码注册或登录的同时，设置用户名及登录密码等信息，那么具体示例如下：\n\n\n\nMyUser user = new MyUser();\nuser.setMobilePhoneNumber(\n11位手机号码\n);//设置手机号码（必填）\nuser.setUsername(xxx);                  //设置用户名，如果没有传用户名，则默认为手机号码\nuser.setPassword(xxx);                  //设置用户密码\nuser.setAge(18);                        //设置额外信息：此处为年龄\nuser.signOrLogin(\n验证码\n, new SaveListener\nMyUser\n() {\n\n    @Override\n    public void done(MyUser user,BmobException e) {\n        if(e==null){\n            toast(\n注册或登录成功\n);\n            Log.i(\nsmile\n, \n+user.getUsername()+\n-\n+user.getAge()+\n-\n+user.getObjectId());\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n\n    }\n\n});\n\n\n\n\n\n绑定手机号码\n\n\n如果已有用户系统，需要为用户绑定手机号，那么官方推荐的绑定流程如下：\n\n\n第一步、先发送短信验证码并验证验证码的有效性,即调用\nrequestSMSCode\n发送短信验证码，调用\nverifySmsCode\n来验证有效性。\n\n\n第二步、在验证成功之后更新当前用户的\nMobilePhoneNumber\n和\nMobilePhoneNumberVerified\n两个字段，具体绑定示例如下：\n\n\nUser user =new User();\nuser.setMobilePhoneNumber(phone);\nuser.setMobilePhoneNumberVerified(true);\nUser cur = BmobUser.getCurrentUser(User.class);\nuser.update(cur.getObjectId(),new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n手机号码绑定成功\n);\n        }else{\n            toast(\n失败:\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n手机号码重置密码\n\n\nBmob自\nV3.3.9\n版本开始引入了短信验证系统，如果用户已经验证过手机号码或者使用过手机号码注册或登录过，也可以通过手机号码来重置用户密码，以下是官方建议使用的重置流程：\n\n\n1、请求重置密码操作的短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n,\n模板名称\n, new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n    });\n\n\n\n\n\n2、用户收到重置密码的验证码之后，就可以调用\nresetPasswordBySMSCode\n方法来实现密码重置:\n\n\nBmobUser.resetPasswordBySMSCode(code,\n1234567\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){\n            Log.i(\nsmile\n, \n密码重置成功\n);\n        }else{\n            Log.i(\nsmile\n, \n重置失败：code =\n+ex.getErrorCode()+\n,msg = \n+ex.getLocalizedMessage());\n        }\n    }\n});\n\n\n\n\n\n重置成功以后，用户就可以使用新密码登陆了。\n\n\n注：\n\n\n1、请开发者按照官方推荐的操作流程来完成重置密码操作。也就是说，开发者在进行重置密码操作时，无需调用\nverifySmsCode\n接口去验证该验证码的有效性。\n\n\n2、验证码只能使用一次，一旦该验证码被使用就会失效，那么再拿失效的验证码去调用重置密码接口，一定会报\n207-验证码错误\n。因为重置密码接口已经包含验证码的有效性验证。\n\n\n手机号码验证\n\n\n请求发送短信验证码\n\n\nBmob自\nV3.3.9\n版本开始引入了短信验证系统，可通过\nrequestSMSCode\n方式请求发送短信验证码：\n\n\nBmobSMS.requestSMSCode(\n11位手机号码\n, \n模板名称\n,new QueryListener\nInteger\n() {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i(\nsmile\n, \n短信id：\n+smsId);//用于查询本次短信发送详情\n        }\n    }\n});\n\n\n\n\n\n短信默认模板：\n\n\n\n    您的验证码是`%smscode%`，有效期为`%ttl%`分钟。您正在使用`%appname%`的验证码。【比目科技】\n\n\n\n\n\n注：\n\n\n1、\n模板名称\n：模板名称需要开发者在应用的管理后台进行短信模板的添加工作，具体：\n短信服务\n-\n短信模板\n,之后点击创建即可。\n\n\n具体请看下图：\n\n\n\n\n2、只有审核通过之后的自定义短信模板才可以被使用，如果自定义的短信模板其状态显示\n审核中\n或者\n审核失败\n,再调用该方法则会以\n默认模板\n来发送验证码。\n\n\n3、开发者提交短信验证码模板时需注意以下几点：\n\n\n1）、模板中不能有【】和 [] ，否则审核不通过；\n\n\n2）、如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载  \n短信关键字监控参考文档\n  来查看提交内容是否合法。\n\n\n3）、一天一个应用给同一手机号发送的短信不能超过10条，否则会报\n10010\n错误，其他错误码可查看  \n短信功能相关错误码\n 。\n\n\n验证验证码\n\n\n通过\nverifySmsCode\n方式可验证该短信验证码：\n\n\nBmobSMS.verifySmsCode(\n11位手机号码\n, \n验证码\n, new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){//短信验证码已验证成功\n            Log.i(\nsmile\n, \n验证通过\n);\n        }else{\n            Log.i(\nsmile\n, \n验证失败：code =\n+ex.getErrorCode()+\n,msg = \n+ex.getLocalizedMessage());\n        }\n    }\n});\n\n\n\n\n\n验证成功后，用户的\nmobilePhoneVerified\n属性会自动变为\ntrue\n。\n\n\n查询短信发送状态\n\n\n通过\nquerySmsState\n方式可查询指定\nsmsId\n的发送状态：\n\n\n\nBmobSMS.querySmsState(smsId, new QueryListener\nBmobSmsState\n() {\n\n            @Override\n            public void done(SmsState state, BmobException ex) {\n                if(ex==null){\n                    Log.i(\nsmile\n,\n短信状态：\n+state.getSmsState()+\n,验证状态：\n+state.getVerifyState());\n                }\n            }\n        });\n\n\n\n\n\n注：\nSmsState\n包含两种状态：\n\n\n1、\nsmsState\n（短信状态）   :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。\n\n\n2、\nverifyState\n（验证状态）:true(已验证)、false(未验证)。\n\n\n注意事项：\n\n\n关于短信条数的计算规则如下:\n\n\n\n\n实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。\n\n\n实际计算的短信字数在70个字以下算1条。\n\n\n实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。\n\n\n计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。\n\n\n\n\n短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。\n\n\n短信验证案例\n\n\n为了方便大家，官方提供了一个短信验证的demo：\nhttps://github.com/bmob/bmob_android_demo_sms\n 。\n\n\n此案例包含了：\n用户名/邮箱/手机号码+密码登录\n、\n手机号码一键注册登录\n、\n绑定手机号\n以及\n通过手机号重置用户密码\n。\n\n\n第三方账号登陆\n\n\nBmob提供了非常简单的方法来实现第三方账号登陆的功能，目前支持\n新浪微博\n、\nQQ账号\n、\n微信账号\n的登陆。\n\n\n自\nBmobV3.3.9\n版本开始，为了与第三方开放平台的SDK解藕，Bmob使用了全新的第三方账号登录方式，之前的微博和qq登录方式的API已删除。\n\n\n应用场景\n\n\n第三方账号登陆目前适应以下两种应用场景：\n\n\n一、没有Bmob账号，希望使用第三方账号一键注册或登陆Bmob账号\n\n\n如果开发者希望用户使用第三方平台的账号注册或登录Bmob的用户体系，则推荐的步骤如下：\n\n\n1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息\n\n\n2、调用Bmob提供的\nloginWithAuthData（BmobV3.3.9版本提供）\n方法，并自行构造\nBmobThirdUserAuth（第三方授权信息）\n对象，调用成功后，在Bmob的User表中会产生一条记录。\n\n\n二、已有Bmob账号，希望与第三方账号进行关联\n\n\n如果已使用Bmob的用户体系（假设用户A已登录），希望和第三方平台进行关联，则推荐的步骤如下：\n\n\n1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息\n\n\n2、调用\nassociateWithAuthData\n方法，并自行构造\nBmobThirdUserAuth(第三方授权信息)\n对象，调用成功后，你就会在后台的用户A的authData这个字段下面看到提交的授权信息。\n\n\n相关文档\n\n\n为了方便开发者完成授权，现整理各个平台的需要查阅的文档：\n\n\n微博登陆相关文档\n\n\n1、\n移动客户端接入文档\n：此文档请着重查阅其中的\nSDK接入流程\n。\n\n\n2、\n新浪微博AndroidSDK快速入门\n，请详细查看\nREADME\n文档,其介绍了完整的集成流程。\n\n\n3、\n新浪微博常见问题\n：在新浪微博授权过程中出现问题，请查看此文档，一般出现频率较高的错误有：\n\n\nsso package and sign error\n- 平台上填写的包名和签名不正确。请仔细检查，一般最需要检查的是\n签名\n，签名需要使用微博提供的获取签名的工具\n（app_signatures.apk）\n。\n\n\nredirect_uri_mismatch\n     - 请确保你在weibo平台上填写的授权回调地址与代码中写的授权回调地址(RedirectURI)一样。\n\n\nQQ登陆相关文档\n\n\n1、如何使用SDK，请参见 \n腾讯开放平台Android_SDK使用说明\n。\n\n\n2、如何调用具体API，请参见 \nAPI调用说明\n。\n\n\n3、常见问题汇总，请参见\n问题汇总说明\n。\n\n\n微信登陆相关文档\n\n\n1、\nAndroid接入指南\n：这里主要介绍的是微信sdk的集成步骤\n\n\n2、\n微信登陆开发指南\n：在\n移动应用开发\n-\n微信登录功能\n-\n移动应用微信登录开发指南\n。主要介绍微信OAuth2.0授权登录的流程。\n\n\n注：\n\n\n三者当中较麻烦的是微信登陆的授权，因此，在此简单说明下可能遇见的问题：\n\n\n1、在微信登陆过程中出现了问题，请仔细注意以下几点：\n\n\n1）、需要在微信开放平台上填写你的\n应用信息、包名和签名\n；\n2）、微信登陆不同于QQ或微博登陆，应用需要\n提交微信官方审核\n，只有审核通过后才能打开授权界面；\n3）、建议\n导出正式签名的apk来测试\n，不建议直接run debug版本的apk；\n4）、检查\n签名是否正确\n、检查\n传递的参数是否正确\n。\n\n\n2、微信登陆的测试相对比较麻烦，如果开发者希望直接能够进行调试，建议使用微信官方demo中的\ndebug keystore\n。具体使用步骤：\n\n\n1)、Eclipse中选择\nWindow-\nPreferences-\nAndroid-\nBuild\n;\n\n\n2)、在Build页有个\nCustom debug keystore\n选项,然后点击\nBrowse\n,选择微信官方demo中的\ndebug keystore\n文件即可。\n\n\n之后重新运行应用时会使用该\ndebug keystore\n文件对应用进行Debug签名。\n\n\n不要忘了在微信后台重新填写通过微信签名工具获得的该调试应用的签名\n。\n\n\n第三方账号一键注册或登录\n\n\n假设你已通过上述提供的文档完成相应平台的授权并得到对应的授权信息，则可以这样来完成一键注册或登陆操作：\n\n\n    BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn,userId);\n    BmobUser.loginWithAuthData(authInfo, new LogInListener\nJSONObject\n() {\n\n        @Override\n        public void done(JSONObject userAuth,BmobException e) {\n            ...\n        }\n    });         \n\n\n\n\n\n注：\n\n\nBmobThirdUserAuth\n的各参数解释：\n\n\n1、\nsnsType\n:只能是三种取值中的一种：\nweibo、qq、weixin\n\n\n2、\naccessToken\n：接口调用凭证\n\n\n3、\nexpiresIn\n：access_token的有效时间\n\n\n4、\nuserId\n:用户身份的唯一标识，对应微博授权信息中的\nuid\n,对应qq和微信授权信息中的\nopenid\n\n\n关联第三方账号\n\n\n账号关联\n\n\n    BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn, userId);\n    BmobUser.associateWithAuthData(authInfo, new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i(\nbmob\n,\n关联成功\n);\n            }else{\n                Log.i(\nbmob\n,\n关联失败：code =\n + e.getErrorCode() + \n,msg = \n + e.getMessage());\n            }\n\n        }\n    });\n\n\n\n\n\n解除关联\n\n\n    BmobUser.dissociateAuthData(snsType,new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i(\nbmob\n,\n取消\n+snsType+\n关联成功\n);\n            }else{\n                int code =e.getErrorCode(); \n                if (code == 208) {// 208错误指的是没有绑定相应账户的授权信息\n                    Log.i(\nsmile\n,\n你没有关联该账号\n);\n                } else {\n                    Log.i(\nsmile\n,\n取消\n+snsType+\n关联失败：code =\n + code + \n,msg = \n + e.getMessage());\n                }\n            }\n        }\n});\n\n\n\n\n\n第三方登录的案例源码\n\n\n具体案例可参考我们Github上的demo：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n ,这个源码包含了第三方登录的源码和登录之后如何获取用户基本信息的部分。\n\n\n文件管理\n\n\nBmobFile\n可以让你的应用程序将文件存储到服务器中，常见的文件类型都可以实现存储：比如图像文件、影像文件、音乐文件和任何其他二进制数据。\n\n\n注：\n\n\n1、以下均为SDK对文件进行操作的方法，如果你想在Web端对文件进行操作，请查看我们的帮助文档：\n如何在Web后台上传文件\n\n\n2、自 \nBmobSDKv3.4.6\n 开始，文件服务需要注意以下几个方面：\n\n\n\n\n\n\nSDK内部集成CDN文件服务，删除\nBmobProFile\n的相关代码，并不再提供新旧文件管理的功能，但上传的方法名不变\n；\n\n\n\n\n\n\n新增了文件下载\n(download)\n和批量删除CDN文件\n(deleteBatch)\n的方法\n；\n\n\n\n\n\n\n2016年7月,旧版SDK中的新旧文件管理的上传方法将停止服务，之前通过旧版SDK中的新旧文件管理上传的文件仍可下载，请大家及时更新SDK\n；\n\n\n\n\n\n\n之前使用了\nBmobProFile中\n的\nupload\n方法上传的文件，开发者可以直接在文件的url地址后面增加：\"?t=2\na=\"+ 你的accessKey，那么拼接后的文件是可以直接用来访问并下载的。\n；\n\n\n\n\n\n\n    举个例子：\n\n    如果之前通过新版文件管理的上传方法得到的文件url地址：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png，\n\n    那么签名后的可访问的文件地址为：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png?t=2\na=你的accessKey。\n\n\n\n\n\n\n无法查看accessKey\n。因为已经废除新旧文件管理功能，所以在开发者管理后台的设置--\n应用密钥中已无法查看accessKey，而之前开发者所使用的accessKey继续有效。\n\n\n\n\n3、CDN文件服务需要\nokhttp-2.4.0、okio-1.4.0\n及\nWAKE_LOCK\n权限，请导入okhttp相关jar包并在\nAndroidManifest.xml\n类的\nmanifest\n标签下添加如下权限，否则会造成调用上传/下载文件的方法无反应。\n\n\n    \n!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --\n\n    \nuses-permission android:name=\nandroid.permission.WAKE_LOCK\n /\n\n\n\n\n\n创建文件对象\n\n\n创建文件对象方式如下：\n\n\nString picPath = \nsdcard/temp.jpg\n;\nBmobFile bmobFile = new BmobFile(new File(picPath));\n\n\n\n\n上传单一文件\n\n\n文件分片上传的方法非常简单，示例代码如下：\n\n\nString picPath = \nsdcard/temp.jpg\n;\nBmobFile bmobFile = new BmobFile(new File(picPath));\nbmobFile.uploadblock(new UploadFileListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            //bmobFile.getFileUrl()--返回的上传文件的完整地址\n            toast(\n上传文件成功:\n + bmobFile.getFileUrl());\n        }else{\n            toast(\n上传文件失败：\n + e.getMessage());\n        }\n\n    }\n\n    @Override\n    public void onProgress(Integer value) {\n        // 返回的上传进度（百分比）\n    }\n});\n\n\n\n\n设置文件分片上传时每片大小\n\n\n自\nBmobSDKv3.4.6\n开始,新增\nBmobConfig\n类，允许开发者设置\n查询超时时间\n及\n文件分片上传时的每片大小\n。建议在\nApplication\n类的\nonCreate\n方法中调用。\n\n\n示例代码如下:\n\n\n\npublic class BmobApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //设置BmobConfig\n        BmobConfig config =new BmobConfig.Builder()\n        //请求超时时间（单位为秒）：默认15s\n        .setConnectTimeout(30)\n        //文件分片上传时每片的大小（单位字节），默认512*1024\n        .setBlockSize(500*1024)\n        .build();\n        Bmob.getInstance().initConfig(config);\n    }\n}\n\n\n\n\n\n批量上传文件\n\n\n自\nBmobSDKv3.2.7\n开始,新增批量上传文件的方法；\n\n\n自\nBmobSDKv3.4.6\n开始,文件批量上传的静态方法由\nBmob\n转移至\nBmobFile\n类,建议调用\nBmobFile.uploadBatch\n方法。\n\n\n示例代码如下：\n\n\n//详细示例可查看BmobExample工程中BmobFileActivity类\nString filePath_mp3 = \n/mnt/sdcard/testbmob/test1.png\n;\nString filePath_lrc = \n/mnt/sdcard/testbmob/test2.png\n;\nfinal String[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmobFile.uploadBatch(filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List\nBmobFile\n files,List\nString\n urls) {\n        //1、files-上传完成后的BmobFile集合，是为了方便大家对其上传后的数据进行操作，例如你可以将该文件保存到表中\n        //2、urls-上传文件的完整url地址\n        if(urls.size()==filePaths.length){//如果数量相等，则代表文件全部上传完成\n            //do something\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        ShowToast(\n错误码\n+statuscode +\n,错误描述：\n+errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,int totalPercent) {\n        //1、curIndex--表示当前第几个文件正在上传\n        //2、curPercent--表示当前上传文件的进度值（百分比）\n        //3、total--表示总的上传文件数\n        //4、totalPercent--表示总的上传进度（百分比）\n    }\n});\n\n\n\n\n注：\n\n\n1、有多少个文件上传，onSuccess方法就会执行多少次;\n\n\n2、通过onSuccess回调方法中的files或urls集合的大小与上传的总文件个数比较，如果一样，则表示全部文件上传成功。\n\n\n下载文件\n\n\n自\nBmobSDKv3.4.6\n版本,SDK提供了文件的下载方法\ndownload\n，并且允许开发者设置下载文件的存储路径。\n\n\n注：下载方法并不局限于下载通过BmobSDK上传的文件，也就是说只要提供一个文件url地址，也可以调用下载方法的。\n\n\n下载文件的步骤：\n\n\n1、先获取BmobFile对象实例，可以是查询数据时返回的BmobFile，也可以自行构建BmobFile对象：\n\n\n\n\n通过查询数据时返回的BmobFile，示例代码如下：\n\n\n\n\n\nbmobQuery.findObjects(new FindListener\nGameScore\n() {\n    @Override\n    public void done(List\nGameScore\n object,BmobException e) {\n        if(e==null){\n            for (GameScore gameScore : object) {\n                BmobFile bmobfile = gameScore.getPic();\n               if(file!= null){\n                    //调用bmobfile.download方法\n               }\n            }\n        }else{\n            toast(\n查询失败：\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n\n\n通过如下构造方法构造BmobFile对象：\n\n\n\n\n需求：如果你想下载一个远程图片地址，那么就需要使用下面的构造方法构造一个BmobFile对象（其中group可为空）\n\n\n/**  \n * @param fileName 文件名(必填)\n * @param group 组名（选填）\n * @param url  完整url地址（必填）\n * 注：必须要有文件名和文件的完整url地址，group可为空\n */\npublic BmobFile(String fileName,String group,String url){\n    this.filename = fileName;\n    this.group=group;\n    this.url = url;\n}\n\n\n\n\n\n示例代码如下：\n\n\n\nBmobFile bmobfile =new BmobFile(\nxxx.png\n,\n,\nhttp://bmob-cdn-2.b0.upaiyun.com/2016/04/12/58eeed852a7542cb964600c6cc0cd2d6.png\n)；\n\n\n\n\n\n2、然后调用\nbmobfile.download\n方法下载文件:\n\n\n有两种下载方法：\n\n\n\n\n\n\ndownload(DownloadFileListener listener)\n：此方法会将文件下载到当前应用的默认缓存目录中，以getFilename()得到的值为文件名\n\n\n\n\n\n\ndownload(File savePath, DownloadFileListener listener)\n：此方法允许开发者指定文件存储目录和文件名\n\n\n\n\n\n\n示例代码如下：\n\n\nprivate void downloadFile(BmobFile file){\n    //允许设置下载文件的存储路径，默认下载文件的目录为：context.getApplicationContext().getCacheDir()+\n/bmob/\n\n    File saveFile = new File(Environment.getExternalStorageDirectory(), file.getFilename());\n    file.download(saveFile, new DownloadFileListener() {\n\n        @Override\n        public void onStart() {\n            toast(\n开始下载...\n);\n        }\n\n        @Override\n        public void done(String savePath,BmobException e) {\n            if(e==null){\n                toast(\n下载成功,保存路径:\n+savePath);\n            }else{\n                toast(\n下载失败：\n+e.getErrorCode()+\n,\n+e.getMessage());\n            }\n        }\n\n        @Override\n        public void onProgress(Integer value, long newworkSpeed) {\n            Log.i(\nbmob\n,\n下载进度：\n+value+\n,\n+newworkSpeed);\n        }\n\n    });\n}\n\n\n\n\n\n\n删除文件\n\n\nBmobSDKv3.4.6\n中删除文件的接口，\n只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件\n。不兼容之前的新旧文件管理，但使用方法不变。\n\n\n示例代码如下：\n\n\nBmobFile file = new BmobFile();\nfile.setUrl(url);//此url是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nfile.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast(\n文件删除成功\n);\n        }else{\n            toast(\n文件删除失败：\n+e.getErrorCode()+\n,\n+e.getMessage());\n        }\n    }\n});\n\n\n\n\n\n批量删除文件\n\n\n自 \nBmobSDKv3.4.6\n 版本，SDK提供了文件的批量删除接口\ndeleteBatch，且只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件\n。\n\n\n示例代码如下：\n\n\n//此url必须是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nString[] urls =new String[]{url};\nBmobFile.deleteBatch(urls, new DeleteBatchListener() {\n\n    @Override\n    public void done(String[] failUrls, BmobException e) {\n        if(e==null){\n            toast(\n全部删除成功\n);\n        }else{\n            if(failUrls!=null){\n                toast(\n删除失败个数：\n+failUrls.length+\n,\n+e.toString());\n            }else{\n                toast(\n全部文件删除失败：\n+e.getErrorCode()+\n,\n+e.toString());\n            }\n        }\n    }\n});\n\n\n\n\n\n为方便大家理解文件服务的使用，Bmob提供了一个文件上传的案例和源码，大家可以到\n示例和教程中查看和下载\n。\n\n\n缩略图\n\n\n自 \nBmobSDKv3.4.6\n 版本，新版文件服务由第三方厂商又拍云提供，只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果，\n如图\n，具体可参考\n这里\n 。\n\n\n注：\n\n\n1、文件的批量上传是BmobSDK_v3.2.7版本才提供的功能，如需使用，请更新版本;\n\n\n2、文件的下载和批量删除是BmobSDK_v3.4.6才提供的功能，如需使用，请更新版本。\n\n\n数据实时同步\n\n\n数据实时同步是一个超酷的功能！\n\n\nSDK可以实现对数据表或行的监听，当这个表或者行的数据发生变化时，Bmob会立即将变化的信息告知SDK。\n这种服务非常适合做游戏开发（如，开发斗地主游戏，三个人同时监听一行数据的变化，任何一个人出牌都会将数据写入到这行数据中，其他人也就立即知道了）、群聊（一群人监听某个表的变化，任何人发言都会将数据写入到这个表中，其他人也可以立即知道了）等实时性要求很高的场景中。\n\n\n为方便大家快速了解数据的实时同步服务，我们提供了一个简单的应用实例（ \nhttps://github.com/bmob/bmob-android-demo-realtime-data\n ）供大家参考。\n\n\n开始连接\n\n\n使用数据实时功能，首先需要创建\nBmobRealTimeData\n对象,然后调用\nstart\n方法连接服务器。\n\n\nBmobRealTimeData rtd = new BmobRealTimeData();\nrtd.start(new ValueEventListener() {\n    @Override\n    public void onDataChange(JSONObject data) {\n        Log.d(\nbmob\n, \n(\n+data.optString(\naction\n)+\n)\n+\n数据：\n+data);\n    }\n\n    @Override\n    public void onConnectCompleted(Exception ex) {\n        Log.d(\nbmob\n, \n连接成功:\n+rtd.isConnected());\n    }\n});\n\n\n\n\nstart\n方法中的\nValueEventListener\n参数用于监听连接成功和数据变化的回调。当有数据变化时会通过onDataChange回调方法反馈到客户端。开发者只需要处理得到的data就可以了。\n\n\n注：\n\n\n1、监听器不支持UI线程，在监听回调中请不要直接操作UI；\n\n\n2、如果你要监听User、Installation等系统表的话，表名前需要加上“_”，例如：_User\n\n\n监听数据\n\n\n在BmobRealTimeData对象连接成功后，就可以进行数据的监听了。BmobSDK提供了监听表和行的方法如下：\n\n\n// 监听表更新\nrtd.subTableUpdate(tableName);\n// 监听表删除\nrtd.subTableDelete(tableName);\n// 监听行更新\nrtd.subRowUpdate(tableName, objectId);\n// 监听行删除\nrtd.subRowDelete(tableName, objectId);\n\n\n\n\n其中\ntableName\n为要监听的数据表名，\nobjectId\n为要监听的数据行Id,\n通常比较保险的做法是在\nBmobRealTimeData\n对象的连接状态为\ntrue\n的情况下进行监听，代码如下：\n\n\nif(rtd.isConnected()){\n    // 监听表更新\n    rtd.subTableUpdate(tableName);\n}\n\n\n\n\n取消监听\n\n\n当开发者想取消监听某个行为是，可使用下面的方法：\n\n\n// 取消监听表更新\nrtd.unsubTableUpdate(testTableName);\n// 取消监听表删除\nrtd.unsubTableDelete(testTableName);\n// 取消监听行更新\nrtd.unsubRowUpdate(testTableName, objectId);\n// 取消监听行删除\nrtd.unsubRowDelete(testTableName, objectId);\n\n\n\n\nACL和角色\n\n\n数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看\nBmob数据与安全页面\n，了解Bmob如何保护数据安全）。\n\n\n其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n\n\n\n\n默认访问权限\n\n\n在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：\n\n\nBmobACL aCL = new BmobACL();\n\naCL.setPublicReadAccess(true);\n\naCL.setPublicWriteAccess(true);\n\n\n\n\n注意：可读可写是默认的权限，不需要写额外的代码。\n\n\n指定用户的访问权限\n\n\n假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：\n\n\nBlog blog = new Blog();\nblog.setTitle(\n论电影的七个元素\n);\nblog.setContent(\n这是blog的具体内容\n);\n\nBmobACL acl = new BmobACL();    //创建一个ACL对象\nacl.setPublicReadAccess(true);  // 设置所有人可读的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(this), true);   // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n\n});\n\n\n\n\n有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：\n\n\nBlog blog = new Blog();\nblog.setTitle(\n一个人的秘密\n);\nblog.setContent(\n这是blog的具体内容\n);\n\nBmobACL acl = new BmobACL();  //创建ACL对象\nacl.setReadAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});\n\n\n\n\n角色管理\n\n\n上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：\n\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.setReadAccess(boos, true);    \nacl.setReadAccess(hr_zhang, true);\nacl.setReadAccess(cashier_xie, true);\nacl.setReadAccess(me, true);\n\n//设置老板和人事小张对这个工资的写权限\nacl.setWriteAccess(boss, true);\nacl.setWriteAccess(hr_zhang, true);\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save(new SaveListener\nString\n() {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});\n\n\n\n\n但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：\n\n\n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);\n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser hr_luo;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole(\nHR\n);\nBmobRole cashier = new BmobRole(\nCashier\n);\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this);  \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save();\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\nacl.setRoleReadAccess(hr, true); // 给hr角色设置读权限\nacl.setRoleReadAccess(cashier, true); // 给cashier角色设置读权限\n\nacl.setWriteAccess(boss, true); // 设置老板拥有写权限\nacl.setRoleWriteAccess(hr, true); // 设置ht角色拥有写权限\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save();\n\n\n\n\n需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。\n\n\n角色之间的从属关系\n\n\n下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。\n\n\n//创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole mobileDep = new BmobRole(\nMobileDep\n);\nBmobRole androidTeam = new BmobRole(\nAndroidTeam\n);\nBmobRole iosTeam = new BmobRole(\niOSTeam\n);\n\n//保存AndroidTeam和iosTeam角色到云端\nandroidTeam.save();\niosTeam.save();\n\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nmobileDep.getRoles().add(androidTeam);\nmobileDep.getRoles().add(iosTeam);\nmobileDep.save();\n\n// 假设创建三个代码数据对象\nCode coreCode = new Code();\nCode androidCode = new Code();\nCode iosCode = new Code();\n\n//......此处省略一些具体的属性设定\n\ncoreCode.save();\nandroidCode.save();\niosCode.save();\n\n//设置androidTeam角色对androidCode对象的读和写的权限\nandroidCode.setRoleReadAccess(androidTeam, true);\nandroidCode.setRoleWriteAccess(androidTeam, true);\n\n//设置iosTeam角色对iosCode对象的读和写的权限\niosCode.setRoleReadAccess(iosTeam, true);\niosCode.setRoleWriteAccess(iosTeam, true);\n\n//设置mobileDep角色可以对coreCode对象进行读操作\ncoreCode.setRoleReadAccess(mobileDep);\n\n\n\n\n\nACL案例源码\n\n\n我们为大家提供一个ACL相关的案例源码，大家可以点击下载：\nhttps://github.com/bmob/bmob-android-demo-acl\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。通过在BmobObject的查询中添加一个BmobGeoPoint的对象查询，你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n为了方便大家查看文档，这里创建一个Person类：\n\n\npublic class Person extends BmobObject{\n    private BmobGeoPoint gpsAdd;\n\n    public BmobGeoPoint getGpsAdd() {\n        return gpsAdd;\n    }\n    public void setGpsAdd(BmobGeoPoint gpsAdd) {\n        this.gpsAdd = gpsAdd;\n    }\n}\n\n\n\n\n\n创建地理位置对象\n\n\n首先需要创建一个BmobGeoPoint对象。例如，创建一个东经116.39727786183357度，北纬39.913768382429105度的BmobGeoPoint对象：\n\n\nBmobGeoPoint point = new BmobGeoPoint(116.39727786183357, 39.913768382429105);\n\n\n\n\n查询地理位置信息\n\n\n现在，你可以测试找出最接近某个点的信息了（\n数据表要有一定的地理坐标对象的数据，GeoPoint字段类型\n）。查询使用BmobQuery对象的\naddWhereNear\n方法进行操作：\n\n\nBmobQuery\nPerson\n bmobQuery = new BmobQuery\nPerson\n();\nbmobQuery.addWhereNear(\ngpsAdd\n, new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.setLimit(10);    //获取最接近用户地点的10条数据\nbmobQuery.findObjects(new FindListener\nPerson\n() {\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n + object.size() + \n条数据。\n);\n        }else{\n            toast(\n查询失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n要限制查询指定距离范围的数据可以使用\naddWhereWithinKilometers\n、\naddWhereWithinMiles\n或\naddWhereWithinRadians\n方法。\n\n\n要查询一个矩形范围内的信息可以使用\naddWhereWithinGeoBox\n来实现：\n\n\nBmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery\nPerson\n query = new BmobQuery\nPerson\n();\nquery.addWhereWithinGeoBox(\ngpsAdd\n, southwestOfSF, northeastOfSF);\nquery.findObjects(new FindListener\nPerson\n() {\n\n    @Override\n    public void done(List\nPerson\n object,BmobException e) {\n        if(e==null){\n            toast(\n查询成功：共\n + object.size() + \n条数据。\n);\n        }else{\n            toast(\n查询失败：\n + e.getMessage());\n        }\n    }\n});\n\n\n\n\n注意事项\n\n\n\n\n\n\n每个BmobObject数据对象中\n只能\n有一个BmobGeoPoint对象\n。\n\n\n\n\n\n\n地理位置的点不能超过规定的范围。\n纬度的范围\n应该是在\n-90.0到90.0\n之间。\n经度的范围\n应该是在\n-180.0到180.0\n之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n\n\n\n\n应用安全\n\n\n请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档：\nhttp://docs.bmob.cn/other/Other/n_datasafety/doc/index.html\n\n\n开源案例\n\n\n为方便大家更好的理解Bmob SDK，我们特意为大家提供了一些源码，大家可以下载之后，\n嵌入Bmob的Application Id\n，就可以打包运行了。\n\n\n阅读源码是一种良好的习惯！！\n\n\n\n\n\n\n即时聊天案例源码：\nhttps://github.com/bmob/BmobIMSDK4Android\n\n\n\n\n\n\n图文社区案例源码：\nhttps://git.oschina.net/v7/Wonderful\n  这个案例是猿圈媛圈开发团队提供的。\n\n\n\n\n\n\n校园小菜案例源码：\nhttps://github.com/bmob/Shop\n 这个案例是湖工大的朋友提供的。\n\n\n\n\n\n\n社交分享案例源码：\nhttps://github.com/bmob/bmob-android-social-share\n 这个是金刚锁开发者提供的\n\n\n\n\n\n\n第三方登录案例源码：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n  包含第三方登录和登录后获取用户信息的源码\n\n\n\n\n\n\n其他功能\n\n\n获取服务器时间\n\n\n在Bmob对象中提供了一个静态方法，用于获取服务器时间。\n\n\nBmob.getServerTime(new QueryListener\nLong\n() {\n\n    @Override\n    public void done(long time,BmobException e) {\n        if(e==null){\n            SimpleDateFormat formatter = new SimpleDateFormat(\nyyyy-MM-dd HH:mm\n);\n            String times = formatter.format(new Date(time * 1000L));\n            Log.i(\nbmob\n,\n当前服务器时间为:\n + times);\n        }else{\n            Log.i(\nbmob\n,\n获取服务器时间失败:\n + e.getMessage());\n        }\n    }\n\n});\n\n\n\n\n自动更新组件\n\n\nBmob为大家提供了应用的自动更新组件，使用这个组件可以快速方便实现应用的自动升级功能。\n详细的使用操作可以参考文档：\n自动更新组件文档\n\n\n表结构\n\n\n自\nV3.4.2\n版本开始，SDK提供了\n获取表结构信息\n方法,具体示例如下：\n\n\n获取特定表的结构\n\n\nBmob.getTableSchema(\n待查询的表名\n, new QueryListener\nBmobTableSchema\n() {\n\n    @Override\n    public void done(BmobTableSchema schema, BmobException ex) {\n        if(ex==null){\n            Log.i(\nbmob\n, \n获取指定表的表结构信息成功：\n+schema.getClassName()+\n-\n+schema.getFields().toString());\n        }else{\n            Log.i(\nbmob\n, \n获取指定表的表结构信息失败:\n + ex.getLocalizedMessage()+\n(\n+ex.getErrorCode()+\n)\n);\n        }\n    }\n});\n\n\n\n\n\n获取所有表的结构\n\n\n\nBmob.getAllTableSchema(context, new QueryListListener\nBmobTableSchema\n() {\n\n    @Override\n    public void done(List\nBmobTableSchema\n schemas, BmobException ex) {\n        if(ex==null \n schemas!=null \n schemas.size()\n0){\n            Log.i(\nbmob\n, \n获取所有表结构信息成功\n);\n        }else{\n            Log.i(\nbmob\n,\n获取所有表结构信息失败：\n+ex.getLocalizedMessage()+\n(\n+ex.getErrorCode()+\n)\n);\n        }\n    }\n});\n\n\n\n\n\n返回数据说明\n\n\n注：\nBmobTableSchema\n参数说明：\n\n\n其中\n\n\nclassName\n：表示表名\n\n\nfields\n   ： 是Map\n类型，里面包含了对应表的所有列的属性，\n\n\n其fields内部结构如下：\n\n\n\n\n{\"列1\":Map,\"列2\":Map, ...}\n\n\n\n\n而Map的结构为：\n\n\n\n\n{\"type\":\"typeName\",\"targetClass\":\"tableName\"}\n\n\n\n\n其中 \ntype\n 指的是该列的类型， 而 \ntargetClass\n 指的是指向的表名，只有在 type 为 Pointer 或者 Relation 时才有值。\n\n\n具体json格式如下,仅供参考：\n\n\n {\n    className: \nPost\n, \n    fields: {\n      ACL: {\n        type: \nObject\n\n      }, \n      author: {\n        targetClass: \n_User\n, \n        type: \nPointer\n\n      }, \n      content: {\n        type: \nString\n\n      }, \n      createdAt: {\n        type: \nDate\n\n      }, \n      objectId: {\n        type: \nString\n\n      }, \n      updatedAt: {\n        type: \nDate\n\n      }\n    }\n }\n\n\n\n\n\n错误码列表\n\n\nAndroid SDK的错误码都是以\n9\n开头的，其他错误码请点击查看：\nRestAPI错误码列表\n。\n\n\n9001\n\n\n内容：AppKey is Null, Please initialize BmobSDK.\n\n\n含义：Application Id为空，请初始化。\n\n\n9002\n\n\n内容：Parse data error\n\n\n含义：解析返回数据出错\n\n\n9003\n\n\n内容：upload file error\n\n\n含义：上传文件出错\n\n\n9004\n\n\n内容：upload file failure\n\n\n含义：文件上传失败\n\n\n9005\n\n\n内容：A batch operation can not be more than 50\n\n\n含义：批量操作只支持最多50条\n\n\n9006\n\n\n内容：objectId is null\n\n\n含义：objectId为空\n\n\n9007\n\n\n内容：BmobFile File size must be less than 10M.\n\n\n含义：文件大小超过10M\n\n\n9008\n\n\n内容：BmobFile File does not exist.\n\n\n含义：上传文件不存在\n\n\n9009\n\n\n内容：No cache data.\n\n\n含义：没有缓存数据\n\n\n9010\n\n\n内容：The network is not normal.(Time out)\n\n\n含义：网络超时\n\n\n9011\n\n\n内容：BmobUser does not support batch operations.\n\n\n含义：BmobUser类不支持批量操作\n\n\n9012\n\n\n内容：context is null.\n\n\n含义：上下文为空\n\n\n9013\n\n\n内容： BmobObject Object names(database table name) format is not correct.\n\n\n含义：BmobObject（数据表名称）格式不正确\n\n\n9014\n\n\n含义：第三方账号授权失败\n\n\n9015\n\n\n含义：其他错误均返回此code\n\n\n9016\n\n\n内容：The network is not available,please check your network!\n\n\n含义：无网络连接，请检查您的手机网络。\n\n\n9017\n\n\n含义：与第三方登录有关的错误，具体请看对应的错误描述\n\n\n9018\n\n\n含义：参数不能为空\n\n\n9019\n\n\n含义：格式不正确：手机号码、邮箱地址、验证码\n\n\n混淆打包\n\n\n使用了BmobSDK的应用在混淆过程中，需注意以下几点：\n\n\n1、\n不要混淆BmobSDK的代码\n，Bmob Android SDK本身进行了代码混淆；\n\n\n2、任何继承自\nBmobObject、BmobUser\n的JavaBean及\n在上述JavaBean中定义的Object属性类\n都不要混淆，否则gson将无法将数据解析成具体对象；\n\n\n3、确保\nrx\n、\nokhttp3 okio\n、\ngson\n及\norg.apache.http.legacy.jar\n包均不要混淆。\n\n\n具体可参考BmobExample中proguard-project.txt的代码：\n\n\n\n-ignorewarnings\n\n-keepattributes Signature,*Annotation*\n\n# keep BmobSDK\n-dontwarn cn.bmob.v3.**\n-keep class cn.bmob.v3.** {*;}\n\n# 确保JavaBean不被混淆-否则gson将无法将数据解析成具体对象\n-keep class * extends cn.bmob.v3.BmobObject {\n    *;\n}\n-keep class com.example.bmobexample.bean.BankCard{*;}\n-keep class com.example.bmobexample.bean.GameScore{*;}\n-keep class com.example.bmobexample.bean.MyUser{*;}\n-keep class com.example.bmobexample.bean.Person{*;}\n-keep class com.example.bmobexample.file.Movie{*;}\n-keep class com.example.bmobexample.file.Song{*;}\n-keep class com.example.bmobexample.relation.Post{*;}\n-keep class com.example.bmobexample.relation.Comment{*;}\n\n# keep BmobPush\n-dontwarn  cn.bmob.push.**\n-keep class cn.bmob.push.** {*;}\n\n# keep okhttp3、okio\n-dontwarn okhttp3.**\n-keep class okhttp3.** { *;}\n-keep interface okhttp3.** { *; }\n-dontwarn okio.**\n\n# keep rx\n-dontwarn sun.misc.**\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n long producerIndex;\n long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode producerNode;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode consumerNode;\n}\n\n# 如果你需要兼容6.0系统，请不要混淆org.apache.http.legacy.jar \n-dontwarn android.net.compatibility.**\n-dontwarn android.net.http.**\n-dontwarn com.android.internal.http.multipart.**\n-dontwarn org.apache.commons.**\n-dontwarn org.apache.http.**\n-keep class android.net.compatibility.**{*;}\n-keep class android.net.http.**{*;}\n-keep class com.android.internal.http.multipart.**{*;}\n-keep class org.apache.commons.**{*;}\n-keep class org.apache.http.**{*;}", 
            "title": "开发文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_2", 
            "text": "建议您在阅读本开发文档之前，先阅读我们提供的  Android快速入门文档 ，便于您后续的开发。 \n如果开发者想使用不同历史版本的SDK，可以移步 历史版本的github仓库 ，选择使用各个历史版本。", 
            "title": "快速入门"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_3", 
            "text": "在使用SDK过程中，如果一些Api如查询是高频代码，可以把一些重复的样板代码抽出来，并在AndroidStudio中设置模板，即可实现快速输入，能提高编码效率，效果如下：", 
            "title": "模板代码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_4", 
            "text": "从v3.5.5开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：      Bmob.resetDomain(\"http://demo.bmob.cn/\");  其中，参数为开发者的域名，调用后的所有请求都指向新的域名。", 
            "title": "数据迁移"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#sdk", 
            "text": "从v3.5.2开始，把统计SDK集成到了数据服务SDK，上传应用不再需要额外集成统计SDK，低于此版本的可以去控制台的应用官网下载。", 
            "title": "统计SDK"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_5", 
            "text": "确保项目有 INTERNET 和 READ_PHONE_STATE 权限  uses-permission android:name=\"android.permission.INTERNET\" /  uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /     在初始化方法中传一个渠道参数(不传默认没开启统计功能)  Bmob.initialize(this,APPID,\"Bmob\");   将libs文件夹内的BmobStat.jar文件添加进项目（AS选择远程依赖可以忽略，本地依赖需要指定libs文件夹，Eclipse中放进libs即可）；", 
            "title": "添加方法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#android60", 
            "text": "自 v3.4.6 版本开始，Bmob提供了一些新的方法和工具类来帮助开发者为自己的应用兼容Android6.0系统。", 
            "title": "兼容Android6.0系统"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#apachehttp-client", 
            "text": "Android6.0版本移除了对Appache的HTTP client的支持，因此，需要添加 org.apache.http.legacy.jar 包，请参照如下方式添加：  1.Eclipse  你需要在Eclipse工程的项目根目录中新建libs文件夹，将org.apache.http.legacy.jar包，添加到libs文件夹中  2.AndroidStudio  你需要在 app 的 build.gradle 文件添加配置信息useLibrary 'org.apache.http.legacy'声明编译时依赖      android {\n        compileSdkVersion 23\n        buildToolsVersion \"23.0.2\"\n        useLibrary 'org.apache.http.legacy'\n    }  注：如果在build.gradle文件中 useLibrary 'org.apache.http.legacy' 这句话报错，可将该jar直接放到libs目录下即可。", 
            "title": "添加对Apache的HTTP-client支持"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_6", 
            "text": "Android6.0中对特定的权限进行了动态授权的方式，需要在运行时用户手动授予，如果用户拒绝后再次申请还可以向用户弹框说明权限的作用，用户点击确认后再去申请。  因此，我们提供了一个权限管理的工具类 PermissionManager(cn.bmob.v3.helper) ，具体使用如下：  注：在 v3.4.6 的BmobSDK内部集成 PermissionManager 类，自 v3.4.7 以后的SDK内部将不再提供该类，开发者可以在下载的配套官方Demo的 com.example.bmobexample.permission 包下面查看该类源码。  1.构建 PermissionManager 对象  PermissionManager helper;\nhelper = PermissionManager.with(MainActivity.this)\n        //添加权限请求码\n        .addRequestCode(MainActivity.REQUEST_CODE_CAMERA)\n        //设置权限，可以添加多个权限\n        .permissions(Manifest.permission.CAMERA)\n        //设置权限监听器\n        .setPermissionsListener(new PermissionListener() {\n\n            @Override\n            public void onGranted() {\n                //当权限被授予时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission granted\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onDenied() {\n                //用户拒绝该权限时调用\n               Toast.makeText(MainActivity.this, \"Camera Permission denied\",Toast.LENGTH_LONG).show();\n            }\n\n            @Override\n            public void onShowRationale(String[] permissions) {\n                //当用户拒绝某权限时并点击`不再提醒`的按钮时，下次应用再请求该权限时，需要给出合适的响应（比如,给个展示对话框来解释应用为什么需要该权限）\n                Snackbar.make(btn_camera, \"需要相机权限去拍照\", Snackbar.LENGTH_INDEFINITE)\n                        .setAction(\"ok\", new View.OnClickListener() {\n                            @Override\n                            public void onClick(View v) {\n                                //必须调用该`setIsPositive(true)`方法\n                                helper.setIsPositive(true);\n                                helper.request();\n                            }\n                        }).show();\n            }\n        })\n        //请求权限\n        .request();  注：   with 方法可以传入Activity或者Fragment；  addRequestCode 方法传入请求码，用于区分各种不同的权限申请；  permissions 方法传入的是你所要请求的权限，支持可变参数，可以批量申请权限；  PermissionListener 接口回调的三个方法：  onGranted()会在权限申请通过后被调用；  onDenied()在权限申请被拒绝时被调用  onShowRationale()方法中你可以弹对话框向用户解释权限的作用，不过记得要调用 setIsPositive(true) 。  request 方法用来请求权限申请   2.覆写 onRequestPermissionsResult 方法  @Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    switch (requestCode) {\n        case REQUEST_CODE_CAMERA:\n            helper.onPermissionResult(permissions, grantResults);\n            break;\n    }\n}", 
            "title": "运行时权限管理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#notification", 
            "text": "Android6.0中， Notification.setLatestEventInfo() 方法被移除，替代的方案是用Notification.Builder来构建通知，对此SDK提供了 NotificationCompat(cn.bmob.v3.helper) 类来做版本兼容（与 android.support.v4.app 包下的NotificationCompat用法一样）。  参照代码如下：      NotificationManager notificationManager = (NotificationManager) mContext\n            .getSystemService(Context.NOTIFICATION_SERVICE);\n    PendingIntent pi = PendingIntent.getActivity(mContext, 0,\n            new Intent(MainActivity.this, MainActivity.class), 0);\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)\n            .setTicker( 更新啦 )\n            .setContentTitle( 标题 )\n            .setContentText( 内容 )\n            .setSmallIcon(R.drawable.ic_launcher);\n    Notification notification = builder.build();\n    notificationManager.notify(0, notification);", 
            "title": "Notification变更"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_7", 
            "text": "一个数据对象（APP中创建的BmobObject类的子类）对应于Bmob后台的一个数据表。", 
            "title": "对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_8", 
            "text": "Bmob存储的数据是建立在BmobObject基础上的，所以任何要保存的数据对象必须继承自BmobObject类(不建议用抽象类去继承BmobObject或者定义父类然后在子类中写bean，这样也解析不了，一般不会这么用，一个bean类对应一张表，类似使用ORM库)。BmobObject类本身包含objectId、createdAt、updatedAt、ACL四个默认的属性，objectId是数据的唯一标示，相当于数据库中表的主键，createdAt是数据的创建时间，updatedAt是数据的最后修改时间，ACL是数据的操作权限。  如，你的游戏中使用GameScore表来记录玩家的比分信息，其中表的字段有：score（分数）、playerName（玩家名字）、isPay(是否付费玩家)、pic（玩家头像）属性，那么这个数据对象为如下定义：  //必须要继承自BmobObject类\npublic class GameScore extends BmobObject{\n\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public String getPlayerName() {\n        return playerName;\n    }\n\n    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n\n    public Integer getScore() {\n        return score;\n    }\n\n    public void setScore(Integer score) {\n        this.score = score;\n    }\n\n    public Boolean getIsPay() {\n        return isPay;\n    }\n\n    public void setIsPay(Boolean isPay) {\n        this. isPay = isPay;\n    }\n\n    public BmobFile getPic() {\n        return pic;\n    }\n\n    public void setPic(BmobFile pic) {\n        this.pic = pic;\n    }\n}  需要注意的是：   JavaBean不需要对 objectId、createdAt、updatedAt、ACL 四个属性进行定义。  不少开发者会没有注意到createdAt和updatedAt属性中的字母d，写成createAt和updateAt。  尽可能使用Integer、Boolean，而不是int、boolean，也就是选择包装类，而不是使用基本数据类型（这两者的区别大家可以看这篇文章：http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html）", 
            "title": "数据对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_9", 
            "text": "为了提供更好的服务，BmobSDK中提供了 BmobUser、BmobInstallation、BmobRole 三个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。    BmobUser 对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的 用户管理 部分。    BmobInstallation 对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的 消息推送 部分。    BmobRole 对象主要用于角色管理，对应用于Web端的Role表，具体的使用方法可查看文档的 ACL和角色 部分。", 
            "title": "特殊对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_10", 
            "text": "目前为止，Bmob支持的数据类型：String、Integer、Float、Short、Byte、Double、Character、Boolean、Object、Array。\n同时也支持BmobObject、BmobDate、BmobGeoPoint、BmobFile特有的数据类型。  以下为Web端类型与SDK端支持的JAVA类型对应表：     Web端类型  支持的JAVA类型  说明      Number  Integer、Float、Short、Byte、Double、Character  对应数据库的Number类型    Array  List  数组类型    File  BmobFile  Bmob特有类型，用来标识文件类型    GeoPoint  BmobGeoPoint  Bmob特有类型，用来标识地理位置    Date  BmobDate  Bmob特有类型，用来标识日期类型    Pointer  特定对象  Bmob特有类型，用来标识指针类型    Relation  BmobRelation  Bmob特有类型，用来标识数据关联     注：不能使用int、float、short byte、double、character等基本数据类型。`", 
            "title": "数据类型"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_11", 
            "text": "Bmob官方推荐类名和表名完全一致的映射使用方式， 即如，上面的GameScore类，它在后台对应的表名也是GameScore（区分大小写）。  如果你希望表名和类名并不相同，如表名为T_a_b，而类名还是GameScore，那么你可以使用BmobObject提供的setTableName(\"表名\")的方法，   示例代码如下：  //这时候实际操作的表是T_a_b\npublic class GameScore extends BmobObject{\n    private String playerName;\n    private Integer score;\n    private Boolean isPay;\n    private BmobFile pic;\n\n    public GameScore() {\n        this.setTableName( T_a_b );\n    }\n\n    public String getPlayerName() {\n        return playerName;\n    }\n    //其他方法，见上面的代码\n}  当然了，除了在构造函数中直接调用setTableName方法之外，你还可以在GameScore的实例中动态调用setTableName方法。", 
            "title": "类名和表名的关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_12", 
            "text": "如果您使用了setTableName方法来自定义表名，那么在对该表进行数据查询的时候必须使用以下方法。 需要注意的是查询的结果是JSONArray,需要自行解析JSONArray中的数据 。  /**\n * 查询数据\n */\npublic void queryData(){\n    BmobQuery query =new BmobQuery( Person );\n    query.addWhereEqualTo( age , 25);\n    query.setLimit(2);\n    query.order( createdAt );\n    //v3.5.0版本提供`findObjectsByTable`方法查询自定义表名的数据\n    query.findObjectsByTable(new QueryListener JSONArray () {\n        @Override\n        public void done(JSONArray ary, BmobException e) {\n            if(e==null){\n                Log.i( bmob , 查询成功： +ary.toString());\n            }else{\n                Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n            }\n        }\n    });\n}  自定义表名情况下的更新、删除数据和普通的更新、删除数据方式一样，没有变化。为方便大家了解学习，我们提供了一个关于自定义表名情况下增删改查数据的Demo，下载地址是： https://github.com/bmob/bmob-android-demo-dynamic-tablename 。", 
            "title": "查询自定义表名的数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_13", 
            "text": "添加数据使用BmobObject对象的 save 方法，就可以将当前对象的内容保存到Bmob服务端。\n例如，你现在要保存一条游戏分数的记录，代码如下：  GameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId( )方法\ngameScore.setPlayerName( 比目 );\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        if(e==null){\n            toast( 创建数据成功：  + objectId);\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n})  运行以上代码，如果添加成功，你可以在Bmob提供的后台的数据浏览中看到类似这样的结果：  objectId:  0c6db13c , score: 89, playerName:  比目 , isPay: false,createdAt: 2013-09-27 10:32:54 , updatedAt: 2013-09-27 10:32:54   这里需要注意的是： \n1. 如果服务器端不存在GameScore表，那么系统将自动建表，并插入数据。\n2. 如果服务器端已经存在GameScore表，和相应的score、playerName、isPay字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则会保存数据失败。\n3. 每个BmobObject对象都有几个默认的键(数据列)是不需要开发者指定的， objectId 是每个保存成功数据的唯一标识符。 createdAt 和 updatedAt 代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键(数据列)的创建和数据内容是由服务器端自主来完成的。 因此，使用save和insert方法时,不需要调用setObjectId方法，否则会出现提示：“It is a reserved field: objectId(105)”--表明objectId为系统保留字段，不允许修改。 。", 
            "title": "添加数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_14", 
            "text": "更新一个对象也是非常简单。例如：将GameScore表中objectId为 0c6db13c 的游戏分数修改为77.  GameScore gameScore = new GameScore();\ngameScore.setScore(77);\ngameScore.update( 0c6db13c , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 更新成功 );\n        }else{\n            Log.i( bmob , 更新失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  自 V3.4.4 版本开始，SDK提供了另一种方法来更新数据，通过调用 Bmobobject 类中的 setValue（key，value） 方法，只需要传入key及想要更新的值即可  举例，说明如下：  public class Person extends BmobObject {\n    private BmobUser user;  //BmobObject类型\n    private BankCard cards; //Object类型\n    private Integer age;    //Integer类型\n    private Boolean gender; //Boolean类型\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\n\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}  Person p2=new Person();\n//更新BmobObject的值\n//  p2.setValue( user , BmobUser.getCurrentUser(this, MyUser.class));\n//更新Object对象\np2.setValue( bankCard ,new BankCard( 农行 ,  农行账号 ));\n//更新Object对象的值\n//p2.setValue( bankCard.bankName , 建行 );\n//更新Integer类型\n//p2.setValue( age ,11);\n//更新Boolean类型\n//p2.setValue( gender , true);\np2.update(objectId, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 更新成功 );\n        }else{\n            Log.i( bmob , 更新失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n\n});  注意：修改数据只能通过objectId来修改，目前不提供查询条件方式的修改方法。", 
            "title": "更新数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_15", 
            "text": "很多应用可能会有计数器功能的需求，比如文章点赞的功能，如果大量用户并发操作，用普通的更新方法操作的话，会存在数据不一致的情况。  为此，Bmob提供了原子计数器来保证原子性的修改某一 数值字段 的值。注意：原子计数器只能对应用于Web后台的Number类型的字段，即JavaBeans数据对象中的Integer对象类型（ 不要用int类型 ）。  gameScore.increment( score ); // 分数递增1\ngameScore.update(updateListener);  您还可以通过 increment(key, amount) 方法来递增或递减任意幅度的数字  gameScore.increment( score , 5); // 分数递增5\n//gameScore.increment( score , -5); // 分数递减5\ngameScore.update(updateListener);", 
            "title": "原子计数器"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_16", 
            "text": "从服务器删除对象。例如：将GameScore表中objectId为 dd8e6aff28 的数据删除。  GameScore gameScore = new GameScore();\ngameScore.setObjectId( dd8e6aff28 );\ngameScore.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  注意：删除数据只能通过objectId来删除，目前不提供查询条件方式的删除方法。", 
            "title": "删除数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_17", 
            "text": "你可以在一个对象中删除一个字段的值，通过 remove 操作：  GameScore gameScore = new GameScore();\ngameScore.setObjectId( dd8e6aff28 );\ngameScore.remove( score );  // 删除GameScore对象中的score字段\ngameScore.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "删除字段的值"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_18", 
            "text": "自2017年04月起，为了提供更稳定的服务，后端启用了QPS限制，所以推荐采用批量数据操作来解决如果需要在循环里多次提交请求但是后端返回QPS达到限制的报错。  自 v3.5.0 开始,新增 BmobBatch 批量操作类， 支持批量添加、批量更新、批量删除的三种操作的同步提交 ，且批量添加的请求返回objectId字段。  在BmobObject对象中提供了三种用于批量操作的方法，分别是 insertBatch 、 updateBatch 、 deleteBatch ,批量添加、更新、删除。", 
            "title": "批量数据操作"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_19", 
            "text": "List BmobObject  persons = new ArrayList BmobObject ();\nfor (int i = 0; i   3; i++) {\n    Person person = new Person();\n    person.setName( 张三  +i);\n    persons.add(person);\n}\n//第一种方式:v3.5.0之前的版本\nnew BmobObject().insertBatch(this, persons, new SaveListener() {\n    @Override\n    public void onSuccess() {\n        toast( 批量添加成功 );\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast( 批量添加失败: +msg);\n    }\n});\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().insertBatch(persons).doBatch(new QueryListListener BatchResult () {\n\n            @Override\n            public void done(List BatchResult  o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i o.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log( 第 +i+ 个数据批量添加成功： +result.getCreatedAt()+ , +result.getObjectId()+ , +result.getUpdatedAt());\n                        }else{\n                            log( 第 +i+ 个数据批量添加失败： +ex.getMessage()+ , +ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n                }\n            }\n        });", 
            "title": "批量添加"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_20", 
            "text": "List BmobObject  persons = new ArrayList BmobObject ();\nPerson p1 = new Person();\np1.setObjectId( e51d651c22 );\np1.setAge(25);\nPerson p2 = new Person();\np2.setObjectId( 3f70a922c4 );\np2.setAge(26);\np2.setGender(false);\nPerson p3 = new Person();\np3.setObjectId( 08fdd55765 );\np3.setAge(27);\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().updateBatch(this, persons, new UpdateListener() {\n    @Override\n    public void onSuccess() {\n        toast( 批量更新成功 );\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast( 批量更新失败: +msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().updateBatch(persons).doBatch(new QueryListListener BatchResult () {\n\n            @Override\n            public void done(List BatchResult  o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i o.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log( 第 +i+ 个数据批量更新成功： +result.getUpdatedAt());\n                        }else{\n                            log( 第 +i+ 个数据批量更新失败： +ex.getMessage()+ , +ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n                }\n            }\n        });", 
            "title": "批量更新"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_21", 
            "text": "List BmobObject  persons = new ArrayList BmobObject ();\nPerson p1 = new Person();\np1.setObjectId( 38ea274d0c );\nPerson p2 = new Person();\np2.setObjectId( 01e29165bc );\nPerson p3 = new Person();\np3.setObjectId( d8226c4828 );\n\npersons.add(p1);\npersons.add(p2);\npersons.add(p3);\n//第一种方式：v3.5.0之前的版本\nnew BmobObject().deleteBatch(this, persons, new DeleteListener() {\n    @Override\n    public void onSuccess() {\n        toast( 批量删除成功 );\n    }\n    @Override\n    public void onFailure(int code, String msg) {\n        toast( 批量删除失败: +msg);\n    }\n});\n\n//第二种方式：v3.5.0开始提供\nnew BmobBatch().deleteBatch(persons).doBatch(new QueryListListener BatchResult () {\n\n            @Override\n            public void done(List BatchResult  o, BmobException e) {\n                if(e==null){\n                    for(int i=0;i o.size();i++){\n                        BatchResult result = o.get(i);\n                        BmobException ex =result.getError();\n                        if(ex==null){\n                            log( 第 +i+ 个数据批量删除成功 );\n                        }else{\n                            log( 第 +i+ 个数据批量删除失败： +ex.getMessage()+ , +ex.getErrorCode());\n                        }\n                    }\n                }else{\n                    Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n                }\n            }\n        });", 
            "title": "批量删除"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#v350", 
            "text": "BmobBatch batch =new BmobBatch();\n//批量添加\nList BmobObject  persons = new ArrayList BmobObject ();\nPerson person = new Person();\nperson.setName( 张三  );\npersons.add(person);\nbatch.insertBatch(persons);\n\n//批量更新\nList BmobObject  persons1=new ArrayList BmobObject ();\nPerson p1 = new Person();\np1.setObjectId( 3388eb6caf );\np1.setAge(35);\npersons1.add(p1);\nbatch.updateBatch(persons1);\n\n//批量删除\nList BmobObject  persons2 = new ArrayList BmobObject ();\nPerson p2 = new Person();\np2.setObjectId( 9af452ebd );\npersons2.add(p2);\nbatch.deleteBatch(persons2);\n//执行批量操作\nbatch.doBatch(new QueryListListener BatchResult (){\n\n    @Override\n    public void done(List BatchResult  results, BmobException ex) {\n        if(ex==null){\n            //返回结果的results和上面提交的顺序是一样的，请一一对应\n            for(int i=0;i results.size();i++){\n                BatchResult result= results.get(i);\n                if(result.isSuccess()){//只有批量添加才返回objectId\n                    log( 第 +i+ 个成功： +result.getObjectId()+ , +result.getUpdatedAt());\n                }else{\n                    BmobException error= result.getError();\n                    log( 第 +i+ 个失败： +error.getErrorCode()+ , +error.getMessage());\n                }\n            }\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  注：   批量操作每次只支持最大50条记录的操作。  批量操作不支持对User表的操作。", 
            "title": "批量添加、批量更新、批量删除同步提交（v3.5.0开始提供）"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_22", 
            "text": "数据的查询可能是每个应用都会频繁使用到的，BmobSDK中提供了 BmobQuery 类，它提供了多样的方法来实现不同条件的查询，同时它的使用也是非常的简单和方便的。", 
            "title": "查询数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_23", 
            "text": "当我们知道某条数据的 objectId 时，就可以根据 objectId 直接获取单条数据对象。例如：查询 objectId 为 a203eba875 的人员信息。  BmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.getObject( a203eba875 , new QueryListener GameScore () {\n\n    @Override\n    public void done(GameScore object, BmobException e) {\n        if(e==null){\n            //获得playerName的信息\n            object.getPlayerName();\n            //获得数据的objectId信息\n            object.getObjectId();\n            //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n            object.getCreatedAt();\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n\n});", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_24", 
            "text": "查询某个数据表中的所有数据是非常简单的查询操作，例如：查询GameScore表中playerName为“比目”的50条数据记录。  BmobQuery GameScore  query = new BmobQuery GameScore ();\n//查询playerName叫“比目”的数据\nquery.addWhereEqualTo( playerName ,  比目 );\n//返回50条数据，如果不加上这条语句，默认返回10条数据\nquery.setLimit(50);\n//执行查询方法\nquery.findObjects(new FindListener GameScore () {\n    @Override\n    public void done(List GameScore  object, BmobException e) {\n        if(e==null){\n            toast( 查询成功：共 +object.size()+ 条数据。 );\n            for (GameScore gameScore : object) {\n               //获得playerName的信息\n               gameScore.getPlayerName();\n               //获得数据的objectId信息\n               gameScore.getObjectId();\n               //获得createdAt数据创建时间（注意是：createdAt，不是createAt）\n               gameScore.getCreatedAt();\n            }\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  查询的结果不需要进行任何处理，BmobSDK已经为你封装成相应的JavaBean集合了，你直接使用即可。  注： \n1 通过setLimit方法设置返回的记录数量。更多细节可查看下一节(查询条件)中的分页查询。 \n2 v3.5.2开始可以对查询条件等提供链式调用的写法，如下：  BmobQuery Book  query = new BmobQuery ();\n        query.setLimit(8).setSkip(1).order( -createdAt )\n                .findObjects(new FindListener Book () {\n                    @Override\n                    public void done(List Book  object, BmobException e) {\n                        if (e == null) {\n                            // ...\n                        } else {\n                            // ...\n                        }\n                    }\n                });", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_25", 
            "text": "在查询的使用过程中，基于不同条件的查询是非常常见的，BmobQuery同样也支持不同条件的查询。", 
            "title": "查询条件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_26", 
            "text": "如果要查询特定键的特定值，可以使用 addWhereEqualTo 方法，如果要过滤掉特定键的值可以使用 addWhereNotEqualTo 方法。  比如需要查询playerName不等于“Barbie”的数据时可以这样写：  query.addWhereNotEqualTo( playerName ,  Barbie );  当然，你可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。  query.addWhereNotEqualTo( playerName ,  Barbie );     //名字不等于Barbie\nquery.addWhereGreaterThan( score , 60);               //条件：分数大于60岁  各种不同条件的比较查询：  // 分数   50\nquery.addWhereLessThan( score , 50);\n//分数  = 50\nquery.addWhereLessThanOrEqualTo( score , 50);\n//分数   50\nquery.addWhereGreaterThan( score , 50);\n//分数  = 50\nquery.addWhereGreaterThanOrEqualTo( score , 50);", 
            "title": "比较查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_27", 
            "text": "如果你想查询匹配几个不同值的数据，如：要查询“Barbie”,“Joe”,“Julia”三个人的成绩时，你可以使用 addWhereContainedIn 方法来实现。  String[] names = { Barbie ,  Joe ,  Julia };\nquery.addWhereContainedIn( playerName , Arrays.asList(names));  相反，如果你想查询排除“Barbie”,“Joe”,“Julia”这三个人的其他同学的信息，你可以使用 addWhereNotContainedIn 方法来实现。  String[] names = { Barbie ,  Joe ,  Julia };\nquery.addWhereNotContainedIn( playerName , Arrays.asList(names));", 
            "title": "子查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_28", 
            "text": "时间查询 比较特殊，我们需要结合 BmobDate 这个类来查询某个指定日期时间前后的数据，这里也给出示例供大家参考：  比如:\n如果想查询指定日期之前的数据，则可以使用 addWhereLessThan 或者 addWhereLessThanOrEqualTo （包含当天）来查询。\n如果想查询指定日期之后的数据，则可以使用 addWhereGreaterThan 或 addWhereGreaterThanOrEqualTo （包含当天）来查询。\n如果想查询指定时间当天的数据，则需要使用 复合与查询 来查询，例如，想 查询2015年5月1号当天的Person数据 ,示例代码如下：  BmobQuery Person  query = new BmobQuery Person ();\nList BmobQuery Person  and = new ArrayList BmobQuery Person ();\n//大于00：00：00\nBmobQuery Person  q1 = new BmobQuery Person ();\nString start =  2015-05-01 00:00:00 ;  \nSimpleDateFormat sdf = new SimpleDateFormat( yyyy-MM-dd HH:mm:ss );  \nDate date  = null;\ntry {\ndate = sdf.parse(start);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq1.addWhereGreaterThanOrEqualTo( createdAt ,new BmobDate(date));\nand.add(q1);\n//小于23：59：59\nBmobQuery Person  q2 = new BmobQuery Person ();\nString end =  2015-05-01 23:59:59 ; \nSimpleDateFormat sdf1 = new SimpleDateFormat( yyyy-MM-dd HH:mm:ss );  \nDate date1  = null;\ntry {\ndate1 = sdf1.parse(end);\n} catch (ParseException e) {\ne.printStackTrace();\n}  \nq2.addWhereLessThanOrEqualTo( createdAt ,new BmobDate(date1));\nand.add(q2);\n//添加复合与查询\nquery.and(and);  注： 由于createdAt、updatedAt是服务器自动生成的时间，在服务器保存的是精确到微秒值的时间，所以，基于时间类型的比较的值要加1秒。", 
            "title": "时间查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_29", 
            "text": "对于字段类型为数组的情况，需要查找字段中的数组值包含有xxx的对象，可以使用 addWhereContainsAll 方法：  比如我想查询有阅读和唱歌爱好的人，可以这样：  BmobQuery Person  query = new BmobQuery Person ();\nString [] hobby = { 阅读 , 唱歌 };\nquery.addWhereContainsAll( hobby , Arrays.asList(hobby));\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            ...\n        }else{\n            ...\n        }\n    }\n\n});", 
            "title": "数组查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_30", 
            "text": "对字符串值的模糊查询 比如 查询包含字符串的值，有几种方法。  你可以使用任何正确的正则表达式来检索相匹配的值，使用 addWhereMatches 方法：  query.addWhereMatches(( username ,  ^[A-Z]\\\\d );  还可以使用如下方法：  //查询username字段的值含有“sm”的数据\nquery.addWhereContains( username ,  sm );\n\n//查询username字段的值是以“sm“字开头的数据\nquery.whereStartsWith( username ,  sm );\n\n// 查询username字段的值是以“ile“字结尾的数据\nquery.whereEndsWith( username ,  ile );  注:模糊查询只对付费用户开放，付费后可直接使用。", 
            "title": "模糊查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_31", 
            "text": "如果你想查询某个列的值存在，那么可以使用 addWhereExists 方法：  //查询username有值的数据\nquery.addWhereExists( username );  如果想查询某个列的值不存在，则可以用 addWhereDoesNotExists 方法  //查询username字段没有值的数据\nquery.addWhereDoesNotExists( username );", 
            "title": "列值是否存在"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_32", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用 setLimit 方法来限制查询结果的数据条数来进行分页。  默认情况下，Limit的值为 100 ，最大有效设置值 1000 （设置的数值超过1000还是视为1000）。  query.setLimit(10); // 限制最多10条数据结果作为一页  在数据较多的情况下，在 setLimit 的基础上分页显示数据是比较合理的解决办法。 setSKip 方法可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为10。  query.setSkip(10); // 忽略前10条数据（即第一页数据结果）  大家也可以直接下载我们提供的Demo源码（ https://github.com/bmob/bmob-android-demo-paging ），查看如何使用分页查询，结合ListView开发下拉刷新查看更多内容的应用。", 
            "title": "分页查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_33", 
            "text": "对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：  // 根据score字段升序显示数据\nquery.order( score );\n// 根据score字段降序显示数据\nquery.order( -score );\n// 多个排序字段可以用（，）号分隔\nquery.order( -score,createdAt );  说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。", 
            "title": "排序"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_34", 
            "text": "", 
            "title": "复合查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#and", 
            "text": "有些查询需要使用到复合“与”的查询条件，例如：你想查询出Person表中年龄在6-29岁之间且姓名以\"y\"或者\"e\"结尾的人，那么，可以采用and查询，示例代码如下：  //查询年龄6-29岁之间的人，每一个查询条件都需要New一个BmobQuery对象\n//--and条件1\nBmobQuery Person  eq1 = new BmobQuery Person ();\neq1.addWhereLessThanOrEqualTo( age , 29);//年龄 =29\n//--and条件2\nBmobQuery Person  eq2 = new BmobQuery Person ();\neq2.addWhereGreaterThanOrEqualTo( age , 6);//年龄 =6\n\n//查询姓名以 y 或者 e 结尾的人--这个需要使用到复合或查询（or）\n//--and条件3\nBmobQuery Person  eq3 = new BmobQuery Person ();\neq3.addWhereEndsWith( name ,  y );\nBmobQuery Person  eq4 = new BmobQuery Person ();\neq4.addWhereEndsWith( name ,  e );\nList BmobQuery Person  queries = new ArrayList BmobQuery Person ();\nqueries.add(eq3);\nqueries.add(eq4);\nBmobQuery Person  mainQuery = new BmobQuery Person ();\nBmobQuery Person  or = mainQuery.or(queries);\n\n//最后组装完整的and条件\nList BmobQuery Person  andQuerys = new ArrayList BmobQuery Person ();\nandQuerys.add(eq1);\nandQuerys.add(eq2);\nandQuerys.add(or);\n//查询符合整个and条件的人\nBmobQuery Person  query = new BmobQuery Person ();\nquery.and(andQuerys);\nquery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            toast( 查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数： +object.size());\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "与查询(and)"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#or", 
            "text": "有些情况，在查询的时候需要使用到复合的“或”的查询条件。例如，你想查出 Person 表中 age 等于 29 或者 age 等于 6 的人，可以这样：  BmobQuery Person  eq1 = new BmobQuery Person ();\neq1.addWhereEqualTo( age , 29);\nBmobQuery Person  eq2 = new BmobQuery Person ();\neq2.addWhereEqualTo( age , 6);\nList BmobQuery Person  queries = new ArrayList BmobQuery Person ();\nqueries.add(eq1);\nqueries.add(eq2);\nBmobQuery Person  mainQuery = new BmobQuery Person ();\nmainQuery.or(queries);\nmainQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            toast( 查询年龄6-29岁之间，姓名以'y'或者'e'结尾的人个数： +object.size());\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  你还可以在此基础上添加更多的约束条件到新创建的 BmobQuery 对象上，表示一个 and 查询操作。", 
            "title": "或查询(or)"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_35", 
            "text": "如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配对象的具体数据信息，可以直接使用 count 替代 findObjects 。例如，查询一个特定玩家玩的游戏场数：  BmobQuery GameSauce  query = new BmobQuery GameSauce ();\nquery.addWhereEqualTo( playerName ,  Barbie );\nquery.count(GameSauce.class, new CountListener() {\n    @Override\n    public void done(Integer count, BmobException e) {\n        if(e==null){\n            toast( count对象个数为： +count);\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});", 
            "title": "查询结果计数"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_36", 
            "text": "有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用BmobQuery对象提供的 addQueryKeys 方法来实现。如下所示：  //只返回Person表的objectId这列的值\nBmobQuery Person  bmobQuery = new BmobQuery Person ();\nbmobQuery.addQueryKeys( objectId );\nbmobQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object, BmobException e) {\n        if(e==null){\n            toast( 查询成功：共  + object.size() +  条数据。 );\n            //注意：这里的Person对象中只有指定列的数据。\n        }else{\n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n});  指定多列时用 , 号分隔每列，如： addQueryKeys(\"objectId,name,age\") ;", 
            "title": "查询指定列"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_37", 
            "text": "从 BmobSDKV3.3.6 开始，Bmob为开发者提供了以下关键字或其组合的统计查询操作,分别用于计算 总和、平均值、最大值、最小值 ，同时支持分组和过滤条件。     方法名  参数说明  方法说明      sum  String[] sumKeys（多个列名）  求某列或多列的和    average  String[] aveKeys（多个列名）  求某列或多列的平均值    max  String[] maxKeys（多个列名）  求某列或多列的最大值    min  String[] minKeys（多个列名）  求某列或多列的最小值    groupby  String[] groupKeys（多个列名）  分组    having  HashMap map(键（String）值(Object)对的形式)  分组的过滤条件    setHasGroupCount  boolean hasCount  是否返回每个分组的记录数     注：\n1、为避免和用户创建的列名称冲突，Bmob约定以上查询返回的字段采用 _(关键字)+首字母大写的列名  的格式：\n例：\n计算玩家得分表（GameScore）中列名为score的总和，那么返回的结果集会有一个列名为 _sumScore ，\n若设置了setHasGroupCount（true）,则结果集中会返回 _count 。\n2、以上方法可自由组合且与之前的查询语句中的where, order, limit, skip等组合一起使用。 \n3、因为返回格式不固定，故使用 findStatistics 来专门处理统计查询。", 
            "title": "统计查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_38", 
            "text": "例如，如果要计算所有玩家的得分总和，那么代码如下：  BmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] {  playScore  });\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){//\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n                    int sum = obj.getInt( _sumPlayScore );//_(关键字)+首字母大写的列名\n                    showToast( 游戏总得分：  + sum);\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            }else{\n                showToast( 查询成功，无数据 );\n            }\n        }else{  \n            Log.i( bmob , 失败： +e.getMessage()+ , +e.getErrorCode());\n        }\n    }\n\n});  注： sum方法的参数只能查询Number类型的列名（对应Java的Integer类型） ，即要计算哪个列的值的总和。  查询平均值、最大、最小和上面的求和类似，在这里也一并提示下：  BmobQuery GameScore  query = new BmobQuery GameScore ();\n//query.average(new String[]{ playScore });//查询某列的平均值\nquery.min(new String[]{ playScore });//查询最小值\n//query.max(new String[]{ playScore });//查询最大值\nquery.groupby(new String[]{ createdAt });\nquery.findStatistics(GameScore.class, new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            JSONArray ary = (JSONArray) result;\n            if (ary!=null) {\n                try {\n                    JSONObject obj = ary.getJSONObject(0);\n    //              int playscore = obj.getInt( _avgPlayScore );\n                    int minscore = obj.getInt( _minPlayScore );\n    //              int maxscore = obj.getInt( _maxPlayScore );\n                    String createDate = obj.getString( createdAt );\n                    showToast( minscore =   + minscore+  ,统计时间 =  + createDate);\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n        } else {\n            showToast( 查询成功，无数据 );\n        }\n        }else{\n            loge(e);\n        }\n    }\n});", 
            "title": "统计查询方法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_39", 
            "text": "如果你需要对查询结果进行分组，可使用 groupby 方法，支持根据多个列名进行分组。  //我们以创建时间按天和游戏分别统计玩家的得分，并按时间降序\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] {  playScore ,  signScore  });//求多个列的总和\nquery.groupby(new String[] {  createdAt ,  game  });//按照时间和游戏名进行分组\nquery.order( -createdAt );//降序排列\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i   length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt( _sumPlayScore );\n                        int signscore = obj.getInt( _sumSignScore );\n                        String createDate = obj.getString( createdAt );\n                        String game = obj.getString( game );\n                        showToast( 游戏总得分：  + playscore +  ,签到得分： \n                                + signscore +  ,时间:  + createDate+ ,game: +game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            loge(e);\n        }\n    }\n});  有时候，我们需要知道分组统计时每个分组有多少条记录，可使用 setHasGroupCount（true） ,如下：  // 查询创建时间按天统计所有玩家的得分和每一天有多少条玩家的得分记录，并按时间降序:\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] {  playScore  });    // 统计总得分\nquery.groupby(new String[] {  createdAt  });// 按照时间分组\nquery.order( -createdAt );                  // 降序排列\nquery.setHasGroupCount(true);              // 统计每一天有多少个玩家的得分记录，默认不返回分组个数\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if (ary!=null) {\n                int length = ary.length();\n                try {\n                    for (int i = 0; i   length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt( _sumPlayScore );\n                        String createDate = obj.getString( createdAt );\n                        int count = obj.getInt( _count );//setHasGroupCount设置为true时，返回的结果中含有 _count 字段\n                        showToast( 游戏总得分：  + playscore +  ,总共统计了 \n                                + count +  条记录,统计时间 =  + createDate);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            loge(e);\n        }\n    }\n});", 
            "title": "分组统计"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_40", 
            "text": "如果需要对分组计算后的结果再进行过滤，可使用 having 来继续过滤部分结果。  //我们按游戏名统计所有玩家的总得分，并只返回总得分大于100的记录，并按时间降序\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.sum(new String[] { playScore });//计算总得分数\nquery.groupby(new String[] { game });//分组条件：按游戏名进行分组\nquery.order( -createdAt );// 降序排列\nHashMap String, Object  map = new HashMap String, Object ();\nJSONObject js = new JSONObject();\ntry {\n    js.put( $gt , 100);\n} catch (JSONException e1) {\n}\nmap.put( _sumPlayScore , js);//过滤条件：总得分数大于100\nquery.having(map);\nquery.setLimit(100);\nquery.findStatistics(GameScore.class,new QueryListener JSONArray () {\n\n    @Override\n    public void done(JSONArray ary, BmobException e) {\n        if(e==null){\n            if(ary!=null){\n                int length = ary.length();\n                try {\n                    for (int i = 0; i   length; i++) {\n                        JSONObject obj = ary.getJSONObject(i);\n                        int playscore = obj.getInt( _sumPlayScore );//过滤条件的key是什么，返回的数据中就有什么\n                        String game = obj.getString( game );//返回的数据中同样包含groupby里面的列名\n                        showToast( 游戏得分：  + playscore +  ,游戏名 =  + game);\n                    }\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            } else {\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            loge(e);\n        }\n    }\n\n});", 
            "title": "添加过滤条件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_41", 
            "text": "缓存查询通常是将查询结果缓存在磁盘上。\n当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。\n或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。\n这样可以让用户不必在按下某个按钮后进行枯燥的等待。\n默认的查询操作是没有启用缓存的，开发者可以使用 setCachePolicy 方法来启用缓存功能。\n例如：优先从缓存获取数据，如果获取失败再从网络获取数据。  bmobQuery.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 先从缓存获取数据，如果没有，再从网络获取。\nbmobQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共 +object.size()+ 条数据。 );\n        }else{\n            toast( 查询失败： +msg);\n        }\n    }\n\n});", 
            "title": "缓存查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_42", 
            "text": "Bmob SDK提供了几种不同的缓存策略，以适应不同应用场景的需求：   IGNORE_CACHE      :只从网络获取数据，且不会将数据缓存在本地，这是默认的缓存策略。  CACHE_ONLY         :只从缓存读取数据，如果缓存没有数据会导致一个BmobException,可以忽略不处理这个BmobException.  NETWORK_ONLY       :只从网络获取数据，同时会在本地缓存数据。  NETWORK_ELSE_CACHE :先从网络读取数据，如果没有，再从缓存中获取。  CACHE_ELSE_NETWORK :先从缓存读取数据，如果没有，再从网络获取。  CACHE_THEN_NETWORK :先从缓存取数据，无论结果如何都会再次从网络获取数据。也就是说会产生2次调用。   建议的做法：  第一次进入应用的时候，设置其查询的缓存策略为 CACHE_ELSE_NETWORK ,当用户执行上拉或者下拉刷新操作时，设置查询的缓存策略为 NETWORK_ELSE_CACHE 。", 
            "title": "缓存策略"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_43", 
            "text": "如果需要操作缓存内容，可以使用BmobQuery提供的方法做如下操作：   检查是否存在当前查询条件的缓存数据   boolean isInCache = query.hasCachedResult(Class ?  clazz);  注：缓存和查询条件有关，此方法必须放在所有的查询条件（where、limit、order、skip、include等）都设置完之后，否则会得不到缓存数据。   清除当前查询的缓存数据   query.clearCachedResult(Class ?  clazz);   清除所有查询结果的缓存数据   BmobQuery.clearAllCachedResults(Class ?  clazz);   设置缓存的最长时间（以毫秒为单位）   query.setMaxCacheAge(TimeUnit.DAYS.toMillis(1));//此表示缓存一天  示例如下：  BmobQuery Person  query  = new BmobQuery Person ();\nquery.addWhereEqualTo( age , 25);\nquery.setLimit(10);\nquery.order( createdAt );\n//判断是否有缓存，该方法必须放在查询条件（如果有的话）都设置完之后再来调用才有效，就像这里一样。\nboolean isCache = query.hasCachedResult(Person.class);\nif(isCache){--此为举个例子，并不一定按这种方式来设置缓存策略\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共 +object.size()+ 条数据。 );\n        }else{\n            toast( 查询失败： +msg);\n        }\n    }\n});  注：  1、只有当缓存查询的条件一模一样时才会获取到缓存到本地的缓存数据。  2、设置的默认的最大缓存时长为5小时。", 
            "title": "缓存方法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bql", 
            "text": "Bmob Query Language （简称 BQL） 是 Bmob 自  BmobSDKV3.3.7  版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。   具体的 BQL 语法，请参考  Bmob Query Language 详细指南 。", 
            "title": "BQL查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bql_1", 
            "text": "可以通过以下方法来进行SQL查询：\n例如：需要查询所有的游戏得分记录  String bql = select * from GameScore ;//查询所有的游戏得分记录\nnew BmobQuery GameScore ().doSQLQuery(bql,new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  上面的示例也等价于( 此方法自BmobV3.3.8版本提供 )：  //查询所有的游戏得分记录\nString bql = select * from GameScore ;\nBmobQuery GameScore  query=new BmobQuery GameScore ();\n//设置查询的SQL语句\nquery.setSQL(bql);\nquery.doSQLQuery(new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  如果需要查询个数，则可以这样：  String bql =  select count(*),* from GameScore ;//查询GameScore表中总记录数并返回所有记录信息\nnew BmobQuery GameScore ().doSQLQuery(bql, new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            int count = result.getCount();//这里得到符合条件的记录数\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线  _ 。  比如，你想查询的是用户 smile 的信息，则：  select * from _User where username = smile", 
            "title": "基本BQL查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bql_2", 
            "text": "由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用 doStatisticQuery 方法来进行：  //按照姓名分组求和,并将结果按时间降序排列\nString bql =  select sum(playScore) from GameScore group by name order by -createdAt ;\nnew BmobQuery GameScore ().doStatisticQuery(bql,new QueryListener JSONArray (){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        if(e ==null){\n            JSONArray ary = (JSONArray) result;\n            if(ary!=null){//开发者需要根据返回结果自行解析数据\n                ...\n            }else{\n                showToast( 查询成功，无数据 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});", 
            "title": "统计BQL查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_44", 
            "text": "在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的  PreparedStatement  使用占位符查询的语法结构。", 
            "title": "占位符查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_45", 
            "text": "String bql= select * from GameScore where player = ? and game = ? ;//查询玩家1的地铁跑酷的GameScore信息\nnew BmobQuery GameScore ().doSQLQuery(bql,new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n}, 玩家1 , 地铁跑酷 );  最后的可变参数  玩家1  和  地铁跑酷  会自动替换查询语句中的问号位置（按照问号的先后出现顺序）。  上面的示例也等价于如下代码（ 此方法自BmobV3.3.8版本提供 ）：  String bql= select * from GameScore where player = ? and game = ? ;\nBmobQuery GameScore  query=new BmobQuery GameScore ();\n//设置SQL语句\nquery.setSQL(bql);\n//设置占位符参数\nquery.setPreparedParams(new Object[]{ 玩家1 , 地铁跑酷 });\nquery.doSQLQuery(new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});", 
            "title": "普通查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_46", 
            "text": "对于包含 内置函数 的占位符查询，比较特殊，请使用 Bmob Query Language 详细指南 中的 内置函数 中 占位符查询用到的内置函数 列出的形式进行查询操作：  举例：我想查询当前用户在2015年5月12日之后，在特定地理位置附近的游戏记录，可以这样：  String sql =  select * from GameScore where createdAt   date(?) and player = pointer(?,?) and gps near geopoint(?,?) ;\nnew BmobQuery GameScore ().doSQLQuery(sql,new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            List GameScore  list = (List GameScore ) result.getResults();\n            if(list!=null   list.size() 0){\n                ...\n            }else{\n                Log.i( smile ,  查询成功，无数据返回 );\n            }\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n}, 2015-05-12 00:00:00 , _User ,user.getObjectId(),112.934755,24.52065);  注  1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；  2、最后的可变参数会自动替换查询语句中的问号位置（按照问号的先后出现顺序），有多少个问号，最后的可变参数就应该有多少个；  3、同样的，统计查询也支持占位符,只需要将 doSQLQuery 替换成 doStatisticQuery 方法即可；  4、只有查询条件 where``limit 子句支持占位符查询，和统计查询有关的 group by 、 order by 、 having 等字句是不支持占位符的。  例如： 正确 查询：  //按照游戏名进行分组并获取总得分数大于200的统计信息，同时统计各分组的记录数\nString bql =  select sum(playScore),count(*) from GameScore group by game having _sumPlayScore 200 ;\nnew BmobQuery GameScore ().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n});  错误 查询：  String bql =  select sum(playScore),count(*) from GameScore group by ? having ? ;\nnew BmobQuery GameScore ().doStatisticQuery(bql,new StatisticQueryListener(){\n\n    @Override\n    public void done(Object result, BmobException e) {\n        ...\n    }\n}, game , _sumPlayScore 200 );", 
            "title": "内置函数"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bql_3", 
            "text": "BQL查询同步支持 缓存查询 ，只需要调用BmobQuery的 setCachePolicy 方法设置缓存策略即可， 建议使用如下方式进行BQL缓存查询 ：  String sql =  select * from GameScore order by playScore,signScore desc ;\nBmobQuery GameScore  query = new BmobQuery GameScore ();\n//设置sql语句\nquery.setSQL(sql);\n//判断此查询本地是否存在缓存数据\nboolean isCache = query.hasCachedResult(GameScore.class);\nif(isCache){\n    query.setCachePolicy(CachePolicy.CACHE_ELSE_NETWORK);   // 如果有缓存的话，则设置策略为CACHE_ELSE_NETWORK\n}else{\n    query.setCachePolicy(CachePolicy.NETWORK_ELSE_CACHE);   // 如果没有缓存的话，则设置策略为NETWORK_ELSE_CACHE\n}\nquery.doSQLQuery(new SQLQueryListener GameScore (){\n\n    @Override\n    public void done(BmobQueryResult GameScore  result, BmobException e) {\n        if(e ==null){\n            Log.i( smile ,  查询到： +result.getResults().size()+ 符合条件的数据 );\n        }else{\n            Log.i( smile ,  错误码： +e.getErrorCode()+ ，错误描述： +e.getMessage());\n        }\n    }\n});  注：  doSQLQuery目前有三种查询方式进行SQL查询，分别是：  1、doSQLQuery（Context context,SQLQueryListener  listener)  2、doSQLQuery（Context context, String bql, SQLQueryListener  listener)----基本BQL查询  3、doSQLQuery（Context context, String bql, SQLQueryListener  listener,Object... params)----占位符查询  只有 第一种查询方式 才能和 query.hasCachedResult(context,class) 或者 query.clearCachedResult(context,class) 并列使用。  建议使用 第一种查询方式 进行BQL缓存查询。", 
            "title": "BQL缓存查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_47", 
            "text": "对于数组类型数据，BmobSDK提供了3种操作来原子性地修改一个数组字段的值：   add、addAll  在一个数组字段的后面添加一些指定的对象(包装在一个数组内)  addUnique、addAllUnique  只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置随机  removeAll  从一个数组字段的值内移除指定数组中的所有对象   举例子：  public class Person extends BmobObject {\n    private List String  hobbys;        // 爱好-对应服务端Array类型：String类型的集合\n    private List BankCard  cards;       // 银行卡-对应服务端Array类型:Object类型的集合\n    ...\n    getter、setter方法\n}\n\n其中BankCard类结构如下：\npublic class BankCard{\n    private String cardNumber;\n    private String bankName;\n    public BankCard(String bankName, String cardNumber){\n        this.bankName = bankName;\n        this.cardNumber = cardNumber;\n    }\n    ...\n    getter、setter方法\n}", 
            "title": "数组"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_48", 
            "text": "给 Person 对象中的数组类型字段添加数据,有以下两种方式：", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#addaddall", 
            "text": "Person p = new Person();\np.setObjectId( d32143db92 );\n//添加String类型的数组\np.add( hobbys ,  唱歌 );                              // 添加单个String\n//p.addAll( hobbys , Arrays.asList( 游泳 ,  看书 ));    // 添加多个String\n//添加Object类型的数组\np.add( cards ,new BankCard( 工行卡 ,  工行卡账号 ))   //添加单个Object\nList BankCard  cards =new ArrayList BankCard ();\nfor(int i=0;i 2;i++){\n    cards.add(new BankCard( 建行卡 +i,  建行卡账号 +i));\n}\n//p.addAll( cards , cards);                         //添加多个Object值\np.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 保存成功 );\n        }else{\n            Log.i( bmob , 保存失败： +e.getMessage());\n        }\n    }\n\n});   注：此类方法不管这些数据之前是否已添加过，都会再次添加。", 
            "title": "使用add、addAll添加"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#adduniqueaddallunique", 
            "text": "Person p = new Person();\n//添加String类型的数组\np.addUnique( hobbys ,  唱歌 );                                // 添加单个String\n//p.addAllUnique( hobbys , Arrays.asList( 游泳 ,  看书 ));  // 添加多个String\n//添加Object类型的数组\np.addUnique( cards ,new BankCard( 工行卡 ,  工行卡账号 ))     //添加单个Object\nList BankCard  cards =new ArrayList BankCard ();\nfor(int i=0;i 2;i++){\n    cards.add(new BankCard( 建行卡 +i,  建行卡账号 +i));\n}\n//p.addAllUnique( cards , cards);                           //添加多个Object\np.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功: +objectId);\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});   注： 只有在这些数据之前未添加过的情况下才会被添加。", 
            "title": "使用addUnique、addAllUnique添加"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_49", 
            "text": "数组更新比较特殊，自 V3.4.4 版本开始提供 BmobObject 的 setValue 方法来更新数组，例：  Person p2 = new Person();\n//更新String类型数组中的值\np2.setValue( hobbys.0 , 爬山 );                             //将hobbys中第一个位置的爱好（上面添加成功的唱歌）修改为爬山\n//更新Object类型数组中的某个位置的对象值(0对应集合中第一个元素)\np2.setValue( cards.0 , new BankCard( 中行 ,  中行卡号 ));    //将cards中第一个位置银行卡修改为指定BankCard对象\n//更新Object类型数组中指定对象的指定字段的值\n//  p2.setValue( cards.0.bankName ,  农行卡 );             //将cards中第一个位置的银行卡名称修改为农行卡\n//  p2.setValue( cards.1.cardNumber ,  农行卡账号 );         //将cards中第二个位置的银行卡账号修改为农行卡账号\np2.update(objectId, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});", 
            "title": "更新数组数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_50", 
            "text": "同理我们也可以使用removeAll从数组字段中移除某些值：  Person p = new Person();\np.removeAll( hobby , Arrays.asList( 阅读 , 唱歌 , 游泳 ));\np.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_51", 
            "text": "对于字段类型为数组的情况，可以以数组字段中包含有xxx的数据为条件进行查询：  BmobQuery Person  query = new BmobQuery Person ();\nString [] hobby = { 阅读 , 唱歌 };\nquery.addWhereContainsAll( hobby , Arrays.asList(hobby));\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 查询成功：共  + object.size() +  条数据。 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});", 
            "title": "查询数组数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_52", 
            "text": "", 
            "title": "数据关联性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_53", 
            "text": "在程序设计中，不同类型的数据之间可能存在某种关系。\n比如：帖子和作者的关系，一篇帖子只属于某个作者，这是 一对一的关系 。\n比如：帖子和评论的关系，一条评论只属于某一篇帖子，而一篇帖子对应有很多条评论，这是 一对多的关系 。\n比如：学生和课程的关系，一个学生可以选择很多课程，一个课程也可以被很多学生所选择，这是 多对多的关系 。  Bmob提供了 Pointer（一对一、一对多） 和 Relation（多对多） 两种数据类型来解决这种业务需求。", 
            "title": "关联关系描述"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_54", 
            "text": "由于关联关系讲解起来比较复杂，以下用一个简单的案例来说明在Bmob中是如何使用关联关系的。  场景： 用户发表帖子，同时又可对帖子进行评论留言。  在这个场景中涉及到三个表：用户表（ _User ）、帖子表（ Post ）、评论表（ Comment ）,以下是各个表的字段：  _User 字段如下：     字段  类型  含义      objectId  String  用户ID    username  String  用户名(可以既发帖子又发评论)    age  Integer  年龄     Post 字段如下：     字段  含义  类型      objectId  String  帖子ID    title  String  帖子标题    content  String  帖子内容    author  Pointer  帖子作者    likes  Relation  喜欢帖子的读者     Comment 字段如下：     字段  含义  类型      objectId  String  评论ID    content  String  评论内容    post  Pointer  评论对应的帖子    author  Pointer  评论该帖子的人", 
            "title": "关联关系案例详解"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#web", 
            "text": "如果你需要在Web端创建上述表的话，那么当选择的字段类型为 Pointer或Relation 时，会提示你选择该字段所指向或关联的数据表。  如下图所示：", 
            "title": "Web端创建关联字段"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_55", 
            "text": "public class MyUser extends BmobUser {\n\n    private Integer age;//为用户表新增一个age字段，注意其必须为`Integer`类型，而不是int\n\n    //自行实现getter和setter方法\n}  1、扩展BmobUser的时，不需要再加上 objectId、username、password、createAt、updateAt 等系统字段，因为BmobUser中已经实现了，如果再次声明的话，会导致编译性的错误。  2、类名可以自定义，这个跟其他表的命名方式有所不同。  \npublic class Post extends BmobObject {\n\n    private String title;//帖子标题\n\n    private String content;// 帖子内容\n\n    private MyUser author;//帖子的发布者，这里体现的是一对一的关系，该帖子属于某个用户\n\n    private BmobFile image;//帖子图片\n\n    private BmobRelation likes;//多对多关系：用于存储喜欢该帖子的所有用户\n\n    //自行实现getter和setter方法\n\n}  \npublic class Comment extends BmobObject {\n\n    private String content;//评论内容  \n\n    private MyUser user;//评论的用户，Pointer类型，一对一关系\n\n    private Post post; //所评论的帖子，这里体现的是一对多的关系，一个评论只能属于一个微博\n\n    //自行实现getter和setter方法\n}  注：  1、类名要和数据表名保持一致。  2、MyUser属性对应为Pointer的指针类型。  以下举例均假定A用户已注册并登陆", 
            "title": "创建数据对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_56", 
            "text": "用户发表帖子，一篇帖子也只能属于某个用户，那么帖子和用户之间的关系是 一对一关系 ，建议使用 Pointer 类型来表示。  Pointer 本质上可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针来获得其指向的关联对象。  用户A写了一篇帖子，需要在 Post 表中生成一条记录，并将该帖子关联到用户A这条记录，表明该帖子是A所发表的。  示例如下：", 
            "title": "一对一关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_57", 
            "text": "MyUser user = BmobUser.getCurrentUser(MyUser.class);\n// 创建帖子信息\nPost post = new Post();\npost.setContent(content);\n//添加一对一关联\npost.setAuthor(user);\npost.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 保存成功 );\n        }else{\n            Log.i( bmob , 保存失败： +e.getMessage());\n        }\n    }\n});  添加成功后，在后台的 Post 表中，你就会看到有一条记录生成，并且该帖子的 author 字段的值指向了 _User 表中的 用户A 这条记录。", 
            "title": "添加一对一关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_58", 
            "text": "如果想查询 用户A (当前用户)所发表的所有帖子，那么可以这样：  MyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobQuery Post  query = new BmobQuery Post ();\nquery.addWhereEqualTo( author , user);  // 查询当前用户的所有帖子\nquery.order( -updatedAt );\nquery.include( author );// 希望在查询帖子信息的同时也把发布人的信息查询出来\nquery.findObjects(new FindListener Post () {\n\n    @Override\n    public void done(List Post  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  注：如果想查询某个用户所发表的所有帖子，则将该用户查询出来，然后使用上述代码查询指定用户所发表的所有帖子。", 
            "title": "查询一对一关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_59", 
            "text": "如果希望将刚刚这条帖子的作者修改成 用户B ,示例：  Post p = new Post();\n//构造用户B，如果你知道用户B的objectId的话，可以使用这种方式进行关联，如果不知道的话，你需要将用户B查询出来\n// 这里假设已知用户B的objectId为aJyG2224\nMyUser userB =new MyUser();\nuserB.setObjectId( aJyG2224 );\np.setAuthor(userB);//重新设置帖子作者\np.update( ESIt3334 , new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  修改成功后，在后台可查看到这个帖子的作者已经变更为用户B", 
            "title": "更新一对一关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_60", 
            "text": "如果你想和 ESIt3334 这个帖子解除关联关系，可以这样：  Post p = new Post();\np.remove( author );\np.update( ESIt3334 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});  删除成功后，在后台的 Post 表中，你就会看到 ESIt3334 这个帖子的 author 字段的值已经被置空了。", 
            "title": "删除一对一关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_61", 
            "text": "一条评论只能属于某一篇帖子，一篇帖子可以有很多用户对其进行评论，那么帖子和评论之间的关系就是 一对多关系 ，推荐使用 pointer 类型来表示 。  因为使用方法和上面的一对一关联基本相同，只是查询一对多关联的时候有些区别，故只举添加和查询两个例子：", 
            "title": "一对多关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_62", 
            "text": "将评论和微博进行关联，并同时和当前用户进行关联，表明是当前用户对该帖子进行评论，示例如下：  MyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId( ESIt3334 );\nfinal Comment comment = new Comment();\ncomment.setContent(content);\ncomment.setPost(post);\ncomment.setUser(user);\ncomment.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 评论发表成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});", 
            "title": "添加一对多关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_63", 
            "text": "我想 查询出某个帖子（objectId为ESIt3334）的所有评论,同时将该评论的作者的信息也查询出来 ，那么可以使用 addWhereEqualTo 方法进行查询：  BmobQuery Comment  query = new BmobQuery Comment ();\n//用此方式可以构造一个BmobPointer对象。只需要设置objectId就行\nPost post = new Post();\npost.setObjectId( ESIt3334 );\nquery.addWhereEqualTo( post ,new BmobPointer(post));        \n//希望同时查询该评论的发布者的信息，以及该帖子的作者的信息，这里用到上面`include`的并列对象查询和内嵌对象的查询\nquery.include( user,post.author );\nquery.findObjects(new FindListener Comment () {\n\n    @Override\n    public void done(List Comment  objects,BmobException e) {\n        ...\n    }\n});  注： addWhereEqualTo 对 BmobPonter 类型的一对多的关联查询是 BmobSDKV3.3.8 开始支持的，因此使用时，请更新SDK版本。", 
            "title": "查询一对多关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_64", 
            "text": "一个帖子可以被很多用户所喜欢，一个用户也可能会喜欢很多帖子，那么可以使用 Relation 类型来表示这种 多对多关联关系 。  Relation 本质上可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。", 
            "title": "多对多关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_65", 
            "text": "MyUser user = BmobUser.getCurrentUser(MyUser.class);\nPost post = new Post();\npost.setObjectId( ESIt3334 );\n//将当前用户添加到Post表中的likes字段值中，表明当前用户喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//将当前用户添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 多对多关联添加成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  添加成功后，在后台的 Post 表中就能查看到 likes 字段已经生成并对应到了 _User   点击红框中的 关联关系 按钮展开后，可查看刚才所添加的喜欢该帖子的用户A：", 
            "title": "添加多对多关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_66", 
            "text": "如果希望 查询喜欢该帖子（objectId为ESIt3334）的所有用户 ,那么就需要用到 addWhereRelatedTo 方法进行多对多关联查询。  示例代码：  // 查询喜欢这个帖子的所有用户，因此查询的是用户表\nBmobQuery MyUser  query = new BmobQuery MyUser ();\nPost post = new Post();\npost.setObjectId( ESIt3334 );\n//likes是Post表中的字段，用来存储所有喜欢该帖子的用户\nquery.addWhereRelatedTo( likes , new BmobPointer(post));    \nquery.findObjects(new FindListener MyUser () {\n\n    @Override\n    public void done(List MyUser  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 查询个数： +object.size());\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});", 
            "title": "查询多对多关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_67", 
            "text": "如果 用户B也喜欢该帖子（objectId为ESIt3334） ，此时需要为该帖子(Post)的 likes 字段多添加一个用户,示例如下：  Post post = new Post();\npost.setObjectId( ESIt3334 );\n//将用户B添加到Post表中的likes字段值中，表明用户B喜欢该帖子\nBmobRelation relation = new BmobRelation();\n//构造用户B\nMyUser user = new MyUser();\nuser.setObjectId( aJyG2224 );\n//将用户B添加到多对多关联中\nrelation.add(user);\n//多对多关联指向`post`的`likes`字段\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 用户B和该帖子关联成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  修改成功后，你在点击该帖子的 likes 字段下面的 关联关系 按钮展开后，可查看刚才所添加的喜欢该帖子的用户B：", 
            "title": "修改多对多关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_68", 
            "text": "如果 想对该帖子进行取消喜欢的操作 ，此时，需要删除之前的多对多关联，具体代码：  Post post = new Post();\npost.setObjectId( 83ce274594 );\nMyUser user = BmobUser.getCurrentUser(MyUser.class);\nBmobRelation relation = new BmobRelation();\nrelation.remove(user);\npost.setLikes(relation);\npost.update(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            Log.i( bmob , 关联关系删除成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n\n});  1 例子中的Comment和Post表请大家注意下在后端控制台建表的数据类型是Pointer还是Relation 否则返回类型不匹配的111错误，表的结构和字段类型如下：    2 为方便大家了解学习，我们提供了一个关于数据关联的Demo，下载地址是：https://github.com/bmob/RelationDemo", 
            "title": "删除多对多关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#include", 
            "text": "在某些情况下，你想在一个查询内获取 Pointer 类型的关联对象。  比如上述示例中，如果希望在查询帖子信息的同时也把该帖子的作者的信息查询出来，可以使用 include 方法  query.include( author );  你可以使用 , 号(逗号)操作符来 include并列查询 两个对象  比如，查询评论表的同时将该评论用户的信息和所评论的帖子信息也一并查询出来（因为Comment表有两个 Pointer类型 的字段），那么可以这样做：  query.include( user,post );  但不能如下的做法：  query.include( user );\nquery.include( post );  你同时还可以使用  . 号（英语句号）操作符来进行 include中的内嵌对象查询  比如，你想在查询评论信息的同时将该评论 Comment 对应的帖子 post 以及该帖子的作者信息 author 一并查询出来，你可以这样做：  query.include( post.author );  另外，include还可以指定返回的字段：  query.include( post[likes].author[username|email] );  其中，post和author都是Pointer类型，post指向的表只返回likes字段，author指向的表只返回username和email字段。  注：include的查询对象只能为BmobPointer类型，而不能是BmobRelation类型。", 
            "title": "include用法"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_69", 
            "text": "如果你在查询某个对象列表时，它们的某个字段是BmobObject类型，并且这个BmobObject匹配一个不同的查询，这种情况下可使用 addWhereMatchesQuery 方法。  请注意，默认的 limit 限制 100 也同样作用在内部查询上。因此如果是大规模的数据查询，你可能需要仔细构造你的查询对象来获取想要的行为。  例如： 查询带有图片的帖子的评论列表 :  BmobQuery Comment  query = new BmobQuery Comment ();\nBmobQuery Post  innerQuery = new BmobQuery Post ();\ninnerQuery.addWhereExists( image , true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用 Post 字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery( post ,  Post , innerQuery);\nquery.findObjects(new FindListener Comment () {\n\n    @Override\n    public void done(List Comment  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});  反之，不想匹配某个子查询，你可以使用 addWhereDoesNotMatchQuery 方法。   比如 查询不带图片的帖子的评论列表 ：  BmobQuery Comment  query = new BmobQuery Comment ();\nBmobQuery Post  innerQuery = new BmobQuery Post ();\ninnerQuery.addWhereExists( image , true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用 Post 字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereDoesNotMatchQuery( post ,  Post , innerQuery);\nquery.findObjects(new FindListener Comment () {\n    @Override\n    public void done(List Comment  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});  注：  当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线 _ 。  比如，你想查询出用户 smile 和 smile 好友的所有帖子，则可以这样：  \nBmobQuery User  innerQuery = new BmobQuery User ();\nString[] friendIds={ ssss , aaaa };//好友的objectId数组\ninnerQuery.addWhereContainedIn( objectId , Arrays.asList(friendIds));\n//查询帖子\nBmobQuery Post  query = new BmobQuery Post ();\n`query.addWhereMatchesQuery( author ,  _User , innerQuery);`\nquery.findObjects(new FindListener Post () {\n    @Override\n    public void done(List Post  object,BmobException e) {\n        if(e==null){\n            Log.i( bmob , 成功 );\n        }else{\n            Log.i( bmob , 失败： +e.getMessage());\n        }\n    }\n});", 
            "title": "内部查询"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_70", 
            "text": "用户是一个应用程序的核心。对于个人开发者来说，自己的应用程序积累到越多的用户，就会给自己带来越强的创作动力。因此Bmob提供了一个专门的用户类——BmobUser来自动处理用户账户管理所需的功能。  有了这个类，你就可以在你的应用程序中添加用户账户功能。  BmobUser是BmobObject的一个子类，它继承了BmobObject所有的方法，具有BmobObject相同的功能。不同的是，BmobUser增加了一些特定的关于用户账户管理相关的功能。", 
            "title": "用户管理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_71", 
            "text": "BmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\nusername: 用户的用户名 （必需） 。\npassword: 用户的密码 （必需） 。\nemail: 用户的电子邮件地址 （可选） 。\nemailVerified:邮箱认证状态 （可选） 。\nmobilePhoneNumber：手机号码 （可选） 。\nmobilePhoneNumberVerified：手机号码的认证状态 （可选） 。", 
            "title": "属性"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_72", 
            "text": "很多时候，你的用户表还会有很多其他字段，如性别、年龄、头像等。那么，你需要对BmobUser类进行扩展，添加一些新的属性。示例代码如下所示：  public class MyUser extends BmobUser {\n\n    private Boolean sex;\n    private String nick;\n    private Integer age;\n\n    public boolean getSex() {\n        return this.sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getNick() {\n        return this.nick;\n    }\n\n    public void setNick(String nick) {\n        this.nick = nick;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}  更多代码实现大家可以下载SDK，在里面的 BmobExample 中查找 MyUser 类，参考它的用法。", 
            "title": "扩展用户类"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_73", 
            "text": "创建用户对象如下：  BmobUser user = new BmobUser();", 
            "title": "创建用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_74", 
            "text": "你的应用程序可能会要求用户注册。下面的代码是一个典型的注册过程：  BmobUser bu = new BmobUser();\nbu.setUsername( sendi );\nbu.setPassword( 123456 );\nbu.setEmail( sendi@163.com );\n//注意：不能用save方法进行注册\nbu.signUp(new SaveListener MyUser () {\n    @Override\n    public void done(MyUser s, BmobException e) {\n        if(e==null){\n            toast( 注册成功:  +s.toString());\n        }else{\n            loge(e);\n        }\n    }\n});  在注册过程中，服务器会对注册用户信息进行检查，以确保注册的用户名和电子邮件地址是独一无二的。此外，对于用户的密码，你可以在应用程序中进行相应的加密处理后提交。  如果注册不成功，你可以查看返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册。这种情况你可以提示用户，要求他们尝试使用不同的用户名进行注册。  你也可以要求用户使用Email做为用户名注册，这样做的好处是，你在提交信息的时候可以将输入的“用户名“默认设置为用户的Email地址，以后在用户忘记密码的情况下可以使用Bmob提供重置密码功能。  注：   有些时候你可能需要在用户注册时发送一封验证邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在注册时自动发动一封验证给用户。     username字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。", 
            "title": "注册"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_75", 
            "text": "当用户注册成功后，您需要让他们以后能够用注册的用户名登录到他们的账户使用应用。要做到这一点，你可以使用BmobUser类的login方法。  BmobUser bu2 = new BmobUser();\nbu2.setUsername( lucky );\nbu2.setPassword( 123456 );\nbu2.login(new SaveListener BmobUser () {\n\n    @Override\n    public void done(BmobUser bmobUser, BmobException e) {\n        if(e==null){\n            toast( 登录成功: );\n            //通过BmobUser user = BmobUser.getCurrentUser()获取登录成功后的本地用户信息\n            //如果是自定义用户对象MyUser，可通过MyUser user = BmobUser.getCurrentUser(MyUser.class)获取自定义用户信息\n        }else{\n            loge(e);\n        }\n    }\n});  也可使用如下方式完成 用户名+密码 的登录：  BmobUser.loginByAccount( username ,  用户密码 , new LogInListener MyUser () {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i( smile , 用户登陆成功 );\n                }\n            }\n        });", 
            "title": "登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_76", 
            "text": "如果用户在每次打开你的应用程序时都要登录，这将会直接影响到你应用的用户体验。为了避免这种情况，你可以使用缓存的CurrentUser对象。缓存的用户有效期为1年。  每当你应用的用户注册成功或是第一次登录成功，都会在本地磁盘中有一个缓存的用户对象，这样，你可以通过获取这个缓存的用户对象来进行登录：  BmobUser bmobUser = BmobUser.getCurrentUser();\nif(bmobUser != null){\n    // 允许用户使用应用\n}else{\n    //缓存用户对象为空时， 可打开用户注册界面…\n}  在扩展了用户类的情况下获取当前登录用户，可以使用如下的示例代码（ MyUser 类可参看上面）：  MyUser userInfo = BmobUser.getCurrentUser(MyUser.class);  自 V3.4.5 版本开始，SDK新增了 getObjectByKey(context,key) 方法从本地缓存中获取当前登陆用户某一列的值。其中 key 为用户表的指定列名。  //BmobUser中的特定属性\nString username = (String) BmobUser.getObjectByKey( username );\n//MyUser中的扩展属性\nInteger age = (Integer) BmobUser.getObjectByKey( age );\nBoolean sex = (Boolean) BmobUser.getObjectByKey( sex );", 
            "title": "当前用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_77", 
            "text": "很多情况下你可能需要修改用户信息，比如你的应用具备修改个人资料的功能，Bmob提供的用户更新方式有两种写法：  第一种： 新建一个用户对象，并调用update(objectId,updateListener)方法来更新（推荐使用） ，示例：  BmobUser newUser = new BmobUser();\nnewUser.setEmail( xxx@163.com );\nBmobUser bmobUser = BmobUser.getCurrentUser(context);\nnewUser.update(bmobUser.getObjectId(),new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 更新用户信息成功 );\n        }else{\n            toast( 更新用户信息失败:  + e.getMessage());\n        }\n    }\n});  第二种：获取本地的用户对象，并调用update（updateListener）方法来更新（ 不推荐使用 ），示例：  BmobUser bmobUser = BmobUser.getCurrentUser();\n// 修改用户的邮箱为xxx@163.com\nbmobUser.setEmail( xxx@163.com );\nbmobUser.update(new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 更新用户信息成功 );\n        }else{\n            toast( 更新用户信息失败:  + e.getMessage());\n        }\n    }\n});  1、开发者在进行用户更新操作的时候，推荐使用 第一种 方式来进行用户的更新操作,因为此方法只会更新你提交的用户信息（比如只会向服务器提交当前用户的email值），而不会将本地存储的用户信息也提交到后台更新。  2、在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发一封邮件验证信息给用户。  3、需要先登录后才能更新用户信息 否则会返回206 User cannot be altered without sessionToken Error错误。", 
            "title": "更新用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_78", 
            "text": "查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：  BmobQuery BmobUser  query = new BmobQuery BmobUser ();\nquery.addWhereEqualTo( username ,  lucky );\nquery.findObjects(new FindListener BmobUser () {\n    @Override\n    public void done(List BmobUser  object,BmobException e) {\n        if(e==null){\n            toast( 查询用户成功: +object.size());\n        }else{\n            toast( 更新用户信息失败:  + e.getMessage());\n        }\n    }\n});  浏览器中查看用户表  User表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。", 
            "title": "查询用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_79", 
            "text": "退出登录非常简单，可以使用如下的代码：  BmobUser.logOut();   //清除缓存用户对象\nBmobUser currentUser = BmobUser.getCurrentUser(); // 现在的currentUser是null了", 
            "title": "退出登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_80", 
            "text": "自 V3.4.3 版本开始，SDK为开发者提供了直接修改当前用户登录密码的方法，只需要传入旧密码和新密码，然后调用 BmobUser 提供的静态方法 updateCurrentUserPassword 即可，以下是示例：  BmobUser.updateCurrentUserPassword( 旧密码 ,  新密码 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 密码修改成功，可以用新密码进行登录啦 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "密码修改"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_81", 
            "text": "", 
            "title": "邮箱"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_82", 
            "text": "新增 邮箱+密码 登录方式,可以通过 loginByAccount 方法来操作：  BmobUser.loginByAccount(account, password, new LogInListener MyUser () {\n\n            @Override\n            public void done(MyUser user, BmobException e) {\n                if(user!=null){\n                    Log.i( smile , 用户登陆成功 );\n                }\n            }\n        });", 
            "title": "邮箱登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_83", 
            "text": "设置邮件验证是一个可选的应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会被默认设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  emailVerified 字段有 3 种状态可以考虑：   true : 用户可以点击邮件中的链接通过Bmob来验证地址，一个用户永远不会在新创建这个值的时候显示emailVerified为true。  false : 用户(User)对象最后一次被刷新的时候, 用户并没有确认过他的邮箱地址, 如果你看到emailVerified为false的话，你可以考虑刷新用户(User)对象。  missing : 用户(User)对象已经被创建，但应用设置并没有开启邮件验证功能； 或者用户(User)对象没有email邮箱。", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#email", 
            "text": "发送给用户的邮箱验证邮件会在一周内失效，可以通过调用  requestEmailVerify  来强制重新发送：  final String email =  xxx@qq.com ;\nBmobUser.requestEmailVerify(email, new UpdateListener() {\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 请求验证邮件成功，请到  + email +  邮箱中进行激活。 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n});", 
            "title": "请求验证Email"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_84", 
            "text": "开发者只需要求用户输入注册时的电子邮件地址即可：  final String email =  xxx@163.com ;\nBmobUser.resetPasswordByEmail(email, new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 重置密码请求成功，请到  + email +  邮箱进行密码重置操作 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n});  邮箱重置密码的流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置链接的电子邮件。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示他们可以输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "邮箱重置密码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_85", 
            "text": "", 
            "title": "手机号相关功能"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_86", 
            "text": "在手机号码被验证后，用户可以使用该手机号码进行登录操作。  手机号码登录包括两种方式： 手机号码＋密码 、 手机号码＋短信验证码 。", 
            "title": "手机号码登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_87", 
            "text": "BmobUser.loginByAccount( 11位手机号码 ,  用户密码 , new LogInListener MyUser () {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i( smile , 用户登陆成功 );\n        }\n    }\n});", 
            "title": "手机号码+密码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_88", 
            "text": "先请求登录的短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 , 模板名称 , new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于后续的查询本次短信发送状态\n        }\n    }\n});  最后调用 loginBySMSCode 方法进行手机号码登录:  BmobUser.loginBySMSCode( 11位手机号码 , code, new LogInListener MyUser () {\n\n        @Override\n        public void done(MyUser user, BmobException e) {\n            if(user!=null){\n                Log.i( smile , 用户登陆成功 );\n            }\n        }\n    });\n}", 
            "title": "手机号码+短信验证码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_89", 
            "text": "Bmob同样支持手机号码一键注册或登录，以下是一键登录的流程：  1、请求登录操作的短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 , 模板名称 , new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n    });  2、用户收到短信验证码之后，就可以调用 signOrLoginByMobilePhone 方法来实现一键登录:  BmobUser.signOrLoginByMobilePhone( 11位手机号码 ,  验证码 , new LogInListener MyUser () {\n\n    @Override\n    public void done(MyUser user, BmobException e) {\n        if(user!=null){\n            Log.i( smile , 用户登陆成功 );\n        }\n    }\n});  如果，你想在一键注册或登录的同时保存其他字段的数据的时，你可以使用 signOrLogin 方法（此方法 V3.4.3 版本提供）。  比如，你想在手机号码注册或登录的同时，设置用户名及登录密码等信息，那么具体示例如下：  \nMyUser user = new MyUser();\nuser.setMobilePhoneNumber( 11位手机号码 );//设置手机号码（必填）\nuser.setUsername(xxx);                  //设置用户名，如果没有传用户名，则默认为手机号码\nuser.setPassword(xxx);                  //设置用户密码\nuser.setAge(18);                        //设置额外信息：此处为年龄\nuser.signOrLogin( 验证码 , new SaveListener MyUser () {\n\n    @Override\n    public void done(MyUser user,BmobException e) {\n        if(e==null){\n            toast( 注册或登录成功 );\n            Log.i( smile ,  +user.getUsername()+ - +user.getAge()+ - +user.getObjectId());\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n\n    }\n\n});", 
            "title": "手机号码一键注册或登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_90", 
            "text": "如果已有用户系统，需要为用户绑定手机号，那么官方推荐的绑定流程如下：  第一步、先发送短信验证码并验证验证码的有效性,即调用 requestSMSCode 发送短信验证码，调用 verifySmsCode 来验证有效性。  第二步、在验证成功之后更新当前用户的 MobilePhoneNumber 和 MobilePhoneNumberVerified 两个字段，具体绑定示例如下：  User user =new User();\nuser.setMobilePhoneNumber(phone);\nuser.setMobilePhoneNumberVerified(true);\nUser cur = BmobUser.getCurrentUser(User.class);\nuser.update(cur.getObjectId(),new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 手机号码绑定成功 );\n        }else{\n            toast( 失败:  + e.getMessage());\n        }\n    }\n});", 
            "title": "绑定手机号码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_91", 
            "text": "Bmob自 V3.3.9 版本开始引入了短信验证系统，如果用户已经验证过手机号码或者使用过手机号码注册或登录过，也可以通过手机号码来重置用户密码，以下是官方建议使用的重置流程：  1、请求重置密码操作的短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 , 模板名称 , new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n    });  2、用户收到重置密码的验证码之后，就可以调用 resetPasswordBySMSCode 方法来实现密码重置:  BmobUser.resetPasswordBySMSCode(code, 1234567 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){\n            Log.i( smile ,  密码重置成功 );\n        }else{\n            Log.i( smile ,  重置失败：code = +ex.getErrorCode()+ ,msg =  +ex.getLocalizedMessage());\n        }\n    }\n});  重置成功以后，用户就可以使用新密码登陆了。  注：  1、请开发者按照官方推荐的操作流程来完成重置密码操作。也就是说，开发者在进行重置密码操作时，无需调用 verifySmsCode 接口去验证该验证码的有效性。  2、验证码只能使用一次，一旦该验证码被使用就会失效，那么再拿失效的验证码去调用重置密码接口，一定会报 207-验证码错误 。因为重置密码接口已经包含验证码的有效性验证。", 
            "title": "手机号码重置密码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_92", 
            "text": "", 
            "title": "手机号码验证"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_93", 
            "text": "Bmob自 V3.3.9 版本开始引入了短信验证系统，可通过 requestSMSCode 方式请求发送短信验证码：  BmobSMS.requestSMSCode( 11位手机号码 ,  模板名称 ,new QueryListener Integer () {\n\n    @Override\n    public void done(Integer smsId,BmobException ex) {\n        if(ex==null){//验证码发送成功\n            Log.i( smile ,  短信id： +smsId);//用于查询本次短信发送详情\n        }\n    }\n});  短信默认模板：  \n    您的验证码是`%smscode%`，有效期为`%ttl%`分钟。您正在使用`%appname%`的验证码。【比目科技】  注：  1、 模板名称 ：模板名称需要开发者在应用的管理后台进行短信模板的添加工作，具体： 短信服务 - 短信模板 ,之后点击创建即可。  具体请看下图：   2、只有审核通过之后的自定义短信模板才可以被使用，如果自定义的短信模板其状态显示 审核中 或者 审核失败 ,再调用该方法则会以 默认模板 来发送验证码。  3、开发者提交短信验证码模板时需注意以下几点：  1）、模板中不能有【】和 [] ，否则审核不通过；  2）、如果你提交的短信模板无法发送，则有可能包含一些敏感监控词，具体可去Github下载   短信关键字监控参考文档   来查看提交内容是否合法。  3）、一天一个应用给同一手机号发送的短信不能超过10条，否则会报 10010 错误，其他错误码可查看   短信功能相关错误码  。", 
            "title": "请求发送短信验证码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_94", 
            "text": "通过 verifySmsCode 方式可验证该短信验证码：  BmobSMS.verifySmsCode( 11位手机号码 ,  验证码 , new UpdateListener() {\n\n    @Override\n    public void done(BmobException ex) {\n        if(ex==null){//短信验证码已验证成功\n            Log.i( smile ,  验证通过 );\n        }else{\n            Log.i( smile ,  验证失败：code = +ex.getErrorCode()+ ,msg =  +ex.getLocalizedMessage());\n        }\n    }\n});  验证成功后，用户的 mobilePhoneVerified 属性会自动变为 true 。", 
            "title": "验证验证码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_95", 
            "text": "通过 querySmsState 方式可查询指定 smsId 的发送状态：  \nBmobSMS.querySmsState(smsId, new QueryListener BmobSmsState () {\n\n            @Override\n            public void done(SmsState state, BmobException ex) {\n                if(ex==null){\n                    Log.i( smile , 短信状态： +state.getSmsState()+ ,验证状态： +state.getVerifyState());\n                }\n            }\n        });  注： SmsState 包含两种状态：  1、 smsState （短信状态）   :SUCCESS（发送成功）、FAIL（发送失败）、SENDING(发送中)。  2、 verifyState （验证状态）:true(已验证)、false(未验证)。  注意事项：  关于短信条数的计算规则如下:   实际计算的短信字数 = 模板的内容或自定义短信的内容字数 + 6。加上6是因为默认的签名【比目科技】占了6个字。  实际计算的短信字数在70个字以下算1条。  实际计算的短信字数超过70字的以67字为一条来计算的。也就是135个字数是计算为3条的。  计算得到的短信条数在本条短信发送成功后将会从你的账户剩余的短信条数中扣除。   短信发送限制规则是1/分钟，5/小时，10/天。即对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条。", 
            "title": "查询短信发送状态"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_96", 
            "text": "为了方便大家，官方提供了一个短信验证的demo： https://github.com/bmob/bmob_android_demo_sms  。  此案例包含了： 用户名/邮箱/手机号码+密码登录 、 手机号码一键注册登录 、 绑定手机号 以及 通过手机号重置用户密码 。", 
            "title": "短信验证案例"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_97", 
            "text": "Bmob提供了非常简单的方法来实现第三方账号登陆的功能，目前支持 新浪微博 、 QQ账号 、 微信账号 的登陆。  自 BmobV3.3.9 版本开始，为了与第三方开放平台的SDK解藕，Bmob使用了全新的第三方账号登录方式，之前的微博和qq登录方式的API已删除。", 
            "title": "第三方账号登陆"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_98", 
            "text": "第三方账号登陆目前适应以下两种应用场景：  一、没有Bmob账号，希望使用第三方账号一键注册或登陆Bmob账号  如果开发者希望用户使用第三方平台的账号注册或登录Bmob的用户体系，则推荐的步骤如下：  1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息  2、调用Bmob提供的 loginWithAuthData（BmobV3.3.9版本提供） 方法，并自行构造 BmobThirdUserAuth（第三方授权信息） 对象，调用成功后，在Bmob的User表中会产生一条记录。  二、已有Bmob账号，希望与第三方账号进行关联  如果已使用Bmob的用户体系（假设用户A已登录），希望和第三方平台进行关联，则推荐的步骤如下：  1、第三方平台授权，开发者需自行根据第三方平台文档提出的授权方法完成账号授权并得到授权信息  2、调用 associateWithAuthData 方法，并自行构造 BmobThirdUserAuth(第三方授权信息) 对象，调用成功后，你就会在后台的用户A的authData这个字段下面看到提交的授权信息。", 
            "title": "应用场景"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_99", 
            "text": "为了方便开发者完成授权，现整理各个平台的需要查阅的文档：", 
            "title": "相关文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_100", 
            "text": "1、 移动客户端接入文档 ：此文档请着重查阅其中的 SDK接入流程 。  2、 新浪微博AndroidSDK快速入门 ，请详细查看 README 文档,其介绍了完整的集成流程。  3、 新浪微博常见问题 ：在新浪微博授权过程中出现问题，请查看此文档，一般出现频率较高的错误有：  sso package and sign error - 平台上填写的包名和签名不正确。请仔细检查，一般最需要检查的是 签名 ，签名需要使用微博提供的获取签名的工具 （app_signatures.apk） 。  redirect_uri_mismatch      - 请确保你在weibo平台上填写的授权回调地址与代码中写的授权回调地址(RedirectURI)一样。", 
            "title": "微博登陆相关文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#qq", 
            "text": "1、如何使用SDK，请参见  腾讯开放平台Android_SDK使用说明 。  2、如何调用具体API，请参见  API调用说明 。  3、常见问题汇总，请参见 问题汇总说明 。", 
            "title": "QQ登陆相关文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_101", 
            "text": "1、 Android接入指南 ：这里主要介绍的是微信sdk的集成步骤  2、 微信登陆开发指南 ：在 移动应用开发 - 微信登录功能 - 移动应用微信登录开发指南 。主要介绍微信OAuth2.0授权登录的流程。  注：  三者当中较麻烦的是微信登陆的授权，因此，在此简单说明下可能遇见的问题：  1、在微信登陆过程中出现了问题，请仔细注意以下几点：  1）、需要在微信开放平台上填写你的 应用信息、包名和签名 ；\n2）、微信登陆不同于QQ或微博登陆，应用需要 提交微信官方审核 ，只有审核通过后才能打开授权界面；\n3）、建议 导出正式签名的apk来测试 ，不建议直接run debug版本的apk；\n4）、检查 签名是否正确 、检查 传递的参数是否正确 。  2、微信登陆的测试相对比较麻烦，如果开发者希望直接能够进行调试，建议使用微信官方demo中的 debug keystore 。具体使用步骤：  1)、Eclipse中选择 Window- Preferences- Android- Build ;  2)、在Build页有个 Custom debug keystore 选项,然后点击 Browse ,选择微信官方demo中的 debug keystore 文件即可。  之后重新运行应用时会使用该 debug keystore 文件对应用进行Debug签名。  不要忘了在微信后台重新填写通过微信签名工具获得的该调试应用的签名 。", 
            "title": "微信登陆相关文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_102", 
            "text": "假设你已通过上述提供的文档完成相应平台的授权并得到对应的授权信息，则可以这样来完成一键注册或登陆操作：      BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn,userId);\n    BmobUser.loginWithAuthData(authInfo, new LogInListener JSONObject () {\n\n        @Override\n        public void done(JSONObject userAuth,BmobException e) {\n            ...\n        }\n    });           注：  BmobThirdUserAuth 的各参数解释：  1、 snsType :只能是三种取值中的一种： weibo、qq、weixin  2、 accessToken ：接口调用凭证  3、 expiresIn ：access_token的有效时间  4、 userId :用户身份的唯一标识，对应微博授权信息中的 uid ,对应qq和微信授权信息中的 openid", 
            "title": "第三方账号一键注册或登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_103", 
            "text": "", 
            "title": "关联第三方账号"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_104", 
            "text": "BmobThirdUserAuth authInfo = new BmobThirdUserAuth(snsType,accessToken, expiresIn, userId);\n    BmobUser.associateWithAuthData(authInfo, new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i( bmob , 关联成功 );\n            }else{\n                Log.i( bmob , 关联失败：code =  + e.getErrorCode() +  ,msg =   + e.getMessage());\n            }\n\n        }\n    });", 
            "title": "账号关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_105", 
            "text": "BmobUser.dissociateAuthData(snsType,new UpdateListener() {\n\n        @Override\n        public void done(BmobException e) {\n            if(e==null){\n                Log.i( bmob , 取消 +snsType+ 关联成功 );\n            }else{\n                int code =e.getErrorCode(); \n                if (code == 208) {// 208错误指的是没有绑定相应账户的授权信息\n                    Log.i( smile , 你没有关联该账号 );\n                } else {\n                    Log.i( smile , 取消 +snsType+ 关联失败：code =  + code +  ,msg =   + e.getMessage());\n                }\n            }\n        }\n});", 
            "title": "解除关联"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_106", 
            "text": "具体案例可参考我们Github上的demo： https://github.com/bmob/bmob-android-demo-thirdpartylogin  ,这个源码包含了第三方登录的源码和登录之后如何获取用户基本信息的部分。", 
            "title": "第三方登录的案例源码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_107", 
            "text": "BmobFile 可以让你的应用程序将文件存储到服务器中，常见的文件类型都可以实现存储：比如图像文件、影像文件、音乐文件和任何其他二进制数据。  注：  1、以下均为SDK对文件进行操作的方法，如果你想在Web端对文件进行操作，请查看我们的帮助文档： 如何在Web后台上传文件  2、自  BmobSDKv3.4.6  开始，文件服务需要注意以下几个方面：    SDK内部集成CDN文件服务，删除 BmobProFile 的相关代码，并不再提供新旧文件管理的功能，但上传的方法名不变 ；    新增了文件下载 (download) 和批量删除CDN文件 (deleteBatch) 的方法 ；    2016年7月,旧版SDK中的新旧文件管理的上传方法将停止服务，之前通过旧版SDK中的新旧文件管理上传的文件仍可下载，请大家及时更新SDK ；    之前使用了 BmobProFile中 的 upload 方法上传的文件，开发者可以直接在文件的url地址后面增加：\"?t=2 a=\"+ 你的accessKey，那么拼接后的文件是可以直接用来访问并下载的。 ；        举个例子：\n\n    如果之前通过新版文件管理的上传方法得到的文件url地址：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png，\n\n    那么签名后的可访问的文件地址为：\n    http://newfile.codenow.cn:8080/a272a1aac5274f7085f140de9db94635.png?t=2 a=你的accessKey。   无法查看accessKey 。因为已经废除新旧文件管理功能，所以在开发者管理后台的设置-- 应用密钥中已无法查看accessKey，而之前开发者所使用的accessKey继续有效。   3、CDN文件服务需要 okhttp-2.4.0、okio-1.4.0 及 WAKE_LOCK 权限，请导入okhttp相关jar包并在 AndroidManifest.xml 类的 manifest 标签下添加如下权限，否则会造成调用上传/下载文件的方法无反应。       !--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 -- \n     uses-permission android:name= android.permission.WAKE_LOCK  /", 
            "title": "文件管理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_108", 
            "text": "创建文件对象方式如下：  String picPath =  sdcard/temp.jpg ;\nBmobFile bmobFile = new BmobFile(new File(picPath));", 
            "title": "创建文件对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_109", 
            "text": "文件分片上传的方法非常简单，示例代码如下：  String picPath =  sdcard/temp.jpg ;\nBmobFile bmobFile = new BmobFile(new File(picPath));\nbmobFile.uploadblock(new UploadFileListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            //bmobFile.getFileUrl()--返回的上传文件的完整地址\n            toast( 上传文件成功:  + bmobFile.getFileUrl());\n        }else{\n            toast( 上传文件失败：  + e.getMessage());\n        }\n\n    }\n\n    @Override\n    public void onProgress(Integer value) {\n        // 返回的上传进度（百分比）\n    }\n});", 
            "title": "上传单一文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_110", 
            "text": "自 BmobSDKv3.4.6 开始,新增 BmobConfig 类，允许开发者设置 查询超时时间 及 文件分片上传时的每片大小 。建议在 Application 类的 onCreate 方法中调用。  示例代码如下:  \npublic class BmobApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //设置BmobConfig\n        BmobConfig config =new BmobConfig.Builder()\n        //请求超时时间（单位为秒）：默认15s\n        .setConnectTimeout(30)\n        //文件分片上传时每片的大小（单位字节），默认512*1024\n        .setBlockSize(500*1024)\n        .build();\n        Bmob.getInstance().initConfig(config);\n    }\n}", 
            "title": "设置文件分片上传时每片大小"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_111", 
            "text": "自 BmobSDKv3.2.7 开始,新增批量上传文件的方法；  自 BmobSDKv3.4.6 开始,文件批量上传的静态方法由 Bmob 转移至 BmobFile 类,建议调用 BmobFile.uploadBatch 方法。  示例代码如下：  //详细示例可查看BmobExample工程中BmobFileActivity类\nString filePath_mp3 =  /mnt/sdcard/testbmob/test1.png ;\nString filePath_lrc =  /mnt/sdcard/testbmob/test2.png ;\nfinal String[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmobFile.uploadBatch(filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List BmobFile  files,List String  urls) {\n        //1、files-上传完成后的BmobFile集合，是为了方便大家对其上传后的数据进行操作，例如你可以将该文件保存到表中\n        //2、urls-上传文件的完整url地址\n        if(urls.size()==filePaths.length){//如果数量相等，则代表文件全部上传完成\n            //do something\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        ShowToast( 错误码 +statuscode + ,错误描述： +errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,int totalPercent) {\n        //1、curIndex--表示当前第几个文件正在上传\n        //2、curPercent--表示当前上传文件的进度值（百分比）\n        //3、total--表示总的上传文件数\n        //4、totalPercent--表示总的上传进度（百分比）\n    }\n});  注：  1、有多少个文件上传，onSuccess方法就会执行多少次;  2、通过onSuccess回调方法中的files或urls集合的大小与上传的总文件个数比较，如果一样，则表示全部文件上传成功。", 
            "title": "批量上传文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_112", 
            "text": "自 BmobSDKv3.4.6 版本,SDK提供了文件的下载方法 download ，并且允许开发者设置下载文件的存储路径。  注：下载方法并不局限于下载通过BmobSDK上传的文件，也就是说只要提供一个文件url地址，也可以调用下载方法的。  下载文件的步骤：  1、先获取BmobFile对象实例，可以是查询数据时返回的BmobFile，也可以自行构建BmobFile对象：   通过查询数据时返回的BmobFile，示例代码如下：   \nbmobQuery.findObjects(new FindListener GameScore () {\n    @Override\n    public void done(List GameScore  object,BmobException e) {\n        if(e==null){\n            for (GameScore gameScore : object) {\n                BmobFile bmobfile = gameScore.getPic();\n               if(file!= null){\n                    //调用bmobfile.download方法\n               }\n            }\n        }else{\n            toast( 查询失败： +e.getMessage());\n        }\n    }\n});   通过如下构造方法构造BmobFile对象：   需求：如果你想下载一个远程图片地址，那么就需要使用下面的构造方法构造一个BmobFile对象（其中group可为空）  /**  \n * @param fileName 文件名(必填)\n * @param group 组名（选填）\n * @param url  完整url地址（必填）\n * 注：必须要有文件名和文件的完整url地址，group可为空\n */\npublic BmobFile(String fileName,String group,String url){\n    this.filename = fileName;\n    this.group=group;\n    this.url = url;\n}  示例代码如下：  \nBmobFile bmobfile =new BmobFile( xxx.png , , http://bmob-cdn-2.b0.upaiyun.com/2016/04/12/58eeed852a7542cb964600c6cc0cd2d6.png )；  2、然后调用 bmobfile.download 方法下载文件:  有两种下载方法：    download(DownloadFileListener listener) ：此方法会将文件下载到当前应用的默认缓存目录中，以getFilename()得到的值为文件名    download(File savePath, DownloadFileListener listener) ：此方法允许开发者指定文件存储目录和文件名    示例代码如下：  private void downloadFile(BmobFile file){\n    //允许设置下载文件的存储路径，默认下载文件的目录为：context.getApplicationContext().getCacheDir()+ /bmob/ \n    File saveFile = new File(Environment.getExternalStorageDirectory(), file.getFilename());\n    file.download(saveFile, new DownloadFileListener() {\n\n        @Override\n        public void onStart() {\n            toast( 开始下载... );\n        }\n\n        @Override\n        public void done(String savePath,BmobException e) {\n            if(e==null){\n                toast( 下载成功,保存路径: +savePath);\n            }else{\n                toast( 下载失败： +e.getErrorCode()+ , +e.getMessage());\n            }\n        }\n\n        @Override\n        public void onProgress(Integer value, long newworkSpeed) {\n            Log.i( bmob , 下载进度： +value+ , +newworkSpeed);\n        }\n\n    });\n}", 
            "title": "下载文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_113", 
            "text": "BmobSDKv3.4.6 中删除文件的接口， 只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件 。不兼容之前的新旧文件管理，但使用方法不变。  示例代码如下：  BmobFile file = new BmobFile();\nfile.setUrl(url);//此url是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nfile.delete(new UpdateListener() {\n\n    @Override\n    public void done(BmobException e) {\n        if(e==null){\n            toast( 文件删除成功 );\n        }else{\n            toast( 文件删除失败： +e.getErrorCode()+ , +e.getMessage());\n        }\n    }\n});", 
            "title": "删除文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_114", 
            "text": "自  BmobSDKv3.4.6  版本，SDK提供了文件的批量删除接口 deleteBatch，且只能删除通过CDN文件服务（v3.4.6开始采用CDN文件服务）上传的文件 。  示例代码如下：  //此url必须是上传文件成功之后通过bmobFile.getUrl()方法获取的。\nString[] urls =new String[]{url};\nBmobFile.deleteBatch(urls, new DeleteBatchListener() {\n\n    @Override\n    public void done(String[] failUrls, BmobException e) {\n        if(e==null){\n            toast( 全部删除成功 );\n        }else{\n            if(failUrls!=null){\n                toast( 删除失败个数： +failUrls.length+ , +e.toString());\n            }else{\n                toast( 全部文件删除失败： +e.getErrorCode()+ , +e.toString());\n            }\n        }\n    }\n});  为方便大家理解文件服务的使用，Bmob提供了一个文件上传的案例和源码，大家可以到 示例和教程中查看和下载 。", 
            "title": "批量删除文件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_115", 
            "text": "自  BmobSDKv3.4.6  版本，新版文件服务由第三方厂商又拍云提供，只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果， 如图 ，具体可参考 这里  。  注：  1、文件的批量上传是BmobSDK_v3.2.7版本才提供的功能，如需使用，请更新版本;  2、文件的下载和批量删除是BmobSDK_v3.4.6才提供的功能，如需使用，请更新版本。", 
            "title": "缩略图"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_116", 
            "text": "数据实时同步是一个超酷的功能！  SDK可以实现对数据表或行的监听，当这个表或者行的数据发生变化时，Bmob会立即将变化的信息告知SDK。\n这种服务非常适合做游戏开发（如，开发斗地主游戏，三个人同时监听一行数据的变化，任何一个人出牌都会将数据写入到这行数据中，其他人也就立即知道了）、群聊（一群人监听某个表的变化，任何人发言都会将数据写入到这个表中，其他人也可以立即知道了）等实时性要求很高的场景中。  为方便大家快速了解数据的实时同步服务，我们提供了一个简单的应用实例（  https://github.com/bmob/bmob-android-demo-realtime-data  ）供大家参考。", 
            "title": "数据实时同步"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_117", 
            "text": "使用数据实时功能，首先需要创建 BmobRealTimeData 对象,然后调用 start 方法连接服务器。  BmobRealTimeData rtd = new BmobRealTimeData();\nrtd.start(new ValueEventListener() {\n    @Override\n    public void onDataChange(JSONObject data) {\n        Log.d( bmob ,  ( +data.optString( action )+ ) + 数据： +data);\n    }\n\n    @Override\n    public void onConnectCompleted(Exception ex) {\n        Log.d( bmob ,  连接成功: +rtd.isConnected());\n    }\n});  start 方法中的 ValueEventListener 参数用于监听连接成功和数据变化的回调。当有数据变化时会通过onDataChange回调方法反馈到客户端。开发者只需要处理得到的data就可以了。  注：  1、监听器不支持UI线程，在监听回调中请不要直接操作UI；  2、如果你要监听User、Installation等系统表的话，表名前需要加上“_”，例如：_User", 
            "title": "开始连接"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_118", 
            "text": "在BmobRealTimeData对象连接成功后，就可以进行数据的监听了。BmobSDK提供了监听表和行的方法如下：  // 监听表更新\nrtd.subTableUpdate(tableName);\n// 监听表删除\nrtd.subTableDelete(tableName);\n// 监听行更新\nrtd.subRowUpdate(tableName, objectId);\n// 监听行删除\nrtd.subRowDelete(tableName, objectId);  其中 tableName 为要监听的数据表名， objectId 为要监听的数据行Id,\n通常比较保险的做法是在 BmobRealTimeData 对象的连接状态为 true 的情况下进行监听，代码如下：  if(rtd.isConnected()){\n    // 监听表更新\n    rtd.subTableUpdate(tableName);\n}", 
            "title": "监听数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_119", 
            "text": "当开发者想取消监听某个行为是，可使用下面的方法：  // 取消监听表更新\nrtd.unsubTableUpdate(testTableName);\n// 取消监听表删除\nrtd.unsubTableDelete(testTableName);\n// 取消监听行更新\nrtd.unsubRowUpdate(testTableName, objectId);\n// 取消监听行删除\nrtd.unsubRowDelete(testTableName, objectId);", 
            "title": "取消监听"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#acl", 
            "text": "数据安全是软件系统中最重要的组成部分，为了更好的保护应用数据的安全，Bmob在软件架构层面提供了应用层次、表层次、ACL（Access Control List：访问控制列表）、角色管理（Role）四种不同粒度的权限控制的方式，确保用户数据的安全（详细请查看 Bmob数据与安全页面 ，了解Bmob如何保护数据安全）。  其中，最灵活的方法是通过ACL和角色，它的思路是每一条数据有一个用户和角色的列表，以及这些用户和角色拥有什么样的许可权限。  大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_120", 
            "text": "在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：  BmobACL aCL = new BmobACL();\n\naCL.setPublicReadAccess(true);\n\naCL.setPublicWriteAccess(true);  注意：可读可写是默认的权限，不需要写额外的代码。", 
            "title": "默认访问权限"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_121", 
            "text": "假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：  Blog blog = new Blog();\nblog.setTitle( 论电影的七个元素 );\nblog.setContent( 这是blog的具体内容 );\n\nBmobACL acl = new BmobACL();    //创建一个ACL对象\nacl.setPublicReadAccess(true);  // 设置所有人可读的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(this), true);   // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n\n});  有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：  Blog blog = new Blog();\nblog.setTitle( 一个人的秘密 );\nblog.setContent( 这是blog的具体内容 );\n\nBmobACL acl = new BmobACL();  //创建ACL对象\nacl.setReadAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\nacl.setWriteAccess(BmobUser.getCurrentUser(), true); // 设置当前用户可写的权限\n\nblog.setACL(acl);    //设置这条数据的ACL信息\nblog.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});", 
            "title": "指定用户的访问权限"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_122", 
            "text": "上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：  \n//创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);   \n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\n\n//设置四个用户读的权限\nacl.setReadAccess(boos, true);    \nacl.setReadAccess(hr_zhang, true);\nacl.setReadAccess(cashier_xie, true);\nacl.setReadAccess(me, true);\n\n//设置老板和人事小张对这个工资的写权限\nacl.setWriteAccess(boss, true);\nacl.setWriteAccess(hr_zhang, true);\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save(new SaveListener String () {\n\n    @Override\n    public void done(String objectId, BmobException e) {\n        ...\n    }\n});  但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：  //创建公司某用户的工资对象\nWageInfo wageinfo = new WageInfo();\nwageinfo.setWage(100000);\n\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser boss;\nBmobUser hr_zhang;\nBmobUser hr_luo;\nBmobUser cashier_xie;\nBmobUser me;\n\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole( HR );\nBmobRole cashier = new BmobRole( Cashier );\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this);  \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save();\n\n//创建ACL对象\nBmobACL acl = new BmobACL();\nacl.setReadAccess(boos, true); // 假设老板只有一个, 设置读权限\nacl.setReadAccess(me, true); // 给自己设置读权限\nacl.setRoleReadAccess(hr, true); // 给hr角色设置读权限\nacl.setRoleReadAccess(cashier, true); // 给cashier角色设置读权限\n\nacl.setWriteAccess(boss, true); // 设置老板拥有写权限\nacl.setRoleWriteAccess(hr, true); // 设置ht角色拥有写权限\n\n//设置工资对象的ACL\nwageinfo.setACL(acl);\nwageinfo.save();  需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。", 
            "title": "角色管理"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_123", 
            "text": "下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。  //创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole mobileDep = new BmobRole( MobileDep );\nBmobRole androidTeam = new BmobRole( AndroidTeam );\nBmobRole iosTeam = new BmobRole( iOSTeam );\n\n//保存AndroidTeam和iosTeam角色到云端\nandroidTeam.save();\niosTeam.save();\n\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nmobileDep.getRoles().add(androidTeam);\nmobileDep.getRoles().add(iosTeam);\nmobileDep.save();\n\n// 假设创建三个代码数据对象\nCode coreCode = new Code();\nCode androidCode = new Code();\nCode iosCode = new Code();\n\n//......此处省略一些具体的属性设定\n\ncoreCode.save();\nandroidCode.save();\niosCode.save();\n\n//设置androidTeam角色对androidCode对象的读和写的权限\nandroidCode.setRoleReadAccess(androidTeam, true);\nandroidCode.setRoleWriteAccess(androidTeam, true);\n\n//设置iosTeam角色对iosCode对象的读和写的权限\niosCode.setRoleReadAccess(iosTeam, true);\niosCode.setRoleWriteAccess(iosTeam, true);\n\n//设置mobileDep角色可以对coreCode对象进行读操作\ncoreCode.setRoleReadAccess(mobileDep);", 
            "title": "角色之间的从属关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#acl_1", 
            "text": "我们为大家提供一个ACL相关的案例源码，大家可以点击下载： https://github.com/bmob/bmob-android-demo-acl", 
            "title": "ACL案例源码"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_124", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。通过在BmobObject的查询中添加一个BmobGeoPoint的对象查询，你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。  为了方便大家查看文档，这里创建一个Person类：  public class Person extends BmobObject{\n    private BmobGeoPoint gpsAdd;\n\n    public BmobGeoPoint getGpsAdd() {\n        return gpsAdd;\n    }\n    public void setGpsAdd(BmobGeoPoint gpsAdd) {\n        this.gpsAdd = gpsAdd;\n    }\n}", 
            "title": "地理位置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_125", 
            "text": "首先需要创建一个BmobGeoPoint对象。例如，创建一个东经116.39727786183357度，北纬39.913768382429105度的BmobGeoPoint对象：  BmobGeoPoint point = new BmobGeoPoint(116.39727786183357, 39.913768382429105);", 
            "title": "创建地理位置对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_126", 
            "text": "现在，你可以测试找出最接近某个点的信息了（ 数据表要有一定的地理坐标对象的数据，GeoPoint字段类型 ）。查询使用BmobQuery对象的 addWhereNear 方法进行操作：  BmobQuery Person  bmobQuery = new BmobQuery Person ();\nbmobQuery.addWhereNear( gpsAdd , new BmobGeoPoint(112.934755, 24.52065));\nbmobQuery.setLimit(10);    //获取最接近用户地点的10条数据\nbmobQuery.findObjects(new FindListener Person () {\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共  + object.size() +  条数据。 );\n        }else{\n            toast( 查询失败：  + e.getMessage());\n        }\n    }\n});  要限制查询指定距离范围的数据可以使用 addWhereWithinKilometers 、 addWhereWithinMiles 或 addWhereWithinRadians 方法。  要查询一个矩形范围内的信息可以使用 addWhereWithinGeoBox 来实现：  BmobGeoPoint southwestOfSF = new BmobGeoPoint(116.10675, 39.711669);\nBmobGeoPoint northeastOfSF = new BmobGeoPoint(116.627623, 40.143687);\nBmobQuery Person  query = new BmobQuery Person ();\nquery.addWhereWithinGeoBox( gpsAdd , southwestOfSF, northeastOfSF);\nquery.findObjects(new FindListener Person () {\n\n    @Override\n    public void done(List Person  object,BmobException e) {\n        if(e==null){\n            toast( 查询成功：共  + object.size() +  条数据。 );\n        }else{\n            toast( 查询失败：  + e.getMessage());\n        }\n    }\n});  注意事项    每个BmobObject数据对象中 只能 有一个BmobGeoPoint对象 。    地理位置的点不能超过规定的范围。 纬度的范围 应该是在 -90.0到90.0 之间。 经度的范围 应该是在 -180.0到180.0 之间。如果您添加的经纬度超出了以上范围，将导致程序错误。", 
            "title": "查询地理位置信息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_127", 
            "text": "请大家在使用Bmob开发应用程序之前，仔细阅读“数据与安全”的文档： http://docs.bmob.cn/other/Other/n_datasafety/doc/index.html", 
            "title": "应用安全"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_128", 
            "text": "为方便大家更好的理解Bmob SDK，我们特意为大家提供了一些源码，大家可以下载之后， 嵌入Bmob的Application Id ，就可以打包运行了。  阅读源码是一种良好的习惯！！    即时聊天案例源码： https://github.com/bmob/BmobIMSDK4Android    图文社区案例源码： https://git.oschina.net/v7/Wonderful   这个案例是猿圈媛圈开发团队提供的。    校园小菜案例源码： https://github.com/bmob/Shop  这个案例是湖工大的朋友提供的。    社交分享案例源码： https://github.com/bmob/bmob-android-social-share  这个是金刚锁开发者提供的    第三方登录案例源码： https://github.com/bmob/bmob-android-demo-thirdpartylogin   包含第三方登录和登录后获取用户信息的源码", 
            "title": "开源案例"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_129", 
            "text": "", 
            "title": "其他功能"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_130", 
            "text": "在Bmob对象中提供了一个静态方法，用于获取服务器时间。  Bmob.getServerTime(new QueryListener Long () {\n\n    @Override\n    public void done(long time,BmobException e) {\n        if(e==null){\n            SimpleDateFormat formatter = new SimpleDateFormat( yyyy-MM-dd HH:mm );\n            String times = formatter.format(new Date(time * 1000L));\n            Log.i( bmob , 当前服务器时间为:  + times);\n        }else{\n            Log.i( bmob , 获取服务器时间失败:  + e.getMessage());\n        }\n    }\n\n});", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_131", 
            "text": "Bmob为大家提供了应用的自动更新组件，使用这个组件可以快速方便实现应用的自动升级功能。\n详细的使用操作可以参考文档： 自动更新组件文档", 
            "title": "自动更新组件"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_132", 
            "text": "自 V3.4.2 版本开始，SDK提供了 获取表结构信息 方法,具体示例如下：", 
            "title": "表结构"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_133", 
            "text": "Bmob.getTableSchema( 待查询的表名 , new QueryListener BmobTableSchema () {\n\n    @Override\n    public void done(BmobTableSchema schema, BmobException ex) {\n        if(ex==null){\n            Log.i( bmob ,  获取指定表的表结构信息成功： +schema.getClassName()+ - +schema.getFields().toString());\n        }else{\n            Log.i( bmob ,  获取指定表的表结构信息失败:  + ex.getLocalizedMessage()+ ( +ex.getErrorCode()+ ) );\n        }\n    }\n});", 
            "title": "获取特定表的结构"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_134", 
            "text": "Bmob.getAllTableSchema(context, new QueryListListener BmobTableSchema () {\n\n    @Override\n    public void done(List BmobTableSchema  schemas, BmobException ex) {\n        if(ex==null   schemas!=null   schemas.size() 0){\n            Log.i( bmob ,  获取所有表结构信息成功 );\n        }else{\n            Log.i( bmob , 获取所有表结构信息失败： +ex.getLocalizedMessage()+ ( +ex.getErrorCode()+ ) );\n        }\n    }\n});", 
            "title": "获取所有表的结构"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_135", 
            "text": "注： BmobTableSchema 参数说明：  其中  className ：表示表名  fields    ： 是Map 类型，里面包含了对应表的所有列的属性，  其fields内部结构如下：   {\"列1\":Map,\"列2\":Map, ...}   而Map的结构为：   {\"type\":\"typeName\",\"targetClass\":\"tableName\"}   其中  type  指的是该列的类型， 而  targetClass  指的是指向的表名，只有在 type 为 Pointer 或者 Relation 时才有值。  具体json格式如下,仅供参考：   {\n    className:  Post , \n    fields: {\n      ACL: {\n        type:  Object \n      }, \n      author: {\n        targetClass:  _User , \n        type:  Pointer \n      }, \n      content: {\n        type:  String \n      }, \n      createdAt: {\n        type:  Date \n      }, \n      objectId: {\n        type:  String \n      }, \n      updatedAt: {\n        type:  Date \n      }\n    }\n }", 
            "title": "返回数据说明"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_136", 
            "text": "Android SDK的错误码都是以 9 开头的，其他错误码请点击查看： RestAPI错误码列表 。  9001  内容：AppKey is Null, Please initialize BmobSDK.  含义：Application Id为空，请初始化。  9002  内容：Parse data error  含义：解析返回数据出错  9003  内容：upload file error  含义：上传文件出错  9004  内容：upload file failure  含义：文件上传失败  9005  内容：A batch operation can not be more than 50  含义：批量操作只支持最多50条  9006  内容：objectId is null  含义：objectId为空  9007  内容：BmobFile File size must be less than 10M.  含义：文件大小超过10M  9008  内容：BmobFile File does not exist.  含义：上传文件不存在  9009  内容：No cache data.  含义：没有缓存数据  9010  内容：The network is not normal.(Time out)  含义：网络超时  9011  内容：BmobUser does not support batch operations.  含义：BmobUser类不支持批量操作  9012  内容：context is null.  含义：上下文为空  9013  内容： BmobObject Object names(database table name) format is not correct.  含义：BmobObject（数据表名称）格式不正确  9014  含义：第三方账号授权失败  9015  含义：其他错误均返回此code  9016  内容：The network is not available,please check your network!  含义：无网络连接，请检查您的手机网络。  9017  含义：与第三方登录有关的错误，具体请看对应的错误描述  9018  含义：参数不能为空  9019  含义：格式不正确：手机号码、邮箱地址、验证码", 
            "title": "错误码列表"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_137", 
            "text": "使用了BmobSDK的应用在混淆过程中，需注意以下几点：  1、 不要混淆BmobSDK的代码 ，Bmob Android SDK本身进行了代码混淆；  2、任何继承自 BmobObject、BmobUser 的JavaBean及 在上述JavaBean中定义的Object属性类 都不要混淆，否则gson将无法将数据解析成具体对象；  3、确保 rx 、 okhttp3 okio 、 gson 及 org.apache.http.legacy.jar 包均不要混淆。  具体可参考BmobExample中proguard-project.txt的代码：  \n-ignorewarnings\n\n-keepattributes Signature,*Annotation*\n\n# keep BmobSDK\n-dontwarn cn.bmob.v3.**\n-keep class cn.bmob.v3.** {*;}\n\n# 确保JavaBean不被混淆-否则gson将无法将数据解析成具体对象\n-keep class * extends cn.bmob.v3.BmobObject {\n    *;\n}\n-keep class com.example.bmobexample.bean.BankCard{*;}\n-keep class com.example.bmobexample.bean.GameScore{*;}\n-keep class com.example.bmobexample.bean.MyUser{*;}\n-keep class com.example.bmobexample.bean.Person{*;}\n-keep class com.example.bmobexample.file.Movie{*;}\n-keep class com.example.bmobexample.file.Song{*;}\n-keep class com.example.bmobexample.relation.Post{*;}\n-keep class com.example.bmobexample.relation.Comment{*;}\n\n# keep BmobPush\n-dontwarn  cn.bmob.push.**\n-keep class cn.bmob.push.** {*;}\n\n# keep okhttp3、okio\n-dontwarn okhttp3.**\n-keep class okhttp3.** { *;}\n-keep interface okhttp3.** { *; }\n-dontwarn okio.**\n\n# keep rx\n-dontwarn sun.misc.**\n-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {\n long producerIndex;\n long consumerIndex;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode producerNode;\n}\n-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef {\n rx.internal.util.atomic.LinkedQueueNode consumerNode;\n}\n\n# 如果你需要兼容6.0系统，请不要混淆org.apache.http.legacy.jar \n-dontwarn android.net.compatibility.**\n-dontwarn android.net.http.**\n-dontwarn com.android.internal.http.multipart.**\n-dontwarn org.apache.commons.**\n-dontwarn org.apache.http.**\n-keep class android.net.compatibility.**{*;}\n-keep class android.net.http.**{*;}\n-keep class com.android.internal.http.multipart.**{*;}\n-keep class org.apache.commons.**{*;}\n-keep class org.apache.http.**{*;}", 
            "title": "混淆打包"
        }, 
        {
            "location": "/module/example/README/index.html", 
            "text": "失物招领案例教程\n\n\n需求描述\n\n\n为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布、修改、呈现和删除，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表，可以对发布的信息进行删除。\n\n\n说明一点的是，因为是演示案例，所以信息的添加和删除并没有进行用户身份验证。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1.添加数据\n\n\n添加失物/招领信息到服务器中。\n\n\n2.查找数据\n\n\n在列表中显示所有用户发布的失物/招领信息。\n\n\n3.删除数据\n\n\n删除已发布的失物/招领信息。\n\n\n本案例最终实现的部分界面效果如下：\n\n\n \n\n\n失物招领软件闪图\n\n\n \n\n\n招领列表页\n\n\n \n\n\n失物编辑删除功能\n\n\n \n\n\n添加失物信息\n\n\n数据结构设计\n\n\n本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程）：\n\n\n失物表（Lost）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ndescribe\n\n\nString\n\n\n失物的描述信息\n\n\n\n\n\n\nphone\n\n\nString\n\n\n联系的手机号码\n\n\n\n\n\n\ntitle\n\n\nString\n\n\n失物的标题信息\n\n\n\n\n\n\n\n\n招领表（Found）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ndescribe\n\n\nString\n\n\n招领的描述信息\n\n\n\n\n\n\nphone\n\n\nString\n\n\n联系的手机号码\n\n\n\n\n\n\ntitle\n\n\nString\n\n\n招领的标题信息\n\n\n\n\n\n\n\n\n初始化SDK\n\n\nBmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥-\nApplication ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类）：\n\n\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}\n\n\n\n\n创建数据模型类\n\n\n为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Lost表和Found表，因此需要创建Lost类和Found类。下面是Lost模型类的实现代码（Found模型类的实现代码略）：\n\n\npublic class Lost extends BmobObject{\n\n    private String title;//标题\n    private String describe;//描述\n    private String phone;//联系手机\n    public String getTitle() {\n        return title;\n    }\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    public String getDescribe() {\n        return describe;\n    }\n    public void setDescribe(String describe) {\n        this.describe = describe;\n    }\n    public String getPhone() {\n        return phone;\n    }\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n}\n\n\n\n\n\n添加失物及招领信息\n\n\n用户填写了失物信息之后，只需要构造一个Lost实例，然后简单调用模型类的insertObject方法（第一个参数是上下文，第二个参数是插入信息的回调类）就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddActivity类）：\n\n\n        Lost lost = new Lost();\n        lost.setDescribe(describe);\n        lost.setPhone(photo);\n        lost.setTitle(title);\n        lost.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                ShowToast(\n失物信息添加成功!\n);\n                //其他代码\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                ShowToast(\n添加失败:\n+arg0);\n            }\n        });\n\n\n\n\n获取失物及招领列表\n\n\nBmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和order方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：\n\n\n        BmobQuery\nLost\n query = new BmobQuery\nLost\n();\n        //按照时间降序\n        query.order(\n-createdAt\n);\n        //执行查询，第一个参数为上下文，第二个参数为查找的回调\n        query.findObjects(this, new FindListener\nLost\n() {\n\n            @Override\n            public void onSuccess(List\nLost\n losts) {\n                .....\n                //将结果显示在列表中\n                LostAdapter.addAll(losts);\n                .....\n            }\n\n            @Override\n            public void onError(int code, String arg0) {\n                showErrorView(0);\n            }\n        });\n\n\n\n\n删除失物及招领信息\n\n\nBmob云数据库对每条新增的数据都有一个唯一标识（objectId），这类似于传统SQL数据库中的唯一主键的性质。从云数据库中删除某条记录需要设置这个要删除的ObjectId的信息，再调用模型类的deleteObject方法就可以了，实现代码如下（详细代码实现参看MainActivity类的deleteLost方法）：\n\n\n        Lost lost = new Lost();\n        //设置ObjectId信息\n        lost.setObjectId(LostAdapter.getItem(position).getObjectId());\n        //执行删除方法，第一个参数为上下文，第二个参数为删除的回调\n        lost.delete(this, new DeleteListener() {\n\n            @Override\n            public void onSuccess() {\n                //删除成功\n                LostAdapter.remove(position);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                //删除失败\n            }\n        });\n\n\n\n\n后记\n\n\n本案例只是演示如何用Bmob进行快速的数据增删改查，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的\n开发文档\n或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n案例下载\n\n\n失物招领案例下载\n\n\n上传文件案例教程\n\n\n上传文件需求描述\n\n\n相对于移动网络和数据服务而言，文件服务往往需要更长的i/o时间，因此也就涉及到更多的异步操作的问题。不少朋友在用到Bmob文件服务的时候出错，原因就是没有充分理解同步和异步的本质。为方便大家理解Bmob的文件服务，这里提供一个上传文件的案例，从如何往一个只有一列文件字段的表中插入一条或者多条，到如何往一个有两列甚至多列文件字段的表中插入一条或者多条数据进行详细阐述。\n\n\n案例的界面效果如下：\n\n\n \n\n\n上传文件数据结构设计\n\n\n本案例的数据结构非常简单，只需要设计两个表，一个是电影表（Movie表，只有一个File字段），一个是音乐表（Music表，有两个File字段），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程）：\n\n\n电影表（Movie表）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\n电影名称\n\n\n\n\n\n\nfile\n\n\nFile\n\n\n电影文件\n\n\n\n\n\n\n\n\n音乐表（Music表）\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\n歌曲名称\n\n\n\n\n\n\nartist\n\n\nString\n\n\n艺术家\n\n\n\n\n\n\nmp3\n\n\nFile\n\n\nmp3文件\n\n\n\n\n\n\nlrc\n\n\nFile\n\n\n歌词文件\n\n\n\n\n\n\n\n\n安装和初始化SDK\n\n\nBmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥-\nApplication ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类，PS：大家可以顺便体会下创建BaseActivity类的好处^_^）：\n\n\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}\n\n\n\n\n创建模型类文件\n\n\n为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Movie表和Music表，因此需要创建Movie类和Music类。下面是Movie模型类的实现代码（Music模型类的实现代码略）：\n\n\n\npublic class Movie extends BmobObject {\nprivate String name;//电影名称\nprivate BmobFile file;//电影文件\n\npublic Movie(){\n}\n\npublic Movie(String name,BmobFile file){\n    this.name =name;\n    this.file = file;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic BmobFile getFile() {\n    return file;\n}\n\npublic void setFile(BmobFile file) {\n    this.file = file;\n}\n}\n\n\n\n\n\n上传一条单个文件的数据\n\n\n往Movie表中添加一条数据非常简单，只需要等到文件上传（BmobFile类的upload方法上传）成功之后，再调用数据服务的insertObject方法将这条数据插入到云数据库中就可以了。实现代码如下：\n\n\n\nfinal BmobFile bmobFile = new BmobFile(file);\nbmobFile.uploadblock(this, new UploadFileListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i(TAG, \n电影文件上传成功，返回的名称--\n+bmobFile.getFileUrl(MainActivity.this));\n        insertObject(new Movie(\n冰封：重生之门\n,bmobFile));\n    }\n\n    @Override\n    public void onProgress(Integer arg0) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onFailure(int arg0, String arg1) {\n        // TODO Auto-generated method stub\n        ShowToast(\n--\nuploadMovoieFile--\nonFailure:\n + arg0+\n,msg = \n+arg1);\n    }\n\n});\n\n\n\n\n\n批量上传多条单个文件的数据\n\n\n往Movie表中插入多条数据时，本案例的实现逻辑是：先调用Bmob提供的批量上传文件的方法，等所有文件都上传成功之后，再进行数据的批量添加操作（见下面的代码片段B）。代码片段A如下：\n\n\n\npublic void insertBatchDatasWithOne(){\nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\n//批量上传是会依次上传文件夹里面的文件\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List\nBmobFile\n files,List\nString\n urls) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertBatchDatasWithOne -onSuccess :\n+urls.size()+\n-----\n+files+\n----\n+urls);\n        if(urls.size()==1){//如果第一个文件上传完成\n            Movie movie =new Movie(\n哈利波特1\n,files.get(0));\n            movies.add(movie);\n        }else if(urls.size()==2){//第二个文件上传成功\n            Movie movie1 =new Movie(\n哈利波特2\n,files.get(1));\n            movies.add(movie1);\n            insertBatch(movies);\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast(\n错误码\n+statuscode +\n,错误描述：\n+errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertBatchDatasWithOne -onProgress :\n+curIndex+\n---\n+curPercent+\n---\n+total+\n----\n+totalPercent);\n    }\n});\n\n}\n\n\n\n\n代码片段B如下：\n\n\n\npublic void insertBatch(List\nBmobObject\n files){\n    new BmobObject().insertBatch(MainActivity.this, files, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast(\n----\n批量更新成功\n);\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast(\n----\n批量更新失败\n+arg0);\n\n        }\n    });\n}\n\n\n\n\n注：BmobSDK_v3.2.7版本提供了文件批量上传的方法，支持一键上传多个文件，非常方便和实用。\n\n\n上传一条多个文件的数据\n\n\n往Music表中插入一条有两个文件的数据的逻辑跟前面的类似，首先进行文件的同步上传操作，示例代码如下：\n\n\n\nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List\nBmobFile\n files,List\nString\n urls) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertDataWithMany -onSuccess :\n+urls.size()+\n-----\n+files+\n----\n+urls);\n        if(urls.size()==2){//如果全部上传完，则更新该条记录\n            Song song =new Song(\n汪峰0\n,\n北京北京0\n,files.get(0),files.get(1));\n            insertObject(song);\n        }else{\n            //有可能上传不完整，中间可能会存在未上传成功的情况，你可以自行处理\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast(\n错误码\n+statuscode +\n,错误描述：\n+errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i(\nlife\n,\ninsertBatchDatasWithOne -onProgress :\n+curIndex+\n---\n+curPercent+\n---\n+total+\n----\n+totalPercent);\n    }\n});\n\n\n\n\n上传成功之后，再进行数据的添加操作。示例代码如下：\n\n\n\nprivate void insertObject(final BmobObject obj){\n    obj.save(MainActivity.this, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast(\n--\n创建数据成功：\n + obj.getObjectId());\n\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast(\n--\n创建数据失败：\n + arg0+\n,msg = \n+arg1);\n        }\n    });\n}\n\n\n\n\n\n批量上传多条多个文件的数据\n\n\n往Music表中插入多条有两个文件的逻辑也一样，同样先进行文件的批量上传操作，最后进行批量更新操作。由于代码都非常相似，这里就不再一一详细阐述，想要知道实现代码的朋友可以直接下载我们的案例代码进行查看。\n\n\n上传文件后记\n\n\n文件上传是移动领域最基础的服务，BmobSDK_v3.2.7提供了批量上传文件的方法，此方法大大简化了开发者对文件的批量操作，也欢迎大家提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n注：如需查看该文的相关代码，可自行去官网下载的BmobSDK_v3.2.7版本下的BmobExample示例工程中BmobFileActivity类查看。也可以去bodismile的github地址\nhttps://github.com/bodismile/bmob-android-upload-file\n 查看。\n\n\n反馈案例教程\n\n\n反馈案例需求描述\n\n\n用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1.推送服务\n将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。\n\n\n2.数据存储服务\n\n\n添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。\n\n\n本案例最终实现的界面效果如下：\n\n\n \n\n\n发送反馈截图\n\n\n \n\n\n查看反馈意见截图\n\n\n反馈案例数据结构设计\n\n\n在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）\n\n\nFeedback表\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\nContact\n\n\nString\n\n\n用户的联系方式\n\n\n\n\n\n\ndeviceType\n\n\nString\n\n\n系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化\n\n\n\n\n\n\n\n\nInstallation表\n\n\n\n\n\n\n\n\n字段名\n\n\n类型\n\n\n描述\n\n\n\n\n\n\n\n\n\n\ninstallationId\n\n\nString\n\n\n系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的\n\n\n\n\n\n\ndeviceToken\n\n\nString\n\n\n系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的\n\n\n\n\n\n\nbadge\n\n\nNumber\n\n\n系统字段，表示iOS 设备最新已知的应用badge\n\n\n\n\n\n\ntimeZone\n\n\nString\n\n\n系统字段，表示安装的这个设备的系统时区\n\n\n\n\n\n\nchannels\n\n\nArray\n\n\n系统字段，表示这个安装对象的订阅频道列表\n\n\n\n\n\n\nappIdentifiter\n\n\nString\n\n\niOS应用的Bundle identifier\n\n\n\n\n\n\nisDeveloper\n\n\nBoolean\n\n\n是否是开发者（是的话则用于接收推送信息）\n\n\n\n\n\n\n\n\n安装和初始化\n\n\n还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。\n推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在Activity的onCreate方法中简单调用BmobPush.startWork方法就可以了，代码如下（详细代码见MainActivity类）：\n\n\n//这里替换为你的APP Key\n    public static String APPID = \n;    \n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Bmob.initialize(this, APPID);\n        BmobPush.startWork(this, APPID);    \n    }\n\n\n\n\n发送反馈功能的开发\n\n\n这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。\n\n\n为实现将数据保存到云数据库的功能，你首先需要先创建一个Feedback类（需要与刚刚创建的数据表Feedback名称对应一致），该类继承自BmobObject类，实现contact和content的set和get方法。实现代码如下（详细代码见Feedback类）：\n\n\npublic class Feedback extends BmobObject {\n    //反馈内容\n    private String content;\n    //联系方式\n    private String contacts;\n    public String getContent() {\n        return content;\n    }\n    public void setContent(String content) {\n        this.content = content;\n    }\n    public String getContacts() {\n        return contacts;\n    }\n    public void setContacts(String contacts) {\n        this.contacts = contacts;\n    }\n}\n\n\n\n\n有了Feedback类，你就可以方便的通过BmobObject的insertObject方法操作云数据库，将数据保存上去了。实现代码如下（详细代码见ActSendFeedback类）：\n\n\n    /**\n     * 保存反馈信息到Bmob云数据库中\n     * @param msg 反馈信息\n     */\n    private void saveFeedbackMsg(String msg){\n        Feedback feedback = new Feedback();\n        feedback.setContent(msg);\n        feedback.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                Log.i(\nbmob\n, \n反馈信息已保存到服务器\n);\n                //发送推送信息\n                saveFeedbackMsg(message);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                // TODO Auto-generated method stub\n                Log.e(\nbmob\n, \n保存反馈信息失败：\n+arg0);\n            }\n        });\n    }\n\n\n\n\n    /**\n     * 推送反馈信息给isDeveloper的设备\n     * @param message 反馈信息\n     */\n    private void sendMessage(String message){\n        BmobPushManager bmobPush = new BmobPushManager(this);\n        BmobQuery\nBmobInstallation\n query = BmobInstallation.getQuery();\n        query.addWhereEqualTo(\nisDeveloper\n, true);\n        bmobPush.setQuery(query);\n        bmobPush.pushMessage(message);\n    }\n\n\n\n\n查看反馈功能的开发\n\n\n为了接收用户端推送过来的反馈信息，查看反馈端需要自定义一个继承自BmobPushMessageReceiver的类，用于处理接收到的推送信息。实现代码如下：\n\n\npublic class MyMessageReceiver extends BmobPushMessageReceiver {\n\n    @Override\n    public void onMessage(Context context, String message) {\n        Log.d(\nbmob\n, \n收到反馈消息 = \n+message);\n        //通知栏显示收到的反馈信息\n        NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        Notification n = new Notification();  \n        n.icon = R.drawable.ic_launcher;  \n        n.tickerText = \n收到反馈消息\n;  \n        n.when = System.currentTimeMillis();  \n        Intent intent = new Intent(context, ActFeedbackList.class);  \n        PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);  \n        n.setLatestEventInfo(context, \n消息\n, message, pi);  \n        n.defaults |= Notification.DEFAULT_SOUND;\n        n.flags = Notification.FLAG_AUTO_CANCEL;\n        nm.notify(1, n);\n    }\n}\n\n\n\n\n查看反馈列表的功能实现也很简单，只需要调用BmobObject的findObjects方法就可以了，实现代码如下（详细代码见ActFeedbackList类）：\n\n\nBmobQuery\nFeedback\n query = new BmobQuery\nFeedback\n();\n//按createAt降序排列\nquery.order(\n-createdAt\n);\nquery.findObjects(this, new FindListener\nFeedback\n() {\n\n    @Override\n    public void onSuccess(List\nFeedback\n arg0) {\n        //显示反馈列表信息\n        adapter = new FeedbackAdapter(ActFeedbackList.this, arg0);\n        listView.setAdapter(adapter);\n    }\n\n    @Override\n    public void onError(int code, String arg0) {\n        emptyView.setText(arg0);\n    }\n});\n\n\n\n\n反馈案例后记\n\n\n当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n反馈案例案例下载\n\n\n反馈案例下载\n\n\n其它案例\n\n\n快速入门相关源码下载\nhttp://www.bmob.cn/static/Bmob_android_quickstart.zip\n\n\n即时聊天案例源码\nhttps://github.com/bmob/BmobIMSDK4Android\n\n\n图文社区案例源码：\nhttps://git.oschina.net/v7/Wonderful\n  这个案例是猿圈媛圈开发团队提供的。\n\n\n图文分享案例源码：\nhttps://github.com/smartbetter/AndroidWonderful\n 这个案例是一个叫郭朝的开发者提供的。\n\n\n校园小菜案例源码：\nhttps://github.com/bmob/Shop\n 这个案例是湖工大的朋友提供的。\n\n\n社交分享案例源码：\nhttps://github.com/bmob/bmob-android-social-share\n 这个是金刚锁开发者提供的\n\n\n第三方登录案例源码：\nhttps://github.com/bmob/bmob-android-demo-thirdpartylogin\n  包含第三方登录和登录后获取用户信息的源码。\n\n\n自定义表名情况下增删改查数据的Demo，下载地址是：\nhttps://github.com/bmob/bmob-android-demo-dynamic-tablename\n。\n\n\n使用分页查询，结合ListView开发下拉刷新查看更多内容\nhttps://github.com/bmob/bmob-android-demo-paging\n。\n\n\n短信验证的demo：\nhttps://github.com/bmob/bmob_android_demo_sms\n 。\n\n\n缩略图案例源码：\nhttps://github.com/bmob/bmob-android-demo-thumbnail\n\n\n数据的实时同步服务应用实例（ \nhttps://github.com/bmob/bmob-android-demo-realtime-data\n ）供大家参考。\n\n\nACL相关的案例源码：\nhttps://github.com/bmob/bmob-android-demo-acl\n\n\n推送案例Demo:\nhttps://github.com/bmob/bmob-android-demo-push\n\n\nBmobSDK自动更新实例程序源码：\nhttps://github.com/bmob/bmob-android-demo-autoupdate\n\n\n踢球吧源码\nhttps://github.com/bmob/BmobTiQiuBa\n\n\nandroid云端逻辑案例:\nhttp://www.bmob.cn/static/Bmob_Sample_android_cloud.zip\n\n\n基于Bmob的二维码扫描工具:\nhttps://github.com/bmob/FindLook", 
            "title": "示例和功能"
        }, 
        {
            "location": "/module/example/README/index.html#_1", 
            "text": "", 
            "title": "失物招领案例教程"
        }, 
        {
            "location": "/module/example/README/index.html#_2", 
            "text": "为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布、修改、呈现和删除，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表，可以对发布的信息进行删除。  说明一点的是，因为是演示案例，所以信息的添加和删除并没有进行用户身份验证。  本案例将使用到Bmob的如下功能：  1.添加数据  添加失物/招领信息到服务器中。  2.查找数据  在列表中显示所有用户发布的失物/招领信息。  3.删除数据  删除已发布的失物/招领信息。  本案例最终实现的部分界面效果如下：     失物招领软件闪图     招领列表页     失物编辑删除功能     添加失物信息", 
            "title": "需求描述"
        }, 
        {
            "location": "/module/example/README/index.html#_3", 
            "text": "本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程）：  失物表（Lost）     字段名  类型  描述      describe  String  失物的描述信息    phone  String  联系的手机号码    title  String  失物的标题信息     招领表（Found）     字段名  类型  描述      describe  String  招领的描述信息    phone  String  联系的手机号码    title  String  招领的标题信息", 
            "title": "数据结构设计"
        }, 
        {
            "location": "/module/example/README/index.html#sdk", 
            "text": "Bmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥- Application ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类）：  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}", 
            "title": "初始化SDK"
        }, 
        {
            "location": "/module/example/README/index.html#_4", 
            "text": "为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Lost表和Found表，因此需要创建Lost类和Found类。下面是Lost模型类的实现代码（Found模型类的实现代码略）：  public class Lost extends BmobObject{\n\n    private String title;//标题\n    private String describe;//描述\n    private String phone;//联系手机\n    public String getTitle() {\n        return title;\n    }\n    public void setTitle(String title) {\n        this.title = title;\n    }\n    public String getDescribe() {\n        return describe;\n    }\n    public void setDescribe(String describe) {\n        this.describe = describe;\n    }\n    public String getPhone() {\n        return phone;\n    }\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n}", 
            "title": "创建数据模型类"
        }, 
        {
            "location": "/module/example/README/index.html#_5", 
            "text": "用户填写了失物信息之后，只需要构造一个Lost实例，然后简单调用模型类的insertObject方法（第一个参数是上下文，第二个参数是插入信息的回调类）就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddActivity类）：          Lost lost = new Lost();\n        lost.setDescribe(describe);\n        lost.setPhone(photo);\n        lost.setTitle(title);\n        lost.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                ShowToast( 失物信息添加成功! );\n                //其他代码\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                ShowToast( 添加失败: +arg0);\n            }\n        });", 
            "title": "添加失物及招领信息"
        }, 
        {
            "location": "/module/example/README/index.html#_6", 
            "text": "Bmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和order方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：          BmobQuery Lost  query = new BmobQuery Lost ();\n        //按照时间降序\n        query.order( -createdAt );\n        //执行查询，第一个参数为上下文，第二个参数为查找的回调\n        query.findObjects(this, new FindListener Lost () {\n\n            @Override\n            public void onSuccess(List Lost  losts) {\n                .....\n                //将结果显示在列表中\n                LostAdapter.addAll(losts);\n                .....\n            }\n\n            @Override\n            public void onError(int code, String arg0) {\n                showErrorView(0);\n            }\n        });", 
            "title": "获取失物及招领列表"
        }, 
        {
            "location": "/module/example/README/index.html#_7", 
            "text": "Bmob云数据库对每条新增的数据都有一个唯一标识（objectId），这类似于传统SQL数据库中的唯一主键的性质。从云数据库中删除某条记录需要设置这个要删除的ObjectId的信息，再调用模型类的deleteObject方法就可以了，实现代码如下（详细代码实现参看MainActivity类的deleteLost方法）：          Lost lost = new Lost();\n        //设置ObjectId信息\n        lost.setObjectId(LostAdapter.getItem(position).getObjectId());\n        //执行删除方法，第一个参数为上下文，第二个参数为删除的回调\n        lost.delete(this, new DeleteListener() {\n\n            @Override\n            public void onSuccess() {\n                //删除成功\n                LostAdapter.remove(position);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                //删除失败\n            }\n        });", 
            "title": "删除失物及招领信息"
        }, 
        {
            "location": "/module/example/README/index.html#_8", 
            "text": "本案例只是演示如何用Bmob进行快速的数据增删改查，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的 开发文档 或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "后记"
        }, 
        {
            "location": "/module/example/README/index.html#_9", 
            "text": "失物招领案例下载", 
            "title": "案例下载"
        }, 
        {
            "location": "/module/example/README/index.html#_10", 
            "text": "", 
            "title": "上传文件案例教程"
        }, 
        {
            "location": "/module/example/README/index.html#_11", 
            "text": "相对于移动网络和数据服务而言，文件服务往往需要更长的i/o时间，因此也就涉及到更多的异步操作的问题。不少朋友在用到Bmob文件服务的时候出错，原因就是没有充分理解同步和异步的本质。为方便大家理解Bmob的文件服务，这里提供一个上传文件的案例，从如何往一个只有一列文件字段的表中插入一条或者多条，到如何往一个有两列甚至多列文件字段的表中插入一条或者多条数据进行详细阐述。  案例的界面效果如下：", 
            "title": "上传文件需求描述"
        }, 
        {
            "location": "/module/example/README/index.html#_12", 
            "text": "本案例的数据结构非常简单，只需要设计两个表，一个是电影表（Movie表，只有一个File字段），一个是音乐表（Music表，有两个File字段），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程）：  电影表（Movie表）     字段名  类型  描述      name  String  电影名称    file  File  电影文件     音乐表（Music表）     字段名  类型  描述      name  String  歌曲名称    artist  String  艺术家    mp3  File  mp3文件    lrc  File  歌词文件", 
            "title": "上传文件数据结构设计"
        }, 
        {
            "location": "/module/example/README/index.html#sdk_1", 
            "text": "Bmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥- Application ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看BaseActivity类，PS：大家可以顺便体会下创建BaseActivity类的好处^_^）：  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    //初始化 Bmob SDK，第一个参数为上下文，第二个参数为Application ID\n    Bmob.initialize(this, Constants.Bmob_APPID);\n    //其他代码\n}", 
            "title": "安装和初始化SDK"
        }, 
        {
            "location": "/module/example/README/index.html#_13", 
            "text": "为操作Bmob的云端数据库，SDK首先需要创建数据表对应的模型类（模型类的名称必须和云端数据表的名称一致），该类需要继承自BmobObject，实现刚刚创建的数据表字段的set和get方法（系统默认字段objectId、createAt、updateAt不需要声明）。因为本案例需要操作Movie表和Music表，因此需要创建Movie类和Music类。下面是Movie模型类的实现代码（Music模型类的实现代码略）：  \npublic class Movie extends BmobObject {\nprivate String name;//电影名称\nprivate BmobFile file;//电影文件\n\npublic Movie(){\n}\n\npublic Movie(String name,BmobFile file){\n    this.name =name;\n    this.file = file;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic BmobFile getFile() {\n    return file;\n}\n\npublic void setFile(BmobFile file) {\n    this.file = file;\n}\n}", 
            "title": "创建模型类文件"
        }, 
        {
            "location": "/module/example/README/index.html#_14", 
            "text": "往Movie表中添加一条数据非常简单，只需要等到文件上传（BmobFile类的upload方法上传）成功之后，再调用数据服务的insertObject方法将这条数据插入到云数据库中就可以了。实现代码如下：  \nfinal BmobFile bmobFile = new BmobFile(file);\nbmobFile.uploadblock(this, new UploadFileListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i(TAG,  电影文件上传成功，返回的名称-- +bmobFile.getFileUrl(MainActivity.this));\n        insertObject(new Movie( 冰封：重生之门 ,bmobFile));\n    }\n\n    @Override\n    public void onProgress(Integer arg0) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onFailure(int arg0, String arg1) {\n        // TODO Auto-generated method stub\n        ShowToast( -- uploadMovoieFile-- onFailure:  + arg0+ ,msg =  +arg1);\n    }\n\n});", 
            "title": "上传一条单个文件的数据"
        }, 
        {
            "location": "/module/example/README/index.html#_15", 
            "text": "往Movie表中插入多条数据时，本案例的实现逻辑是：先调用Bmob提供的批量上传文件的方法，等所有文件都上传成功之后，再进行数据的批量添加操作（见下面的代码片段B）。代码片段A如下：  \npublic void insertBatchDatasWithOne(){\nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\n//批量上传是会依次上传文件夹里面的文件\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List BmobFile  files,List String  urls) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertBatchDatasWithOne -onSuccess : +urls.size()+ ----- +files+ ---- +urls);\n        if(urls.size()==1){//如果第一个文件上传完成\n            Movie movie =new Movie( 哈利波特1 ,files.get(0));\n            movies.add(movie);\n        }else if(urls.size()==2){//第二个文件上传成功\n            Movie movie1 =new Movie( 哈利波特2 ,files.get(1));\n            movies.add(movie1);\n            insertBatch(movies);\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast( 错误码 +statuscode + ,错误描述： +errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertBatchDatasWithOne -onProgress : +curIndex+ --- +curPercent+ --- +total+ ---- +totalPercent);\n    }\n});\n\n}  代码片段B如下：  \npublic void insertBatch(List BmobObject  files){\n    new BmobObject().insertBatch(MainActivity.this, files, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast( ---- 批量更新成功 );\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast( ---- 批量更新失败 +arg0);\n\n        }\n    });\n}  注：BmobSDK_v3.2.7版本提供了文件批量上传的方法，支持一键上传多个文件，非常方便和实用。", 
            "title": "批量上传多条单个文件的数据"
        }, 
        {
            "location": "/module/example/README/index.html#_16", 
            "text": "往Music表中插入一条有两个文件的数据的逻辑跟前面的类似，首先进行文件的同步上传操作，示例代码如下：  \nString[] filePaths = new String[2];\nfilePaths[0] = filePath_mp3;\nfilePaths[1] = filePath_lrc;\nBmob.uploadBatch(this, filePaths, new UploadBatchListener() {\n\n    @Override\n    public void onSuccess(List BmobFile  files,List String  urls) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertDataWithMany -onSuccess : +urls.size()+ ----- +files+ ---- +urls);\n        if(urls.size()==2){//如果全部上传完，则更新该条记录\n            Song song =new Song( 汪峰0 , 北京北京0 ,files.get(0),files.get(1));\n            insertObject(song);\n        }else{\n            //有可能上传不完整，中间可能会存在未上传成功的情况，你可以自行处理\n        }\n    }\n\n    @Override\n    public void onError(int statuscode, String errormsg) {\n        // TODO Auto-generated method stub\n        ShowToast( 错误码 +statuscode + ,错误描述： +errormsg);\n    }\n\n    @Override\n    public void onProgress(int curIndex, int curPercent, int total,\n            int totalPercent) {\n        // TODO Auto-generated method stub\n        Log.i( life , insertBatchDatasWithOne -onProgress : +curIndex+ --- +curPercent+ --- +total+ ---- +totalPercent);\n    }\n});  上传成功之后，再进行数据的添加操作。示例代码如下：  \nprivate void insertObject(final BmobObject obj){\n    obj.save(MainActivity.this, new SaveListener() {\n\n        @Override\n        public void onSuccess() {\n            // TODO Auto-generated method stub\n            ShowToast( -- 创建数据成功：  + obj.getObjectId());\n\n        }\n\n        @Override\n        public void onFailure(int arg0, String arg1) {\n            // TODO Auto-generated method stub\n            ShowToast( -- 创建数据失败：  + arg0+ ,msg =  +arg1);\n        }\n    });\n}", 
            "title": "上传一条多个文件的数据"
        }, 
        {
            "location": "/module/example/README/index.html#_17", 
            "text": "往Music表中插入多条有两个文件的逻辑也一样，同样先进行文件的批量上传操作，最后进行批量更新操作。由于代码都非常相似，这里就不再一一详细阐述，想要知道实现代码的朋友可以直接下载我们的案例代码进行查看。", 
            "title": "批量上传多条多个文件的数据"
        }, 
        {
            "location": "/module/example/README/index.html#_18", 
            "text": "文件上传是移动领域最基础的服务，BmobSDK_v3.2.7提供了批量上传文件的方法，此方法大大简化了开发者对文件的批量操作，也欢迎大家提出更多的意见和建议帮助Bmob更好的发展。谢谢～  注：如需查看该文的相关代码，可自行去官网下载的BmobSDK_v3.2.7版本下的BmobExample示例工程中BmobFileActivity类查看。也可以去bodismile的github地址 https://github.com/bodismile/bmob-android-upload-file  查看。", 
            "title": "上传文件后记"
        }, 
        {
            "location": "/module/example/README/index.html#_19", 
            "text": "", 
            "title": "反馈案例教程"
        }, 
        {
            "location": "/module/example/README/index.html#_20", 
            "text": "用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。  本案例将使用到Bmob的如下功能：  1.推送服务\n将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。  2.数据存储服务  添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。  本案例最终实现的界面效果如下：     发送反馈截图     查看反馈意见截图", 
            "title": "反馈案例需求描述"
        }, 
        {
            "location": "/module/example/README/index.html#_21", 
            "text": "在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）  Feedback表     字段名  类型  描述      Contact  String  用户的联系方式    deviceType  String  系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化     Installation表     字段名  类型  描述      installationId  String  系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的    deviceToken  String  系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的    badge  Number  系统字段，表示iOS 设备最新已知的应用badge    timeZone  String  系统字段，表示安装的这个设备的系统时区    channels  Array  系统字段，表示这个安装对象的订阅频道列表    appIdentifiter  String  iOS应用的Bundle identifier    isDeveloper  Boolean  是否是开发者（是的话则用于接收推送信息）", 
            "title": "反馈案例数据结构设计"
        }, 
        {
            "location": "/module/example/README/index.html#_22", 
            "text": "还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。\n推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在Activity的onCreate方法中简单调用BmobPush.startWork方法就可以了，代码如下（详细代码见MainActivity类）：  //这里替换为你的APP Key\n    public static String APPID =  ;    \n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Bmob.initialize(this, APPID);\n        BmobPush.startWork(this, APPID);    \n    }", 
            "title": "安装和初始化"
        }, 
        {
            "location": "/module/example/README/index.html#_23", 
            "text": "这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。  为实现将数据保存到云数据库的功能，你首先需要先创建一个Feedback类（需要与刚刚创建的数据表Feedback名称对应一致），该类继承自BmobObject类，实现contact和content的set和get方法。实现代码如下（详细代码见Feedback类）：  public class Feedback extends BmobObject {\n    //反馈内容\n    private String content;\n    //联系方式\n    private String contacts;\n    public String getContent() {\n        return content;\n    }\n    public void setContent(String content) {\n        this.content = content;\n    }\n    public String getContacts() {\n        return contacts;\n    }\n    public void setContacts(String contacts) {\n        this.contacts = contacts;\n    }\n}  有了Feedback类，你就可以方便的通过BmobObject的insertObject方法操作云数据库，将数据保存上去了。实现代码如下（详细代码见ActSendFeedback类）：      /**\n     * 保存反馈信息到Bmob云数据库中\n     * @param msg 反馈信息\n     */\n    private void saveFeedbackMsg(String msg){\n        Feedback feedback = new Feedback();\n        feedback.setContent(msg);\n        feedback.save(this, new SaveListener() {\n\n            @Override\n            public void onSuccess() {\n                Log.i( bmob ,  反馈信息已保存到服务器 );\n                //发送推送信息\n                saveFeedbackMsg(message);\n            }\n\n            @Override\n            public void onFailure(int code, String arg0) {\n                // TODO Auto-generated method stub\n                Log.e( bmob ,  保存反馈信息失败： +arg0);\n            }\n        });\n    }      /**\n     * 推送反馈信息给isDeveloper的设备\n     * @param message 反馈信息\n     */\n    private void sendMessage(String message){\n        BmobPushManager bmobPush = new BmobPushManager(this);\n        BmobQuery BmobInstallation  query = BmobInstallation.getQuery();\n        query.addWhereEqualTo( isDeveloper , true);\n        bmobPush.setQuery(query);\n        bmobPush.pushMessage(message);\n    }", 
            "title": "发送反馈功能的开发"
        }, 
        {
            "location": "/module/example/README/index.html#_24", 
            "text": "为了接收用户端推送过来的反馈信息，查看反馈端需要自定义一个继承自BmobPushMessageReceiver的类，用于处理接收到的推送信息。实现代码如下：  public class MyMessageReceiver extends BmobPushMessageReceiver {\n\n    @Override\n    public void onMessage(Context context, String message) {\n        Log.d( bmob ,  收到反馈消息 =  +message);\n        //通知栏显示收到的反馈信息\n        NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        Notification n = new Notification();  \n        n.icon = R.drawable.ic_launcher;  \n        n.tickerText =  收到反馈消息 ;  \n        n.when = System.currentTimeMillis();  \n        Intent intent = new Intent(context, ActFeedbackList.class);  \n        PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);  \n        n.setLatestEventInfo(context,  消息 , message, pi);  \n        n.defaults |= Notification.DEFAULT_SOUND;\n        n.flags = Notification.FLAG_AUTO_CANCEL;\n        nm.notify(1, n);\n    }\n}  查看反馈列表的功能实现也很简单，只需要调用BmobObject的findObjects方法就可以了，实现代码如下（详细代码见ActFeedbackList类）：  BmobQuery Feedback  query = new BmobQuery Feedback ();\n//按createAt降序排列\nquery.order( -createdAt );\nquery.findObjects(this, new FindListener Feedback () {\n\n    @Override\n    public void onSuccess(List Feedback  arg0) {\n        //显示反馈列表信息\n        adapter = new FeedbackAdapter(ActFeedbackList.this, arg0);\n        listView.setAdapter(adapter);\n    }\n\n    @Override\n    public void onError(int code, String arg0) {\n        emptyView.setText(arg0);\n    }\n});", 
            "title": "查看反馈功能的开发"
        }, 
        {
            "location": "/module/example/README/index.html#_25", 
            "text": "当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "反馈案例后记"
        }, 
        {
            "location": "/module/example/README/index.html#_26", 
            "text": "反馈案例下载", 
            "title": "反馈案例案例下载"
        }, 
        {
            "location": "/module/example/README/index.html#_27", 
            "text": "快速入门相关源码下载 http://www.bmob.cn/static/Bmob_android_quickstart.zip  即时聊天案例源码 https://github.com/bmob/BmobIMSDK4Android  图文社区案例源码： https://git.oschina.net/v7/Wonderful   这个案例是猿圈媛圈开发团队提供的。  图文分享案例源码： https://github.com/smartbetter/AndroidWonderful  这个案例是一个叫郭朝的开发者提供的。  校园小菜案例源码： https://github.com/bmob/Shop  这个案例是湖工大的朋友提供的。  社交分享案例源码： https://github.com/bmob/bmob-android-social-share  这个是金刚锁开发者提供的  第三方登录案例源码： https://github.com/bmob/bmob-android-demo-thirdpartylogin   包含第三方登录和登录后获取用户信息的源码。  自定义表名情况下增删改查数据的Demo，下载地址是： https://github.com/bmob/bmob-android-demo-dynamic-tablename 。  使用分页查询，结合ListView开发下拉刷新查看更多内容 https://github.com/bmob/bmob-android-demo-paging 。  短信验证的demo： https://github.com/bmob/bmob_android_demo_sms  。  缩略图案例源码： https://github.com/bmob/bmob-android-demo-thumbnail  数据的实时同步服务应用实例（  https://github.com/bmob/bmob-android-demo-realtime-data  ）供大家参考。  ACL相关的案例源码： https://github.com/bmob/bmob-android-demo-acl  推送案例Demo: https://github.com/bmob/bmob-android-demo-push  BmobSDK自动更新实例程序源码： https://github.com/bmob/bmob-android-demo-autoupdate  踢球吧源码 https://github.com/bmob/BmobTiQiuBa  android云端逻辑案例: http://www.bmob.cn/static/Bmob_Sample_android_cloud.zip  基于Bmob的二维码扫描工具: https://github.com/bmob/FindLook", 
            "title": "其它案例"
        }, 
        {
            "location": "/module/auto_update/README/index.html", 
            "text": "快速入门\n\n\n1、添加资源文件\n\n\n下载SDK提供的res文件夹拷入工程目录下，和工程本身res目录合并。\n\n\nres文件夹下载地址：\nhttp://www.bmob.cn/static/res.zip\n\n\n这里需要注意的是：\n\n\n\n\n请不要随便删除其中的文件。\n\n\nBmobSDK提供的资源文件都以bmob_开头。\n\n\n如果是在AndroidStudio中用远程依赖的方式就可以跳过这个步骤，因为这些资源都在下载到本地的aar包中。\n\n\n\n\n2、配置AndroidManifest.xml\n\n\n1.打开AndroidManifest.xml，添加SDK需要的权限到\n标签下：\n\n\nuses-permission android:name=\nandroid.permission.WRITE_EXTERNAL_STORAGE\n/uses-permission\n\n\nuses-permission android:name=\nandroid.permission.ACCESS_NETWORK_STATE\n/uses-permission\n\n\nuses-permission android:name=\nandroid.permission.INTERNET\n/uses-permission\n\n\n\n\n\n说明：\n- android.permission.WRITE_EXTERNAL_STORAGE 权限允许将下载的apk保存到sd卡中。\n- android.permission.ACCESS_NETWORK_STATE 权限允许检查网络状态，从而根据不同网络环境决定何种下载策略,务必添加该权限。\n\n\n2.添加渠道到\n标签下： \n\n\nmeta-data android:value=\nChannel ID\n android:name=\nBMOB_CHANNEL\n/\n\n\n\n\n\n说明：\nBMOB_CHANNEL\n用来标注应用推广渠道，不同渠道可以上传不同更新包，您可以使用20位以内的英文和数字为渠道定名，替换value中的\nChannel ID\n。如果不添加，将不区分渠道。(注意不要出现在manifest中标识了渠道但后端控制台没写渠道值，这样是无法自动更新的，因为没匹配上)\n\n\n3.添加Activity到\n标签下：\n\n\nactivity \n            android:name=\ncn.bmob.v3.update.UpdateDialogActivity\n\n            android:theme=\n@android:style/Theme.Translucent.NoTitleBar\n \n\n        \n/activity\n\n\n\n\n\n3、初始化AppVersion表\n\n\n一行代码轻松搞定\nAppVersion\n表（\n注意：请务必将该表在WEB端设置为只读模式\n）：\n\n\nSDK提供了初始化自动创建\nAppVersion\n表的方法，不再需要开发者手动在web端创建。只需要在你使用自动更新功能的地方调用如下代码：\n\n\n    BmobUpdateAgent.initAppVersion();\n\n\n\n\n注：\n\n\n1、initAppVersion方法适合开发者调试自动更新功能时使用，一旦AppVersion表在后台创建成功，建议屏蔽或删除此方法，否则会生成多行记录。\n\n\n2、如果调用了此方法后，在管理后台没有看见AppVersion表生成，建议到手机的应用管理界面\n清除该应用的数据，并再次调用该方法\n，也可到LogCat中查看与\nbmob\n相关错误日志。\n\n\n3、如果\n2\n方法尝试多次之后仍然无效，请\n手动创建AppVersion表\n，表的各个字段名称请查看下表。\n\n\n4、调用自动更新接口\n\n\n最常见的自动更新模式是：当用户进入应用首页后，如果处于wifi环境则检测更新，如果有更新，弹出对话框提示有新版本，用户点选更新开始下载更新。实现的方法是，在应用程序入口Activity里的\nOnCreate()\n方法中调用如下代码：\n\n\npublic void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.update(this);\n}\n\n\n\n\n\n\n考虑到用户流量的限制，目前我们默认在WiFi接入情况下才进行自动提醒。如需要在任意网络环境下都进行更新自动提醒，则请在update调用之前添加以下代码：\n\n\n\n\nBmobUpdateAgent.setUpdateOnlyWifi(false)\n\n\n\n\n\n\n如果你发现调用update方法无反应，可使用下面\n自定义功能\n中的\n监听检测更新的结果\n提到的方法来监听自动更新的结果,具体如下：\n\n\n\n\nBmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n    @Override\n    public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n        // TODO Auto-generated method stub\n        //根据updateStatus来判断更新是否成功\n    }\n})\n\n\n\n\n强制更新\n\n\n应用场景：如果应用需要屏蔽旧版本，强制用户必须更新升级到最新版才能继续使用。\n\n\nSDK中为自动更新方式提供了\n强制更新\n功能，当开发者开启强制更新功能（即将后台的\nAppVersion\n表中的isforce字段置为true）时，客户端调用\nBmobUpdateAgent.update(context)\n方法后，更新对话框只保留“立即更新”按钮且不再支持回退操作。其效果图如下：\n\n\n\n\n忽略版本更新\n\n\nSDK中为自动更新方式提供了\n忽略版本更新\n功能，当用户勾选”忽略该版“选项时，再次调用\nBmobUpdateAgent.update(context)\n则不再出现版本更新对话框。\n\n\n注：强制更新和忽略版本更新只支持自动更新方式。\n\n\n5、上传APK文件或填写apk文件的url地址\n\n\n初始化AppVersion表成功后，开发者在管理后台的\n数据浏览\n页中就可以看见AppVersion表了,该表的结构如下：\n\n\n\n\n\n\n\n\n字段名称\n\n\n字段类型\n\n\n是否必填\n\n\n字段说明\n\n\n\n\n\n\n\n\n\n\nupdate_log\n\n\nString\n\n\n是\n\n\n更新日志\n\n\n\n\n\n\nversion\n\n\nString\n\n\n是\n\n\n版本名称\n\n\n\n\n\n\nversion_i\n\n\nNumber\n\n\n是\n\n\n版本号\n\n\n\n\n\n\nplatform\n\n\nString\n\n\n是\n\n\n平台，注意：\"Android\"为安卓平台标示，\"ios\"为ios平台标示\n\n\n\n\n\n\ntarget_size\n\n\nString\n\n\n是\n\n\nApk文件大小\n\n\n\n\n\n\nisforce\n\n\nBoolean\n\n\n否\n\n\n是否强制更新\n\n\n\n\n\n\npath\n\n\nFile\n\n\n是/否\n\n\nApk文件\n\n\n\n\n\n\nandroid_url\n\n\nString\n\n\n是/否\n\n\napk市场地址（path字段和本字段必填其中一个）\n\n\n\n\n\n\nchannel\n\n\nString\n\n\n否\n\n\n渠道标示\n\n\n\n\n\n\nios_url\n\n\nString\n\n\n否\n\n\niOS app store地址（如果是ios记录一定要填写）\n\n\n\n\n\n\n\n\n创建好这个表结构之后就可以新增一些记录，把应用的信息和下载地址（或者上传文件）填写上去，如下图所示：\n\n\n\n\n注：\n\n\n1、target_size为必填项，是为了解决当apk下载过程中切换网络导致的解析包出现错误问题，请手动填入apk文件的字节大小。可通过鼠标右键apk文件--\n属性--\n大小（不是占用空间）获取到的target_size值（不需要单位）：\n\n\n\n\n如上例，只需要在\ntarget_size\n字段中填写\n5032788\n就行。\n\n\n2、新添加的数据记录的version_i（对应应用中的version code，如下图）的数值要大于手机中安装的应用的version number，否则无法生效。另外，platform需要根据实际情况填写平台信息。\n\n\n\n\n3、新版SDKV3.3.2调用initAppVersion方法后，你会看到AppVersion表的path字段有一个test.apk的文件，其实这个文件是个空的文件，不必过于纠结，将test.apk删除后再上传自己的apk文件即可。\n\n\n4、新版SDKV3.3.4允许下载已上传到应用市场上的apk文件，因此，path和android_url两者填任意一个即可，若都填写，默认优先下载path字段下的apk文件。\n\n\n5、新版SDKV3.3.4新增对update_log字段内容进行文字排版的功能，只需要在分段处加上分隔符\n；\n即可（UI效果如下图）\n\n\n具体格式参考如下范例：1、修复第三方登陆成功后无法获取本地用户信息的问题\n；\n2、修复设置缓存策略后无法获取本地缓存信息的问题\n；\n3、修复调用云端逻辑（callEndpoint）方法的成功回调的返回值中含有“results”的问题\n；\n4、新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。\n\n\n\n\n6、如果在web后台上传apk文件，然后在使用了v3.4.6之前版本的sdk的应用上调用自动更新功能出现 \n解析包出错\n 的问题，解决方法如下：\n\n\n请不要上传apk文件到\npath\n字段，改为\n填写apk文件的url地址\n到\nandroid_url\n字段。\n\n\n具体原因请查看 \n常见问题\n。\n\n\n6、集成检测\n\n\nSDK中默认开启了集成检测功能，在调用任意的更新接口后，我们将替您自动检查上述集成过程中2、3两个步骤是否被正确完成。 如果正确完成不会出现任何提示，否则会以如下的toast提示您。\n\n\n你可以通过调用\nBmobUpdateAgent.setUpdateCheckConfig(false)\n来禁用此功能。\n\n\ntoast的含义如下：\n\n\n\"Please copy all resources (res/) from SDK to your project!\"：请检查是不是把res文件夹下所有的资源文件都放到了工程中。\n\n\"Please add Permission in AndroidManifest!\"：请检查上述步骤中的相关权限是否正确添加。\n\n\"Please add Activity in AndroidManifest!\"：请检查上述步骤中的Activity是否正确添加。\n\n\n\n其他更新方式\n\n\n除了在快速入门中提到的自动更新之外，Bmob自动更新SDK还支持另外两种场景：手动更新、静默更新。\n下面将详细介绍这两种场景的接口及默认行为。\n\n\n手动更新\n\n\n许多应用的设置界面中都会有检查更新等类似功能，需要用户主动触发而检测更新。它的默认行为基本和自动更新基本一致。它和自动更新的主要区别是：在这种手动更新的情况下，无论网络状况是否Wifi，无论用户是否忽略过该版本的更新，都可以像下面的示例一样在按钮的回调中发起更新检查，代替update(Context context)：\n\n\npublic void onClick(View v) {\n    BmobUpdateAgent.forceUpdate(mContext);\n}\n\n\n\n静默下载更新\n\n\n当用户进入应用首页后如果处于wifi环境检测更新，如果有更新，后台下载新版本，如果下载成功，则进行通知栏展示，用户点击通知栏开始安装。静默下载过程中如果wifi断开，则会停止下载。实现的方法是：在应用程序入口Activity里的\nOnCreate()\n方法中调用如下代码：\n\n\npublic void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.silentUpdate(this);\n}\n\n\n\n自定义功能\n\n\n恢复默认设置\n\n\nBmobUpdateAgent.setDefault();\n\n\n设置更新的网络条件\n\n\nBmobUpdateAgent.setUpdateOnlyWifi（boolean updateOnlyWifi）\n\n\n注：updateOnlyWifi:true表示只在wifi环境下检测更新，false表示所有环境下均可检测更新\n\n\n监听检测更新的结果\n\n\n如果开发者想自己处理检测更新的结果，可以按如下步骤，实现更新监听接口，自主处理更新事件：\n\n\n    BmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n        @Override\n        public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n            // TODO Auto-generated method stub\n            if (updateStatus == UpdateStatus.Yes) {//版本有更新\n\n            }else if(updateStatus == UpdateStatus.No){\n                Toast.makeText(ActAutoUpdate.this, \n版本无更新\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.EmptyField){//此提示只是提醒开发者关注那些必填项，测试成功后，无需对用户提示\n                Toast.makeText(ActAutoUpdate.this, \n请检查你AppVersion表的必填项，1、target_size（文件大小）是否填写；2、path或者android_url两者必填其中一项。\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.IGNORED){\n                Toast.makeText(ActAutoUpdate.this, \n该版本已被忽略更新\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.ErrorSizeFormat){\n                Toast.makeText(ActAutoUpdate.this, \n请检查target_size填写的格式，请使用file.length()方法获取apk大小。\n, Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.TimeOut){\n                Toast.makeText(ActAutoUpdate.this, \n查询出错或查询超时\n, Toast.LENGTH_SHORT).show();\n            }\n        }\n    });\n    //发起自动更新\n    BmobUpdateAgent.update(this);\n\n\n\n\n监听对话框按键操作\n\n\n有时候开发者需要知道用户点击了哪个按钮，开发者可设置监听对话框的按钮点击事件。\n\n\n    //设置对对话框按钮的点击事件的监听\n    BmobUpdateAgent.setDialogListener(new BmobDialogButtonListener() {\n\n        @Override\n        public void onClick(int status) {\n            // TODO Auto-generated method stub\n            switch (status) {\n            case UpdateStatus.Update:\n                Toast.makeText(ActAutoUpdate.this, \n点击了立即更新按钮\n , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.NotNow:\n                Toast.makeText(ActAutoUpdate.this, \n点击了以后再说按钮\n , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.Close://只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等\n                Toast.makeText(ActAutoUpdate.this, \n点击了对话框关闭按钮\n , Toast.LENGTH_SHORT).show();\n                break;\n            }\n        }\n    });\n\n\n\n\n注：UpdateStatus列表\n\n\nUpdateStatus.TimeOut    =-1：查询出错或超时\nUpdateStatus.Yes        = 0：有更新\nUpdateStatus.No         = 1：没有更新\nUpdateStatus.IGNORED    = 3：该版本已被忽略更新\nUpdateStatus.EmptyField = 2：字段值为空，请检查以下内容：\n                            1)、是否已填写target_size目标apk大小（以字节为单位）；\n                            2)、path或者android_url两者是否必填其中一项（若两者都填写，则默认下载path字段下的apk文件）\nUpdateStatus.ErrorSizeFormat = 4：请检查target_size填写的格式，请使用file.length()方法获取apk大小\nUpdateStatus.Update     =6： 代表点击的是“立即更新”\nUpdateStatus.NotNow     =7： 代表点击的是“以后再说”\nUpdateStatus.Close      =8： 代表关闭对话框--\n只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等\n\n\n\n常见问题\n\n\n一、\n上传新的APK文件之后，为什么使用 \nv3.4.6以前版本的SDK开发的旧应用\n 的自动更新功能出现\n解析包出错\n问题？\n\n\n1、表现：\n\n\n只下载58字节后就弹出安装界面，点击安装出现`解析包出错`的错误。\n\n\n\n2、原因：\n\n\n 自4月13日上线CDN文件服务以来，通过Web后台上传的apk文件都会自动上传到CDN服务提供商那里，而`v3.4.6以前版本的SDK`的自动更新功能中得到`用于下载的url地址会将Bmob原有的文件域名拼接到BmobFile的url前面`。\n\n因此，最终拼接成的用于下载的地址是类似这样的：`http://file.bmob.cn/http://bmob-cdn-82.b0.upaiyun.com/2016/04/20/xxx.apk`，由此导致 `解析包出错`。\n\n\n\n3、解决方法：\n\n\n不要上传apk文件到`AppVersion`表的`path`字段，改为填写url地址到`AppVersion`表的`android_url`字段，以此来恢复旧应用的自动更新功能。\n\n\n\n其中，\nandroid_url\n可以是以下两种之一：\n\n\n1）、`各大应用市场的应用下载地址`\n2）、`上传新的apk文件到bmob的其他表的文件字段中，然后通过getFileUrl(context)获取到的url地址`\n\n\n\n注：如果是新发布的应用(使用BmobV3.4.6后的版本开发的应用)，则仍然可以上传apk文件到\nAppVersion\n表的\npath\n字段中。\n\n\n二、 \n为什么调用\nBmobUpdateAgent.update(this)\n方法后没有弹出更新对话框？\n\n\n请仔细检查以下几方面：\n\n\n1）、如果是通过`手动方法`在后台创建的AppVersion表的话，则仔细对照文档检查各个字段的名称是否正确填写，注意大小写;\n\n2）、`AndroidManifest.xml`中的的`android:versionCode`的值是否比后台的`AppVersion`表中填写的`version_i`的值`小`;\n\n3）、`target_size`的值是否正确填写，填写的是apk的字节大小，没有单位，例如：很多开发者填写的是'x.xxM',这个格式是错误的;\n\n4)、`AndroidManifest.xml`中的`BMOB_CHANNEL`的值是否和后台的`AppVersion`表中填写的`channel`的值`相等`。\n\n \n!-- 设置应用渠道，如果应用不需要区分渠道，则建议删除此行 --\n\n\nmeta-data android:name=\"BMOB_CHANNEL\" android:value=\"bmob\"/\n\n\n\n\n案例源码\n\n\n这里我们提供了一个使用BmobSDK自动更新功能的实例程序供大家参考。下载地址如下：\nhttps://github.com/bmob/bmob-android-demo-autoupdate", 
            "title": "自动更新"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_1", 
            "text": "", 
            "title": "快速入门"
        }, 
        {
            "location": "/module/auto_update/README/index.html#1", 
            "text": "下载SDK提供的res文件夹拷入工程目录下，和工程本身res目录合并。  res文件夹下载地址： http://www.bmob.cn/static/res.zip  这里需要注意的是：   请不要随便删除其中的文件。  BmobSDK提供的资源文件都以bmob_开头。  如果是在AndroidStudio中用远程依赖的方式就可以跳过这个步骤，因为这些资源都在下载到本地的aar包中。", 
            "title": "1、添加资源文件"
        }, 
        {
            "location": "/module/auto_update/README/index.html#2androidmanifestxml", 
            "text": "1.打开AndroidManifest.xml，添加SDK需要的权限到 标签下：  uses-permission android:name= android.permission.WRITE_EXTERNAL_STORAGE /uses-permission  uses-permission android:name= android.permission.ACCESS_NETWORK_STATE /uses-permission  uses-permission android:name= android.permission.INTERNET /uses-permission   说明：\n- android.permission.WRITE_EXTERNAL_STORAGE 权限允许将下载的apk保存到sd卡中。\n- android.permission.ACCESS_NETWORK_STATE 权限允许检查网络状态，从而根据不同网络环境决定何种下载策略,务必添加该权限。  2.添加渠道到 标签下：   meta-data android:value= Channel ID  android:name= BMOB_CHANNEL /   说明： BMOB_CHANNEL 用来标注应用推广渠道，不同渠道可以上传不同更新包，您可以使用20位以内的英文和数字为渠道定名，替换value中的 Channel ID 。如果不添加，将不区分渠道。(注意不要出现在manifest中标识了渠道但后端控制台没写渠道值，这样是无法自动更新的，因为没匹配上)  3.添加Activity到 标签下：  activity \n            android:name= cn.bmob.v3.update.UpdateDialogActivity \n            android:theme= @android:style/Theme.Translucent.NoTitleBar   \n         /activity", 
            "title": "2、配置AndroidManifest.xml"
        }, 
        {
            "location": "/module/auto_update/README/index.html#3appversion", 
            "text": "一行代码轻松搞定 AppVersion 表（ 注意：请务必将该表在WEB端设置为只读模式 ）：  SDK提供了初始化自动创建 AppVersion 表的方法，不再需要开发者手动在web端创建。只需要在你使用自动更新功能的地方调用如下代码：      BmobUpdateAgent.initAppVersion();  注：  1、initAppVersion方法适合开发者调试自动更新功能时使用，一旦AppVersion表在后台创建成功，建议屏蔽或删除此方法，否则会生成多行记录。  2、如果调用了此方法后，在管理后台没有看见AppVersion表生成，建议到手机的应用管理界面 清除该应用的数据，并再次调用该方法 ，也可到LogCat中查看与 bmob 相关错误日志。  3、如果 2 方法尝试多次之后仍然无效，请 手动创建AppVersion表 ，表的各个字段名称请查看下表。", 
            "title": "3、初始化AppVersion表"
        }, 
        {
            "location": "/module/auto_update/README/index.html#4", 
            "text": "最常见的自动更新模式是：当用户进入应用首页后，如果处于wifi环境则检测更新，如果有更新，弹出对话框提示有新版本，用户点选更新开始下载更新。实现的方法是，在应用程序入口Activity里的 OnCreate() 方法中调用如下代码：  public void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.update(this);\n}   考虑到用户流量的限制，目前我们默认在WiFi接入情况下才进行自动提醒。如需要在任意网络环境下都进行更新自动提醒，则请在update调用之前添加以下代码：   BmobUpdateAgent.setUpdateOnlyWifi(false)   如果你发现调用update方法无反应，可使用下面 自定义功能 中的 监听检测更新的结果 提到的方法来监听自动更新的结果,具体如下：   BmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n    @Override\n    public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n        // TODO Auto-generated method stub\n        //根据updateStatus来判断更新是否成功\n    }\n})", 
            "title": "4、调用自动更新接口"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_2", 
            "text": "应用场景：如果应用需要屏蔽旧版本，强制用户必须更新升级到最新版才能继续使用。  SDK中为自动更新方式提供了 强制更新 功能，当开发者开启强制更新功能（即将后台的 AppVersion 表中的isforce字段置为true）时，客户端调用 BmobUpdateAgent.update(context) 方法后，更新对话框只保留“立即更新”按钮且不再支持回退操作。其效果图如下：", 
            "title": "强制更新"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_3", 
            "text": "SDK中为自动更新方式提供了 忽略版本更新 功能，当用户勾选”忽略该版“选项时，再次调用 BmobUpdateAgent.update(context) 则不再出现版本更新对话框。  注：强制更新和忽略版本更新只支持自动更新方式。", 
            "title": "忽略版本更新"
        }, 
        {
            "location": "/module/auto_update/README/index.html#5apkapkurl", 
            "text": "初始化AppVersion表成功后，开发者在管理后台的 数据浏览 页中就可以看见AppVersion表了,该表的结构如下：     字段名称  字段类型  是否必填  字段说明      update_log  String  是  更新日志    version  String  是  版本名称    version_i  Number  是  版本号    platform  String  是  平台，注意：\"Android\"为安卓平台标示，\"ios\"为ios平台标示    target_size  String  是  Apk文件大小    isforce  Boolean  否  是否强制更新    path  File  是/否  Apk文件    android_url  String  是/否  apk市场地址（path字段和本字段必填其中一个）    channel  String  否  渠道标示    ios_url  String  否  iOS app store地址（如果是ios记录一定要填写）     创建好这个表结构之后就可以新增一些记录，把应用的信息和下载地址（或者上传文件）填写上去，如下图所示：   注：  1、target_size为必填项，是为了解决当apk下载过程中切换网络导致的解析包出现错误问题，请手动填入apk文件的字节大小。可通过鼠标右键apk文件-- 属性-- 大小（不是占用空间）获取到的target_size值（不需要单位）：   如上例，只需要在 target_size 字段中填写 5032788 就行。  2、新添加的数据记录的version_i（对应应用中的version code，如下图）的数值要大于手机中安装的应用的version number，否则无法生效。另外，platform需要根据实际情况填写平台信息。   3、新版SDKV3.3.2调用initAppVersion方法后，你会看到AppVersion表的path字段有一个test.apk的文件，其实这个文件是个空的文件，不必过于纠结，将test.apk删除后再上传自己的apk文件即可。  4、新版SDKV3.3.4允许下载已上传到应用市场上的apk文件，因此，path和android_url两者填任意一个即可，若都填写，默认优先下载path字段下的apk文件。  5、新版SDKV3.3.4新增对update_log字段内容进行文字排版的功能，只需要在分段处加上分隔符 ； 即可（UI效果如下图）  具体格式参考如下范例：1、修复第三方登陆成功后无法获取本地用户信息的问题 ； 2、修复设置缓存策略后无法获取本地缓存信息的问题 ； 3、修复调用云端逻辑（callEndpoint）方法的成功回调的返回值中含有“results”的问题 ； 4、新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。   6、如果在web后台上传apk文件，然后在使用了v3.4.6之前版本的sdk的应用上调用自动更新功能出现  解析包出错  的问题，解决方法如下：  请不要上传apk文件到 path 字段，改为 填写apk文件的url地址 到 android_url 字段。  具体原因请查看  常见问题 。", 
            "title": "5、上传APK文件或填写apk文件的url地址"
        }, 
        {
            "location": "/module/auto_update/README/index.html#6", 
            "text": "SDK中默认开启了集成检测功能，在调用任意的更新接口后，我们将替您自动检查上述集成过程中2、3两个步骤是否被正确完成。 如果正确完成不会出现任何提示，否则会以如下的toast提示您。  你可以通过调用 BmobUpdateAgent.setUpdateCheckConfig(false) 来禁用此功能。  toast的含义如下：  \"Please copy all resources (res/) from SDK to your project!\"：请检查是不是把res文件夹下所有的资源文件都放到了工程中。\n\n\"Please add Permission in AndroidManifest!\"：请检查上述步骤中的相关权限是否正确添加。\n\n\"Please add Activity in AndroidManifest!\"：请检查上述步骤中的Activity是否正确添加。", 
            "title": "6、集成检测"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_4", 
            "text": "除了在快速入门中提到的自动更新之外，Bmob自动更新SDK还支持另外两种场景：手动更新、静默更新。\n下面将详细介绍这两种场景的接口及默认行为。", 
            "title": "其他更新方式"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_5", 
            "text": "许多应用的设置界面中都会有检查更新等类似功能，需要用户主动触发而检测更新。它的默认行为基本和自动更新基本一致。它和自动更新的主要区别是：在这种手动更新的情况下，无论网络状况是否Wifi，无论用户是否忽略过该版本的更新，都可以像下面的示例一样在按钮的回调中发起更新检查，代替update(Context context)：  public void onClick(View v) {\n    BmobUpdateAgent.forceUpdate(mContext);\n}", 
            "title": "手动更新"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_6", 
            "text": "当用户进入应用首页后如果处于wifi环境检测更新，如果有更新，后台下载新版本，如果下载成功，则进行通知栏展示，用户点击通知栏开始安装。静默下载过程中如果wifi断开，则会停止下载。实现的方法是：在应用程序入口Activity里的 OnCreate() 方法中调用如下代码：  public void onCreate(Bundle  savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    BmobUpdateAgent.silentUpdate(this);\n}", 
            "title": "静默下载更新"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_7", 
            "text": "", 
            "title": "自定义功能"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_8", 
            "text": "BmobUpdateAgent.setDefault();", 
            "title": "恢复默认设置"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_9", 
            "text": "BmobUpdateAgent.setUpdateOnlyWifi（boolean updateOnlyWifi）  注：updateOnlyWifi:true表示只在wifi环境下检测更新，false表示所有环境下均可检测更新", 
            "title": "设置更新的网络条件"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_10", 
            "text": "如果开发者想自己处理检测更新的结果，可以按如下步骤，实现更新监听接口，自主处理更新事件：      BmobUpdateAgent.setUpdateListener(new BmobUpdateListener() {\n\n        @Override\n        public void onUpdateReturned(int updateStatus, UpdateResponse updateInfo) {\n            // TODO Auto-generated method stub\n            if (updateStatus == UpdateStatus.Yes) {//版本有更新\n\n            }else if(updateStatus == UpdateStatus.No){\n                Toast.makeText(ActAutoUpdate.this,  版本无更新 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.EmptyField){//此提示只是提醒开发者关注那些必填项，测试成功后，无需对用户提示\n                Toast.makeText(ActAutoUpdate.this,  请检查你AppVersion表的必填项，1、target_size（文件大小）是否填写；2、path或者android_url两者必填其中一项。 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.IGNORED){\n                Toast.makeText(ActAutoUpdate.this,  该版本已被忽略更新 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.ErrorSizeFormat){\n                Toast.makeText(ActAutoUpdate.this,  请检查target_size填写的格式，请使用file.length()方法获取apk大小。 , Toast.LENGTH_SHORT).show();\n            }else if(updateStatus==UpdateStatus.TimeOut){\n                Toast.makeText(ActAutoUpdate.this,  查询出错或查询超时 , Toast.LENGTH_SHORT).show();\n            }\n        }\n    });\n    //发起自动更新\n    BmobUpdateAgent.update(this);", 
            "title": "监听检测更新的结果"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_11", 
            "text": "有时候开发者需要知道用户点击了哪个按钮，开发者可设置监听对话框的按钮点击事件。      //设置对对话框按钮的点击事件的监听\n    BmobUpdateAgent.setDialogListener(new BmobDialogButtonListener() {\n\n        @Override\n        public void onClick(int status) {\n            // TODO Auto-generated method stub\n            switch (status) {\n            case UpdateStatus.Update:\n                Toast.makeText(ActAutoUpdate.this,  点击了立即更新按钮  , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.NotNow:\n                Toast.makeText(ActAutoUpdate.this,  点击了以后再说按钮  , Toast.LENGTH_SHORT).show();\n                break;\n            case UpdateStatus.Close://只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等\n                Toast.makeText(ActAutoUpdate.this,  点击了对话框关闭按钮  , Toast.LENGTH_SHORT).show();\n                break;\n            }\n        }\n    });  注：UpdateStatus列表  UpdateStatus.TimeOut    =-1：查询出错或超时\nUpdateStatus.Yes        = 0：有更新\nUpdateStatus.No         = 1：没有更新\nUpdateStatus.IGNORED    = 3：该版本已被忽略更新\nUpdateStatus.EmptyField = 2：字段值为空，请检查以下内容：\n                            1)、是否已填写target_size目标apk大小（以字节为单位）；\n                            2)、path或者android_url两者是否必填其中一项（若两者都填写，则默认下载path字段下的apk文件）\nUpdateStatus.ErrorSizeFormat = 4：请检查target_size填写的格式，请使用file.length()方法获取apk大小\nUpdateStatus.Update     =6： 代表点击的是“立即更新”\nUpdateStatus.NotNow     =7： 代表点击的是“以后再说”\nUpdateStatus.Close      =8： 代表关闭对话框-- 只有在强制更新状态下才会在更新对话框的右上方出现close按钮,如果用户不点击”立即更新“按钮，这时候开发者可做些操作，比如直接退出应用等", 
            "title": "监听对话框按键操作"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_12", 
            "text": "一、 上传新的APK文件之后，为什么使用  v3.4.6以前版本的SDK开发的旧应用  的自动更新功能出现 解析包出错 问题？  1、表现：  只下载58字节后就弹出安装界面，点击安装出现`解析包出错`的错误。  2、原因：   自4月13日上线CDN文件服务以来，通过Web后台上传的apk文件都会自动上传到CDN服务提供商那里，而`v3.4.6以前版本的SDK`的自动更新功能中得到`用于下载的url地址会将Bmob原有的文件域名拼接到BmobFile的url前面`。\n\n因此，最终拼接成的用于下载的地址是类似这样的：`http://file.bmob.cn/http://bmob-cdn-82.b0.upaiyun.com/2016/04/20/xxx.apk`，由此导致 `解析包出错`。  3、解决方法：  不要上传apk文件到`AppVersion`表的`path`字段，改为填写url地址到`AppVersion`表的`android_url`字段，以此来恢复旧应用的自动更新功能。  其中， android_url 可以是以下两种之一：  1）、`各大应用市场的应用下载地址`\n2）、`上传新的apk文件到bmob的其他表的文件字段中，然后通过getFileUrl(context)获取到的url地址`  注：如果是新发布的应用(使用BmobV3.4.6后的版本开发的应用)，则仍然可以上传apk文件到 AppVersion 表的 path 字段中。  二、  为什么调用 BmobUpdateAgent.update(this) 方法后没有弹出更新对话框？  请仔细检查以下几方面：  1）、如果是通过`手动方法`在后台创建的AppVersion表的话，则仔细对照文档检查各个字段的名称是否正确填写，注意大小写;\n\n2）、`AndroidManifest.xml`中的的`android:versionCode`的值是否比后台的`AppVersion`表中填写的`version_i`的值`小`;\n\n3）、`target_size`的值是否正确填写，填写的是apk的字节大小，没有单位，例如：很多开发者填写的是'x.xxM',这个格式是错误的;\n\n4)、`AndroidManifest.xml`中的`BMOB_CHANNEL`的值是否和后台的`AppVersion`表中填写的`channel`的值`相等`。\n\n  !-- 设置应用渠道，如果应用不需要区分渠道，则建议删除此行 --  meta-data android:name=\"BMOB_CHANNEL\" android:value=\"bmob\"/", 
            "title": "常见问题"
        }, 
        {
            "location": "/module/auto_update/README/index.html#_13", 
            "text": "这里我们提供了一个使用BmobSDK自动更新功能的实例程序供大家参考。下载地址如下： https://github.com/bmob/bmob-android-demo-autoupdate", 
            "title": "案例源码"
        }, 
        {
            "location": "/module/error_code/README/index.html", 
            "text": "AndroidSDK错误码列表\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n9001\n\n\nAppKey is Null, Please initialize BmobSDK.\n\n\nApplication Id为空，请初始化.\n\n\n\n\n\n\n9002\n\n\nParse data error\n\n\n解析返回数据出错\n\n\n\n\n\n\n9003\n\n\nupload file error\n\n\n上传文件出错\n\n\n\n\n\n\n9004\n\n\nupload file failure\n\n\n文件上传失败\n\n\n\n\n\n\n9005\n\n\nA batch operation can not be more than 50\n\n\n批量操作只支持最多50条\n\n\n\n\n\n\n9006\n\n\nobjectId is null\n\n\nobjectId为空\n\n\n\n\n\n\n9007\n\n\nBmobFile File size must be less than 10M.\n\n\n文件大小超过10M\n\n\n\n\n\n\n9008\n\n\nBmobFile File does not exist.\n\n\n上传文件不存在\n\n\n\n\n\n\n9009\n\n\nNo cache data.\n\n\n没有缓存数据\n\n\n\n\n\n\n9010\n\n\nThe network is not normal.(Time out)\n\n\n网络超时\n\n\n\n\n\n\n9011\n\n\nBmobUser does not support batch operations.\n\n\nBmobUser类不支持批量操作\n\n\n\n\n\n\n9012\n\n\ncontext is null.\n\n\n上下文为空\n\n\n\n\n\n\n9013\n\n\nBmobObject Object names(database table name) format is not correct.\n\n\nBmobObject（数据表名称）格式不正确\n\n\n\n\n\n\n9014\n\n\n第三方账号授权失败\n\n\n第三方账号授权失败\n\n\n\n\n\n\n9015\n\n\n其他错误均返回此code\n\n\n其他错误均返回此code\n\n\n\n\n\n\n9016\n\n\nThe network is not available,please check your network!\n\n\n无网络连接，请检查您的手机网络.\n\n\n\n\n\n\n9017\n\n\n与第三方登录有关的错误，具体请看对应的错误描述\n\n\n与第三方登录有关的错误，具体请看对应的错误描述\n\n\n\n\n\n\n9018\n\n\n参数不能为空\n\n\n参数不能为空\n\n\n\n\n\n\n9019\n\n\n格式不正确：手机号码、邮箱地址、验证码\n\n\n格式不正确：手机号码、邮箱地址、验证码\n\n\n\n\n\n\n9020\n\n\n保存CDN信息失败\n\n\n保存CDN信息失败\n\n\n\n\n\n\n9021\n\n\npermission not defined.You must write android.permission.WAKE_LOCK in AndroidManifest.xml \"\nuses-permission android:name=\"android.permission.WAKE_LOCK\".\n\n\n文件上传缺少wakelock权限\n\n\n\n\n\n\n9022\n\n\nupload failure,please retry.\n\n\n文件上传失败，请重新上传\n\n\n\n\n\n\n9023\n\n\nplease call Bmob.initialize to init sdk.\n\n\n请调用Bmob类的initialize方法去初始化SDK\n\n\n\n\n\n\n\n\nRESTAPI错误码列表\n\n\n\n\n\n\n\n\nHttpResponseCode\n\n\n错误码\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n401\n\n\n\n\nunauthorized\n\n\n\n\n\n\n500\n\n\n\n\nIt is busy...Try it later!\n\n\n\n\n\n\n当HttpResponseCode的值为401或500时，接口返回的内容格式如下：\n\n\n\n\n\n\n\n\n\n\n\n\n{\n    \nerror\n: \nunauthorized\n\n}\n\n\n\n\nerror为上表中含义的值\n\n\n当HttpResponseCode的值为400时，接口返回的内容格式如下：\n\n\n{\n    \ncode\n: 101,\n    \nerror\n: \nobject not found for e1kXT22L\n\n}\n\n\n\n\ncode为下表中的错误码，error为下表中的内容\n以下是HttpResponseCode为404时返回内容的详细说明，信息中的%s，%d，%f将替换为详细的信息或具体的值。\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n101\n\n\nobject not found for %s. OR username or password incorrect\n\n\n查询的 对象或Class 不存在 或者 登录接口的用户名或密码不正确\n\n\n\n\n\n\n102\n\n\nInvalid key '%s' for find OR Invalid value for key '%s'. OR %s: invalid geopoint object.\n\n\n查询中的字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。，或查询对应的字段值不匹配，或提供的地理位置格式不正确\n\n\n\n\n\n\n103\n\n\nobjectId required. OR classname '%s' must start with a letter.\n\n\n查询单个对象或更新对象时必须提供objectId 或 非法的 class 名称，class 名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线.\n\n\n\n\n\n\n104\n\n\nrelation className '%s' not exists.\n\n\n关联的class名称不存在\n\n\n\n\n\n\n105\n\n\ninvalid field name: %s. OR It is a reserved field: %s.\n\n\n字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线 或 字段名是\nBmob\n默认保留的，如objectId,createdAt,updateAt,ACL\n\n\n\n\n\n\n106\n\n\n%s: is not a valid Pointer.\n\n\n不是一个正确的指针类型\n\n\n\n\n\n\n107\n\n\ninvalid json: %s.\n\n\n输入的json不是正确的json格式\n\n\n\n\n\n\n107\n\n\nThis endpoint only supports Content-Type: application/json requests, not %s.\n\n\n请求只支持Header头部Content-Type值为application/json或application/json; charset=utf-8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n107\n\n\ninvalid date: %s.\n\n\n时间格式不正确\n\n\n\n\n\n\n107\n\n\nACL shoud be like: \n\n\nACL应该像这样的\n\n\n\n\n\n\n107\n\n\ninvalid op value\n\n\n不是正确的__op的值\n\n\n\n\n\n\n108\n\n\nusername and password required.\n\n\n用户名和密码是必需的\n\n\n\n\n\n\n109\n\n\nlogin data required.\n\n\n登录信息是必需的，如邮箱和密码时缺少其中一个提示此信息\n\n\n\n\n\n\n111\n\n\ninvalid type for key '%s', expected '%s', but got '%s'.\n\n\n传入的字段值与字段类型不匹配，期望是这样(%s)的，但传过来却是这样(%s)的\n\n\n\n\n\n\n112\n\n\nrequests must be an array.\n\n\nrequests的值必须是数组\n\n\n\n\n\n\n113\n\n\nevery request shoud be an object like:\n\n\nrequests数组中每个元素应该是一个像这样子的json对象\n\n\n\n\n\n\n114\n\n\nrequests array larger than %d\n\n\nrequests数组大于50\n\n\n\n\n\n\n117\n\n\nLatitude must be in [-90, 90]: %f. OR Longitude must be in [-180, 180]: %f.\n\n\n纬度范围在[-90, 90] 或 经度范围在[-180, 180]\n\n\n\n\n\n\n120\n\n\nEmail verify should be opened in your app setup page of bmob\n\n\n要使用此功能，请在\nBmob\n后台应用设置中打开邮箱认证功能开关\n\n\n\n\n\n\n131\n\n\nInvalid device token:%s\n\n\n不正确的deviceToken\n\n\n\n\n\n\n132\n\n\nInvalid installation ID:%s\n\n\n不正确的installationId\n\n\n\n\n\n\n133\n\n\nInvalid device type:%s\n\n\n不正确的deviceType\n\n\n\n\n\n\n134\n\n\ndevice token '%s' already token.\n\n\ndeviceToken已经存在\n\n\n\n\n\n\n135\n\n\ninstallation ID '%s' already token.\n\n\ninstallationId已经存在\n\n\n\n\n\n\n136\n\n\n%s cannot be changed by this operation OR deviceToken may not be set for deviceType android\n\n\n只读属性不能修改 或 android设备不需要设置deviceToken\n\n\n\n\n\n\n138\n\n\n%s is read only.\n\n\n表是只读的\n\n\n\n\n\n\n139\n\n\nRole names must be restricted to alphanumeric characters, dashes(-), underscores(_), and spaces.\n\n\n角色名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字、空格、横线以及下划线。\n\n\n\n\n\n\n\n\nrole name '%s' already taken.\n\n\n角色名称已经存在。\n\n\n\n\n\n\n141\n\n\nMissing the push data.\n\n\n缺失推送需要的data参数\n\n\n\n\n\n\n142\n\n\n%s shoule be like: 2013-12-04 00:51:13\n\n\n时间格式应该如下： 2013-12-04 00:51:13\n\n\n\n\n\n\n143\n\n\n%s must be a number\"\n\n\n必须是一个数字\n\n\n\n\n\n\n144\n\n\n%s cannot before now\n\n\n不能是之前的时间\n\n\n\n\n\n\n145\n\n\nfile size error\n\n\n文件大小错误\n\n\n\n\n\n\n146\n\n\nfile name error\n\n\n文件名错误\n\n\n\n\n\n\n147\n\n\nfile offeset error\n\n\n文件分页上传偏移量错误\n\n\n\n\n\n\n148\n\n\nfile ctx error\n\n\n文件上下文错误\n\n\n\n\n\n\n149\n\n\nempty file\n\n\n空文件\n\n\n\n\n\n\n150\n\n\nfile upload error\n\n\n文件上传错误\n\n\n\n\n\n\n151\n\n\nfile delete error\n\n\n文件删除错误\n\n\n\n\n\n\n160\n\n\nimage error\n\n\n图片错误\n\n\n\n\n\n\n161\n\n\nimage mode error\n\n\n图片模式错误\n\n\n\n\n\n\n162\n\n\nimage width error\n\n\n图片宽度错误\n\n\n\n\n\n\n163\n\n\nimage height error\n\n\n图片高度错误\n\n\n\n\n\n\n164\n\n\nimage longEdge error\n\n\n图片长边错误\n\n\n\n\n\n\n165\n\n\nimage shortgEdge error\n\n\n图片短边错误\n\n\n\n\n\n\n201\n\n\n%s missing\n\n\n缺失数据\n\n\n\n\n\n\n202\n\n\nusername '%s' already taken.\n\n\n用户名已经存在\n\n\n\n\n\n\n203\n\n\nemail '%s' already taken.\n\n\n邮箱已经存在\n\n\n\n\n\n\n204\n\n\nyou must provide an email.\n\n\n必须提供一个邮箱地址\n\n\n\n\n\n\n205\n\n\nno user found with email '%s'.\n\n\n没有找到此邮件的用户\n\n\n\n\n\n\n\n\nno user found with username '%s'.\n\n\n没有找到此用户名的用户\n\n\n\n\n\n\n206\n\n\nUser cannot be altered without sessionToken Error.\n\n\n登录用户才能修改自己的信息。RestAPI的Http Header中没有提供sessionToken的正确值，不能修改或删除用户\n\n\n\n\n\n\n207\n\n\ncode error.\n\n\n验证码错误\n\n\n\n\n\n\n208\n\n\nauthData error.\n\n\nauthData不正确\n\n\n\n\n\n\n\n\nauthData already linked by other user.\n\n\nauthData已经绑定了其他用户账户\n\n\n\n\n\n\n209\n\n\nmobilePhoneNumber '%s' already taken.\n\n\n该手机号码已经存在\n\n\n\n\n\n\n210\n\n\nold password incorrect.\n\n\n旧密码不正确\n\n\n\n\n\n\n301\n\n\n%s\n\n\n验证错误详细提示，如邮箱格式不正确\n\n\n\n\n\n\n302\n\n\nyour app setting '%s'.\n\n\nBmob后台设置了应用设置值， 如'不允许SDK创建表 '\n\n\n\n\n\n\n310\n\n\n%s\n\n\n云端逻辑运行错误的详细信息\n\n\n\n\n\n\n311\n\n\ninvalid cloudcode name: %s.\n\n\n云端逻辑名称是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。\n\n\n\n\n\n\n401\n\n\nunique index cannot has duplicate value: %s\n\n\n唯一键不能存在重复的值\n\n\n\n\n\n\n402\n\n\nquery where larger than %d bytes.\n\n\n查询的wher语句长度大于具体多少个字节\n\n\n\n\n\n\n601\n\n\nInvalid bql:%s\n\n\n不正确的BQL查询语句\n\n\n\n\n\n\n\n\nVIP付费限制相关错误码\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n1002\n\n\nTables of the app can create has reached to limit\n\n\n该应用能创建的表数已达到限制\n\n\n\n\n\n\n1003\n\n\nRows of the table can add has reached to limit\n\n\n该表的行数已达到限制\n\n\n\n\n\n\n1004\n\n\nFields of the table can add has reached to limit\n\n\n该表的列数已达到限制\n\n\n\n\n\n\n1005\n\n\nRequest api of the this month has reached to limit\n\n\n每月api请求数量已达到限制\n\n\n\n\n\n\n1006\n\n\nCrontab jobs of the app has reached to limit\n\n\n该应用能创建定时任务数已达到限制\n\n\n\n\n\n\n1007\n\n\nCloudCodes of the app has reached to limit\n\n\n该应用能创建云端逻辑数已达到限制\n\n\n\n\n\n\n1500\n\n\nThe file is larger than file size you can upload\n\n\n你上传的文件大小已超出限制\n\n\n\n\n\n\n\n\n短信功能相关错误码\n\n\n短信功能包含的错误码，除了包括以上的109, 207, 209 状态码外，还定义了以下错误码：\n\n\n\n\n\n\n\n\n错误码\n\n\n内容\n\n\n含义\n\n\n\n\n\n\n\n\n\n\n10010\n\n\nmobile '%s' send message limited.\n\n\n该手机号发送短信达到限制(对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条)\n\n\n\n\n\n\n10011\n\n\nno remaining number for send messages.\n\n\n该账户无可用的发送短信条数\n\n\n\n\n\n\n10012\n\n\nyour credit info must verify ok.\n\n\n身份信息必须审核通过才能使用该功能\n\n\n\n\n\n\n10013\n\n\nsms content illegal.\n\n\n非法短信内容", 
            "title": "错误码"
        }, 
        {
            "location": "/module/error_code/README/index.html#androidsdk", 
            "text": "错误码  内容  含义      9001  AppKey is Null, Please initialize BmobSDK.  Application Id为空，请初始化.    9002  Parse data error  解析返回数据出错    9003  upload file error  上传文件出错    9004  upload file failure  文件上传失败    9005  A batch operation can not be more than 50  批量操作只支持最多50条    9006  objectId is null  objectId为空    9007  BmobFile File size must be less than 10M.  文件大小超过10M    9008  BmobFile File does not exist.  上传文件不存在    9009  No cache data.  没有缓存数据    9010  The network is not normal.(Time out)  网络超时    9011  BmobUser does not support batch operations.  BmobUser类不支持批量操作    9012  context is null.  上下文为空    9013  BmobObject Object names(database table name) format is not correct.  BmobObject（数据表名称）格式不正确    9014  第三方账号授权失败  第三方账号授权失败    9015  其他错误均返回此code  其他错误均返回此code    9016  The network is not available,please check your network!  无网络连接，请检查您的手机网络.    9017  与第三方登录有关的错误，具体请看对应的错误描述  与第三方登录有关的错误，具体请看对应的错误描述    9018  参数不能为空  参数不能为空    9019  格式不正确：手机号码、邮箱地址、验证码  格式不正确：手机号码、邮箱地址、验证码    9020  保存CDN信息失败  保存CDN信息失败    9021  permission not defined.You must write android.permission.WAKE_LOCK in AndroidManifest.xml \" uses-permission android:name=\"android.permission.WAKE_LOCK\".  文件上传缺少wakelock权限    9022  upload failure,please retry.  文件上传失败，请重新上传    9023  please call Bmob.initialize to init sdk.  请调用Bmob类的initialize方法去初始化SDK", 
            "title": "AndroidSDK错误码列表"
        }, 
        {
            "location": "/module/error_code/README/index.html#restapi", 
            "text": "HttpResponseCode  错误码  含义      401   unauthorized    500   It is busy...Try it later!    当HttpResponseCode的值为401或500时，接口返回的内容格式如下：       {\n     error :  unauthorized \n}  error为上表中含义的值  当HttpResponseCode的值为400时，接口返回的内容格式如下：  {\n     code : 101,\n     error :  object not found for e1kXT22L \n}  code为下表中的错误码，error为下表中的内容\n以下是HttpResponseCode为404时返回内容的详细说明，信息中的%s，%d，%f将替换为详细的信息或具体的值。     错误码  内容  含义      101  object not found for %s. OR username or password incorrect  查询的 对象或Class 不存在 或者 登录接口的用户名或密码不正确    102  Invalid key '%s' for find OR Invalid value for key '%s'. OR %s: invalid geopoint object.  查询中的字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。，或查询对应的字段值不匹配，或提供的地理位置格式不正确    103  objectId required. OR classname '%s' must start with a letter.  查询单个对象或更新对象时必须提供objectId 或 非法的 class 名称，class 名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线.    104  relation className '%s' not exists.  关联的class名称不存在    105  invalid field name: %s. OR It is a reserved field: %s.  字段名是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线 或 字段名是 Bmob 默认保留的，如objectId,createdAt,updateAt,ACL    106  %s: is not a valid Pointer.  不是一个正确的指针类型    107  invalid json: %s.  输入的json不是正确的json格式    107  This endpoint only supports Content-Type: application/json requests, not %s.  请求只支持Header头部Content-Type值为application/json或application/json; charset=utf-8         107  invalid date: %s.  时间格式不正确    107  ACL shoud be like:   ACL应该像这样的    107  invalid op value  不是正确的__op的值    108  username and password required.  用户名和密码是必需的    109  login data required.  登录信息是必需的，如邮箱和密码时缺少其中一个提示此信息    111  invalid type for key '%s', expected '%s', but got '%s'.  传入的字段值与字段类型不匹配，期望是这样(%s)的，但传过来却是这样(%s)的    112  requests must be an array.  requests的值必须是数组    113  every request shoud be an object like:  requests数组中每个元素应该是一个像这样子的json对象    114  requests array larger than %d  requests数组大于50    117  Latitude must be in [-90, 90]: %f. OR Longitude must be in [-180, 180]: %f.  纬度范围在[-90, 90] 或 经度范围在[-180, 180]    120  Email verify should be opened in your app setup page of bmob  要使用此功能，请在 Bmob 后台应用设置中打开邮箱认证功能开关    131  Invalid device token:%s  不正确的deviceToken    132  Invalid installation ID:%s  不正确的installationId    133  Invalid device type:%s  不正确的deviceType    134  device token '%s' already token.  deviceToken已经存在    135  installation ID '%s' already token.  installationId已经存在    136  %s cannot be changed by this operation OR deviceToken may not be set for deviceType android  只读属性不能修改 或 android设备不需要设置deviceToken    138  %s is read only.  表是只读的    139  Role names must be restricted to alphanumeric characters, dashes(-), underscores(_), and spaces.  角色名称是大小写敏感的，并且必须以英文字母开头，有效的字符仅限在英文字母、数字、空格、横线以及下划线。     role name '%s' already taken.  角色名称已经存在。    141  Missing the push data.  缺失推送需要的data参数    142  %s shoule be like: 2013-12-04 00:51:13  时间格式应该如下： 2013-12-04 00:51:13    143  %s must be a number\"  必须是一个数字    144  %s cannot before now  不能是之前的时间    145  file size error  文件大小错误    146  file name error  文件名错误    147  file offeset error  文件分页上传偏移量错误    148  file ctx error  文件上下文错误    149  empty file  空文件    150  file upload error  文件上传错误    151  file delete error  文件删除错误    160  image error  图片错误    161  image mode error  图片模式错误    162  image width error  图片宽度错误    163  image height error  图片高度错误    164  image longEdge error  图片长边错误    165  image shortgEdge error  图片短边错误    201  %s missing  缺失数据    202  username '%s' already taken.  用户名已经存在    203  email '%s' already taken.  邮箱已经存在    204  you must provide an email.  必须提供一个邮箱地址    205  no user found with email '%s'.  没有找到此邮件的用户     no user found with username '%s'.  没有找到此用户名的用户    206  User cannot be altered without sessionToken Error.  登录用户才能修改自己的信息。RestAPI的Http Header中没有提供sessionToken的正确值，不能修改或删除用户    207  code error.  验证码错误    208  authData error.  authData不正确     authData already linked by other user.  authData已经绑定了其他用户账户    209  mobilePhoneNumber '%s' already taken.  该手机号码已经存在    210  old password incorrect.  旧密码不正确    301  %s  验证错误详细提示，如邮箱格式不正确    302  your app setting '%s'.  Bmob后台设置了应用设置值， 如'不允许SDK创建表 '    310  %s  云端逻辑运行错误的详细信息    311  invalid cloudcode name: %s.  云端逻辑名称是大小写敏感的，且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。    401  unique index cannot has duplicate value: %s  唯一键不能存在重复的值    402  query where larger than %d bytes.  查询的wher语句长度大于具体多少个字节    601  Invalid bql:%s  不正确的BQL查询语句", 
            "title": "RESTAPI错误码列表"
        }, 
        {
            "location": "/module/error_code/README/index.html#vip", 
            "text": "错误码  内容  含义      1002  Tables of the app can create has reached to limit  该应用能创建的表数已达到限制    1003  Rows of the table can add has reached to limit  该表的行数已达到限制    1004  Fields of the table can add has reached to limit  该表的列数已达到限制    1005  Request api of the this month has reached to limit  每月api请求数量已达到限制    1006  Crontab jobs of the app has reached to limit  该应用能创建定时任务数已达到限制    1007  CloudCodes of the app has reached to limit  该应用能创建云端逻辑数已达到限制    1500  The file is larger than file size you can upload  你上传的文件大小已超出限制", 
            "title": "VIP付费限制相关错误码"
        }, 
        {
            "location": "/module/error_code/README/index.html#_1", 
            "text": "短信功能包含的错误码，除了包括以上的109, 207, 209 状态码外，还定义了以下错误码：     错误码  内容  含义      10010  mobile '%s' send message limited.  该手机号发送短信达到限制(对于一个应用来说，一天给同一手机号发送短信不能超过10条，一小时给同一手机号发送短信不能超过5条，一分钟给同一手机号发送短信不能超过1条)    10011  no remaining number for send messages.  该账户无可用的发送短信条数    10012  your credit info must verify ok.  身份信息必须审核通过才能使用该功能    10013  sms content illegal.  非法短信内容", 
            "title": "短信功能相关错误码"
        }, 
        {
            "location": "/module/common_problem/README/index.html", 
            "text": "对象\n\n\nQ: 为什么我修改表中的某个Number类型的字段，其他Number类型的都变为0呢？\n\n\nA: 继承自BmobObject的类不要用int类型，用Integer。\n\n\n\n\nQ: 定义类名必须和表中的名一致？\n\n\nA: 类名和表名一致，表内字段名和类变量名一致。\n\n\n\n\nQ: 插入一条数据之后怎么获得该数据的id\n\n\nA:\n\n\nGameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId(\n)方法\ngameScore.setPlayerName(\n比目\n);\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(mContext, new SaveListener() {\n\n@Override\npublic void onSuccess() {\n    toast(\n添加数据成功，返回objectId为：\n+gameScore.getObjectId() + ”,数据在服务端的创建时间为：“ + gameScore.getCreatedAt());\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n    // 添加失败\n}\n});\n\n\n\n\n请看代码，成功后gameScore使用getObjectId()就可以获取objectId了。\n\n\n\n\nQ: success方法中获取的数据，用全局变量接收，但是在方法外就接受不到，变量为空\n\n\nA: 请先理解同步和异步的概念，回调中的onsuccess是异步方法，是不能用全局变量接收的，可以直接在onsuccess方法中做ui层面的更新\n\n\n\n\nQ: 缓存路径能指定吗？\n\n\nA: 不可以\n\n\n\n\nQ: 我在User表中增加了一个Number类型的字段，设置为以1自增，但几天过去了，里面的值并未自动增加，这个自增是怎样自增的，还要去哪里设置吗？\n\n\nA: 添加字段的时候选择num类型，有一个自增的checkbox和初始值的input，填一下就可以了\n\n\n\n\nQ: 场景是多个客户端共同操作同一个数据表，更新该表的一个字段的值，如何做到一个客户端更新时锁定该数据表，操作结束时解锁？\n\n\nA: 目前没有该功能，只有Number类型可以使用原子计算器达到该效果\n\n\n\n\nQ: 一次查询多条数据 算是调用了几次API？\n\n\nA: 一次调用算一次\n\n\n\n\nQ: 请问每条数据的objectId都是唯一的吗，我的意思是，假设有个user表，有userName和level两个属性。如果两个对象的这两个属性都相同，其objectId是否就相同？ \n\n\nA: objectId是每一条数据的唯一标示，不会出现重复的。\n\n\n\n\nQ: String 数据类型最大可支持多大数据？\n\n\nA: 最大为16M\n\n\n\n\nQ: 求问怎么获取上传数据后生成的objectid\n\n\nA: 保存数据成功后，你的BmobObject对象就有objectId了的。\n或者你按条件查询得到的数据对象中也是包含objectId的。\n\n\n\n\nQ: 数据查询必须要objectId吗？在用户数据表中，在无法获取用户objectId的情况下，如何查询一个用户是否存在，是否可以通过其他字段查询？\n\n\nA: 单条查询必须使用ObjectId，多条查询时可以添加条件来进行查询。\n\n\n\n\n查询\n\n\nQ: 查询成功，但是list只能在onSuccess方法中使用,如何在本类中的其他地方使用？\n\n\nA: 网路请求都是异步独立线程的，你用\nhandler\n把数据传递出来就可以。\n\n\n\n\nQ: 如果不知道objectId，是否可以通过表中的元素获得数据？\n\n\nA: 添加数据的时候，\nonSuccess\n中可以得到objectId。也可以通过条件查询得到对应的objectId的。\n\n\n\n\nQ: 在Activity关闭的时候如何动态关闭查询？\n\n\nA: 查询都是一次性的，并不需要取消\n\n\n\n\nQ: bmob怎么查询一列数据并合并相同数据？\n\n\nA: 可以使用统计查询中的groupby\n\n\n\n\nQ: bmob的数据库操作方法save insert这些都有开线程吗\n\n\nA: bmob sdk提供的操作都是在线程中运行的，对外都是提供异步的回调方法，其回调方法，比如onsuccess和onFailure等是可以再UI线程中运行的，开发者不需要额外再开线程。\n\n\n\n\nQ: Bmob查询数据结束标志\n\n\nA: 在查询的回调方法中的onSuccess或onFailure触发时都是代表这个查询结束。\n\n\n\n\nQ: Bmob能否进行多表查询？\n\n\nA: 无法用一条语句查多张表，只能单独一个一个查\n\n\n\n\nQ: 怎么设置缓存 让缓存数据在listView显示\n\n\nA: 可以使用缓存查询，具体可以查看官方文档\n\n\n\n\nQ: 怎么通过BmobUser的一个属性列来获取其他列的信息\n\n\nA: 使用bmob的查询功能，查询Username 等于名称的用户信息即可，使用的是addWhereEqualTo方法\n\n\n\n\nQ: 我的应用想只查询最新上传的一组数据，请问该如何操作呢\n\n\nA: 可以根据时间来设置条件，再进行查询\n\n\n\n\nQ: 查询中findListener中的onerror方法不执行,两次测试均是数据库无该数据的，但是程序均不执行onerror方法\n\n\nA: 没有数据不代表查询出错，当没有数据符合你的查询条件时，就会返回空，此时还是执行onSuccess的\n\n\n\n\nQ: 想问问查询的时候排序有多个关键字怎么解决？\n\n\nA: 数据服务的文档中有的，在开发文档的查询数据-\n查询条件-\n排序那里：\n\n\n排序\n\n\n对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：\n\n\n// 根据score字段升序显示数据\nquery.order(\"score\");\n// 根据score字段降序显示数据\nquery.order(\"-score\");\n// 多个排序字段可以用（，）号分隔\nquery.order(\"-score,createdAt\");\n说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。\n\n\n\n\n数据关联\n\n\nQ: 我有个Relation字段，想用它来记录喜欢这篇文章的用户，我该怎么添加里面的数据呢？\n\n\nA: 这个问题请看 \n数据关联\n 相关文档。\n\n\n\n\nQ: Relation字段 能否像pointer一样在查询的时候一并把关联的记录也查询下来，不需要二次查询\n\n\nA: 目前并没有这个功能，建议使用pointer\n\n\n\n\nQ: activity是一个表，里面有一个BmobPointer org指向BmobUser，\nactivity.getOrg.getObjectId总是为空呢？\n\n\nA: 查询的时候应该没有用includ查询进去\n\n\n\n\nQ: 查询数据时，表中的一个字段是pointer字段，如何将这个pointer字段的一个属性作为查询匹配条件？\n\n\nA:\n\n\nBmobQuery\nComment\n query = new BmobQuery\nComment\n();\nBmobQuery\nPost\n innerQuery = new BmobQuery\nPost\n();\ninnerQuery.addWhereExists(\nimage\n, true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用\nPost\n字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery(\npost\n, \nPost\n, innerQuery);\nquery.findObjects(this, new FindListener\nComment\n() {\n@Override\npublic void onSuccess(List\nComment\n object) {\n    // TODO Auto-generated method stub\n    toast(\n查询成功:\n);\n}\n@Override\npublic void onError(int code, String msg) {\n    // TODO Auto-generated method stub\n    toast(\n查询失败:\n+msg);\n}\n});\n\n\n\n\n如上，就是使用内部查询就可以实现你的需求了，只需要将查询条件和表名换成你需要的就可以了～\n\n\n\n\nQ: 如果一个用户要收藏一个产品应该怎么定义对象\n\n\nA: 可以使用pointer类型\n\n\n\n\nQ: 删除关联关系\n我现在有评论类如下：\n\n\npublic class Comment extends BmobObject {\nprivate String comment;\nprivate Found found;\nprivate Lost lost;\nprivate MyUser user;\n}\n\n\n\n\n如果我想删除Lost类或者Found类的某条数据\n其对应的Comment会被同时删除吗？\n如果不能应该怎么实现同时删除？\n\n\nA: 不能同时删除，对于不同数据表的数据只能分别执行删除操作。\n\n\n\n\nQ: 查询时 include 两个Pointer字段后会把前一个的数据冲掉\n对表 AaaaEntity 查询时 include 两个Pointer字段后会把前一个的数据冲掉,如:\nbmobQuery.include(\"userAuthor\");\nbmobQuery.include(\"xxxxEntity\");\n\n\n则:\naaaaEntity.getUserAuthor.getName()返回空\n\n\n如果去掉后一行\nbmobQuery.include(\"userAuthor\");\n//bmobQuery.include(\"xxxxEntity\");\n或\n移到后面：\nbmobQuery.include(\"xxxxEntity\");\nbmobQuery.include(\"userAuthor\");\n\n\naaaaEntity.getUserAuthor.getName() 就能正常返回值\n\n\nA: include的用法在文档里面已经说明了的(http://docs.bmob.cn/android/de ... clude用法),想include多个就这样用：query.include(\"x1,x2\");\n\n\n\n\n用户管理\n\n\nQ: 打开了邮箱验证功能，注册成功后未验证也能登录成功？\n\n\nA: Bmob SDK中，邮箱的验证和用户的注册登录是异步的关系，也就是说，即使用户没有点击邮箱验证功能，也是一样可以登录成功的。如果需要限制用户的登录或者只能查看到登录后的部分功能，可以使用\nBmobUser.getEmailVerified\n。\n\n\n\n\nQ: Bmob如何实现用户登录之后获取数据读写权限，以及如何实现登出操作的？\n\n\nA: 用户登录之后，我们会把获取到的用户信息保存在本地文件中，你可以通过\nBmobUser.getCurrentUser\n方法获取对应的值，当调用 \nlogout\n方法之后，这些缓存的数据就会清除。如果不调用\nlogout\n方法，下次重新打开这个应用，还是可以通过\nBmobUser.getCurrentUser\n方法获得上次登陆的用户信息，从而判断是否登陆过。\n\n\n\n\nQ: BmobUser.logOut(getApplicationContext()); //清除缓存用户对象\n这个只是针对本地缓存，看了源码，只是对本地清除，没有真正向服务端注销登录的账号，请问是怎么去处理这个问题\n\n\nA: BmobSDK中的BmobUser登录，只是登录成功后缓存用户信息到本地。服务端并没有记录用户的登录状态，所以退出登录并不需要向服务器注销。\n\n\n\n\nQ: Bmob支持第三方登录吗？怎么做？\n\n\nA: 支持，官方的文档上有介绍。\n\n\n\n\nQ: 为什么邮箱验证还没去验证却可以登录\n\n\nA: 是可以的，邮箱验证那个字段需要开发者根据需求自行决定要不要使用\n\n\n\n\nQ: 登录时异常退出MyUser declares multiple JSON fields named mobilePhoneNumber\n\n\nA: MyUser定义了一个Bmob的系统字段呀，你可以看看用户管理那里的文档，里面有介绍说明BmobUser的特有属性，以下摘抄自文档：\n\n\nBmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\nusername: 用户的用户名（必需）。\npassword: 用户的密码（必需）。\nemail: 用户的电子邮件地址（可选）。\nemailVerified:邮箱认证状态（可选）。\nmobilePhoneNumber：手机号码（可选）。\nmobilePhoneNumberVerified：手机号码的认证状态（可选）。\n\n\n\n\nQ: 第三方登录之后该怎么获得User的objectId呢？\n\n\nA: 登陆成功之后，系统就会给你生成一个objectId的，你正常的通过 user.getObjectId() 就可以得到了\n\n\n\n\nQ: 如何修改user表中其他用户的数据\n\n\nA: 直接在web控制台修改或者使用masterkey\n\n\n\n\nQ: 修改数据提示User cannot be altered without sessionToken Error.\n\n\nA: 这种情况一般都是没有进行用户登录就对用户信息进行更新导致的\n\n\n\n\nQ: 更新用户update时失败，9012错误\n\n\nA: 9012是context is null,没传上下文对象\n\n\n\n\nQ: 用了getobjectId方法为什么还是显示objectId cant't be empty。\n\n\npublic void setsj(View v){\nfinal User setUser = new User();\nList\nString\n a=new ArrayList\nString\n();\na.add(\n5cd431f659\n);\na.add(\n4c2184e8ea\n);\nsetUser.setFriends(a);\nsetUser.update(this, setUser.getObjectId(), new UpdateListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i(\nbmob\n, \n更新成功：\n);\n        toast(\n更新成功\n);\n    }\n\n    @Override\n    public void onFailure(int code, String msg) {\n        // TODO Auto-generated method stub\n        Log.i(\nbmob\n,\n更新失败：\n+msg);\n        toast(\n更新失败\n);\n    }\n});\n}\n\n\n\n\n\n这段代码是通过点击一个button然后更新我写好的数据，可一直显示更新失败，查看logcat显示objectId cant't be empty。可是我有用setUser.getObjectId()啊，为什么还是说ID为空？\n\n\nA: 你的user并不是通过登录得到的，而是自己生成的，并没有objectid，需要从服务器上获取的数据才有objectid\n\n\n\n\nQ: 更新了用户信息后 服务器都更新了数据 但是本地缓存用户没有更新\n\n\nA: 更新用户信息后需要从新登陆，本地用户信息才会更新。\n\n\n\n\nQ: 登录后在个人资料中上传头像在用户表，并且要头像和用户要对应。\n\n\nA: 上传图片成功后，将BmobFile对象更新到当前用户的头像字段中即可。\n\n\n\n\nQ: 在数据下_User 下把email添加后为啥 emailVerified Boolean 这一栏显示的是false 是什么原因呢\n\n\nA: 该字段需要注册用户点击了验证邮件才会主动设置为true\n\n\n\n\n数据实时功能\n\n\nQ: 如何实现Bmob服务端向Android应用发送实时通知？如某个数据过高需要提醒APP用户\n\n\nA: 以使用实时数据监听功能来实现\n\n\n\n\nQ: 登录之后，怎么获取用户的信息并显示出来\n\n\nA: 登录成功之后就可以通过getCurrentUser方法获取本地用户信息\n\n\n\n\nACL和角色\n\n\nQ: 例如我已经有一个角色叫Chief，我怎么用代码给它添加成员？直接new BmobRole(\"Chief\")然后再getUsers().add然后再save?\n但这个代码不应该是新建一个角色吗？\n如果是用BmobQuery\n获取的话获取失败，返回101错误\n\n\nA:\n\n\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole(\nHR\n);\nBmobRole cashier = new BmobRole(\nCashier\n);\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this); \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save(this);\n\n\n\n\n\n\nQ: 是否可以针一行数据的某一个字段控制读写权限 ？\n是否可以针一行数据的某一个字段控制读写权限 ？例如，UserA 发了一条说说，这条说说只有UserA可以写，其它用户可以读，但是其中有一个点赞计数字段，所有用户都可以对这条说说点赞，点赞后，这个点赞计数字段值就加1。\n\n\nA: 没有针对一个字段控制读写的，如果需要，可以将这些需要控制的另外建一个表，使用pointer字段指向该表来获取\n\n\n\n\n地理位置\n\n\nQ: 基于地理位置的查询是根据什么排序的\n\n\nA: 是按照距离从近到远来进行排序的\n\n\n\n\n自动更新\n\n\nQ: 自动更新生成的表和文档上的不一致\n\n\nA: 没有调用initAppversion方法\n\n\n\n\nQ: 自动更新，如何实现只获取是否有新版本，不弹出对话框。\n\n\nA: 目前SDK中暂没有这个功能，后续版本会考虑添加\n\n\n\n\n文件\n\n\nQ: Bmob如何实现储存和传输图片？\n\n\nA: 通过\nBmobFile\n类上传图片，上传成功之后，会返回一个\nBmobFile\n，你从这个\nBmobFile\n可以得到文件上传之后的url，把这个url保存到你的对应表中。下载的时候，先查询数据表得到url，然后下载这个图片就可以了。 \n\n\n\n\nQ: Bmob如何将整批图片下载在本地呢？\n\n\nA: 首先先查询，得到全部数据，从而得到图片的url列表，再用一些下载文件的代码把图片批量下载下来。\n\n\n\n\nQ: BmobFile类最多可以保存多少张图片？\n\n\nA: \nBmobFile\n类只能保存一张图片，你可以用\nBmobFile\n上传图片，得到图片的url，保存的字段用string或者array。\n\n\n\n\nQ:怎么让表的某个字段包含多张图片？\nA:用array来存储文件的url\n\n\n\n\nQ: 能把json文件放在bmob里，并配置一个专门的地址，然后APP通过这路径下载或者读取吗？\n\n\nA: 用文件服务实现即可。\n\n\n\n\nQ: 怎么通过objectID获得文件的下载路径？\n\n\nA:\n\n\n// 根据objectId查询数据\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.getObject(this, \na203eba875\n, new GetListener\nGameScore\n() {\n\n@Override\npublic void onSuccess(GameScore object) {\n// TODO Auto-generated method stub\ntoast(\n查询成功：\n);\n//获得playerName的信息\nobject.getPlayerName();\n//获得数据的objectId信息\nobject.getObjectId();\n//获得createdAt数据创建时间（注意是：createdAt，不是createAt）\nobject.getCreatedAt();\n\n// 假设GameScore对象中有一列是BmobFile类型的icon\n// 如下取出查询到的数据中的BmobFile类型，得到下载地址\nBmobFile icon = object.getIcon();\nString url = icon.getFileUrl();\n\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n// TODO Auto-generated method stub\ntoast(\n查询失败：\n+arg0);\n}\n\n});\n\n\n\n\n\n\n\nQ: 为什么最新的SDK里面的BmobFile没有loadImageThumbnail方法\n\n\nA: 最新的SDK已经将图像处理的接口去掉了，需要用户自己在本地处理\n\n\n\n\nQ: 怎么去在批量上完图片之后，取得对应的缩略图呢？\n\n\nA: 缩略图功能已经取消，请在客户端进行图片的处理\n\n\n\n\nQ: 9015your uploading task is canceled. 安卓文件上传无响应\n\n\nA: 调用了bmobfile.cancel()方法会出错该提示。\n\n\n\n\nQ: 表中有一列数据为BmobFile类型 ，数据为.TXT格式 ，怎么将文件下载下来\n\n\nA: 查询这一行数据，在结果中从这一列对应的BmobFile对象中用getFileUrl()得到文件的地址，再进行下载。\n\n\n\n\nQ: listview显示Bmob上的图片怎么实现？\n\n\nA: 图片上传后会返回相应url给客户端的，可以在表中，在需要显示的时候利用url将图片下载下来进行显示\n\n\n\n\nQ: 我通过软件上传了文件到bmob后端云。怎么获得该文件url。\n\n\nA: 上传后会有url返回\n\n\n\n\nQ: bmob可以通过客户端下载文件吗？\n\n\nA: 上传到Bmob之后就会返回文件的地址，至于怎么下载，由你来决定。\n\n\n\n\nQ: 为什么我上传的文件(图片)已经删除了，但是通过url仍然可以访问到图片呢？\n\n\nA: CDN缓存的，过一段时间就会完全删除\n\n\n\n\n其它问题\n\n\nQ: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\n\nA: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.\n\n\n这是重复导包造成的，你用的v4和v7包重复了，你需要去掉报错的那个模块\n\n\n\n\nQ: 我使用BmobUser.login接口,返回onFailure的参数code分别对应什么情况?有说明文档么?\n\n\nA: \nandroid 错误码列表\n\n\n\n\nQ: App_ID is not setted出现什么原因？\n\n\nA: 初始化BmobSDK时需要传入你自己应用的ApplicationID\n\n\n\n\nQ: Duplicate files copied in APK META-INF/maven/com.squareup.okhttp/okhttp/pom.xml\n\n\nA: 导了重复的包\n\n\n\n\nQ: bomb_AndroidSDK_V3.4.7_0518 中文乱码\n\n\nA: SDK的demo的编码格式是gbk,换下格式就行\n\n\n\n\nQ: android Bmobquery 开两个线程 分别查两个不一样的表，返回数据有问题\n\n\nA: sdk中的很多方法本身就是在子线程中执行的，开发者没必要开子线程(创建子线程和线程池管理SDK都封装好了)。\n\n\n\n\nQ: 查询出了回调函数，List就变空了\n\n\nA: 请先理解下同步和异步的概念，bmob目前的接口提供的都是异步回调函数，建议在onsucess/onFailure中进行ui操作\n\n\n\n\nQ: Bmob的各个SDK可以使用Application的Context来初始化吗\n\n\nA: 可以的。最好是用Application的Context来初始化。\n\n\n\n\nQ: bmob的jar包和volley包冲突怎么回事\n\n\nA: bmob的jar里面包含了volley,无需再次导入\n\n\n\n\nQ: 移动端和WEB端能用BMOB作为云端，实现数据共享么？\n\n\nA: 可以的，使用同一个app id来进行操作即可\n\n\n\n\nQ: 真机运行时控制台输出 Error:warning: Ignoring InnerClasses attribute for an anonymous inner class\n\n\nA: 可以试试在你的app的build.gradle的android标签下添加如下：\n\n\nlintOptions {\nignoreWarnings true\n}\n\n\n\n\n\n\nQ: 把应用装到手机很慢，一直在Gradle Build\n\n\nA: 如果你确定你的应用所需的jar包已经下载完了，可以将gradle设置成离线模式\n\n\n\n\nQ: BmobSDK能导入源码开发编译吗\n\n\nA: BmobSDK目前并未开源\n\n\n\n\nQ: 3.4.7 sdk java.lang.UnsatisfiedLinkError 怎么破\njava.lang.UnsatisfiedLinkError: Couldn't load bmob from loader dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/top.kiuber.sharemy-1.apk\"],nativeLibraryDirectories=[/data/app-lib/top.kiuber.sharemy-1, /vendor/lib, /system/lib]]]: findLibrary returned null\n\n\nA: 详情移步到博客http://www.kiuber.top/2016/05/24/android-studio-add-so/\n问题已经被攻克，原因是so库文件未导入。\n解决方法：在project视图下，在main文件夹内新建jniLibs文件夹，把对应so库文件夹及文件复制到jniLibs文件内，然后在MainActivity.java文件\n\n\n\n\nQ: 邮箱验证用哪个SDK\n\n\nA: 使用数据服务SDK即可\n\n\n\n\nQ: Android studio连接Bmob时报错\n\n\njava.lang.UnsatisfiedLinkError: com.android.tools.fd.runtime.IncrementalClassLoader$DelegateClassLoader[DexPathList[[dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-support-annotations-23.4.0_eff36cb3dd5776bcc7dfe63d3c4af3d7d0b02909-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_9-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_8-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_7-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_6-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_5-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_4-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_3-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_2-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_1-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_0-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okio-1.7.0_16f89fb230458d29c309937f6ab11ce75258c504-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okhttp-3.2.0_8f755226a0726d7921fa90d83c674c16a1bd0ee3-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-internal_impl-23.4.0_2c4831db21059d6465959fb999a28d5a6fe10599-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-vector-drawable-23.4.0_eb28b4ae1a0615e1130648d3b547db30e6e89fd0-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-v4-23.4.0_c594c96eba293bbb78cda22a0502566240fb4409-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-appcompat-v7-23.4.0_39e8b9d21669eb9eb3df764bcd49eb0facc75e07-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-animated-vector-drawable-23.4.0_613291d2784b41eebf3800d518847e90b2efa55b-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-sdk-3.4.7_3bb8e20fe85419a97fea506c0c8a8a8fe18f45d5-classes.dex\n, dex file \n/data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-push-0.9_35e71e7e49d7888481221634e134fec14816f381-classes.dex\n],nativeLibraryDirectories=[/data/app/com.example.administrator.bmob2-2/lib/arm, /vendor/lib, /system/lib]]] couldn't find \nlibbmob.so\n\n\n\n\nA: 使用aar格式的SDK，这样就不用导入so库\n\n\n\n\nQ: sdk怎么和Retrofit这些库一起使用呢\n\n\nA: 出现这个问题的原因是retrofit依赖的okhttp和sdk的远程aar包中的okhttp重复导致的，将会导致编译不过，解决方式有：\n\n1 下载Retrofit的jar包，采用本地依赖的方式；\n\n2 compile Retrofit的配置加下exclude，把重复的okhttp除去，如下：\n\n\ncompile ('com.squareup.retrofit2:retrofit:2.1.0'){\n        exclude group : 'com.squareup.okhttp3'\n    }", 
            "title": "常见问题"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_1", 
            "text": "Q: 为什么我修改表中的某个Number类型的字段，其他Number类型的都变为0呢？  A: 继承自BmobObject的类不要用int类型，用Integer。   Q: 定义类名必须和表中的名一致？  A: 类名和表名一致，表内字段名和类变量名一致。   Q: 插入一条数据之后怎么获得该数据的id  A:  GameScore gameScore = new GameScore();\n//注意：不能调用gameScore.setObjectId( )方法\ngameScore.setPlayerName( 比目 );\ngameScore.setScore(89);\ngameScore.setIsPay(false);\ngameScore.save(mContext, new SaveListener() {\n\n@Override\npublic void onSuccess() {\n    toast( 添加数据成功，返回objectId为： +gameScore.getObjectId() + ”,数据在服务端的创建时间为：“ + gameScore.getCreatedAt());\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n    // 添加失败\n}\n});  请看代码，成功后gameScore使用getObjectId()就可以获取objectId了。   Q: success方法中获取的数据，用全局变量接收，但是在方法外就接受不到，变量为空  A: 请先理解同步和异步的概念，回调中的onsuccess是异步方法，是不能用全局变量接收的，可以直接在onsuccess方法中做ui层面的更新   Q: 缓存路径能指定吗？  A: 不可以   Q: 我在User表中增加了一个Number类型的字段，设置为以1自增，但几天过去了，里面的值并未自动增加，这个自增是怎样自增的，还要去哪里设置吗？  A: 添加字段的时候选择num类型，有一个自增的checkbox和初始值的input，填一下就可以了   Q: 场景是多个客户端共同操作同一个数据表，更新该表的一个字段的值，如何做到一个客户端更新时锁定该数据表，操作结束时解锁？  A: 目前没有该功能，只有Number类型可以使用原子计算器达到该效果   Q: 一次查询多条数据 算是调用了几次API？  A: 一次调用算一次   Q: 请问每条数据的objectId都是唯一的吗，我的意思是，假设有个user表，有userName和level两个属性。如果两个对象的这两个属性都相同，其objectId是否就相同？   A: objectId是每一条数据的唯一标示，不会出现重复的。   Q: String 数据类型最大可支持多大数据？  A: 最大为16M   Q: 求问怎么获取上传数据后生成的objectid  A: 保存数据成功后，你的BmobObject对象就有objectId了的。\n或者你按条件查询得到的数据对象中也是包含objectId的。   Q: 数据查询必须要objectId吗？在用户数据表中，在无法获取用户objectId的情况下，如何查询一个用户是否存在，是否可以通过其他字段查询？  A: 单条查询必须使用ObjectId，多条查询时可以添加条件来进行查询。", 
            "title": "对象"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_2", 
            "text": "Q: 查询成功，但是list只能在onSuccess方法中使用,如何在本类中的其他地方使用？  A: 网路请求都是异步独立线程的，你用 handler 把数据传递出来就可以。   Q: 如果不知道objectId，是否可以通过表中的元素获得数据？  A: 添加数据的时候， onSuccess 中可以得到objectId。也可以通过条件查询得到对应的objectId的。   Q: 在Activity关闭的时候如何动态关闭查询？  A: 查询都是一次性的，并不需要取消   Q: bmob怎么查询一列数据并合并相同数据？  A: 可以使用统计查询中的groupby   Q: bmob的数据库操作方法save insert这些都有开线程吗  A: bmob sdk提供的操作都是在线程中运行的，对外都是提供异步的回调方法，其回调方法，比如onsuccess和onFailure等是可以再UI线程中运行的，开发者不需要额外再开线程。   Q: Bmob查询数据结束标志  A: 在查询的回调方法中的onSuccess或onFailure触发时都是代表这个查询结束。   Q: Bmob能否进行多表查询？  A: 无法用一条语句查多张表，只能单独一个一个查   Q: 怎么设置缓存 让缓存数据在listView显示  A: 可以使用缓存查询，具体可以查看官方文档   Q: 怎么通过BmobUser的一个属性列来获取其他列的信息  A: 使用bmob的查询功能，查询Username 等于名称的用户信息即可，使用的是addWhereEqualTo方法   Q: 我的应用想只查询最新上传的一组数据，请问该如何操作呢  A: 可以根据时间来设置条件，再进行查询   Q: 查询中findListener中的onerror方法不执行,两次测试均是数据库无该数据的，但是程序均不执行onerror方法  A: 没有数据不代表查询出错，当没有数据符合你的查询条件时，就会返回空，此时还是执行onSuccess的   Q: 想问问查询的时候排序有多个关键字怎么解决？  A: 数据服务的文档中有的，在开发文档的查询数据- 查询条件- 排序那里：  排序  对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：  // 根据score字段升序显示数据\nquery.order(\"score\");\n// 根据score字段降序显示数据\nquery.order(\"-score\");\n// 多个排序字段可以用（，）号分隔\nquery.order(\"-score,createdAt\");\n说明：多个字段排序时，先按第一个字段进行排序，再按第二个字段进行排序，依次进行。", 
            "title": "查询"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_3", 
            "text": "Q: 我有个Relation字段，想用它来记录喜欢这篇文章的用户，我该怎么添加里面的数据呢？  A: 这个问题请看  数据关联  相关文档。   Q: Relation字段 能否像pointer一样在查询的时候一并把关联的记录也查询下来，不需要二次查询  A: 目前并没有这个功能，建议使用pointer   Q: activity是一个表，里面有一个BmobPointer org指向BmobUser，\nactivity.getOrg.getObjectId总是为空呢？  A: 查询的时候应该没有用includ查询进去   Q: 查询数据时，表中的一个字段是pointer字段，如何将这个pointer字段的一个属性作为查询匹配条件？  A:  BmobQuery Comment  query = new BmobQuery Comment ();\nBmobQuery Post  innerQuery = new BmobQuery Post ();\ninnerQuery.addWhereExists( image , true);\n// 第一个参数为评论表中的帖子字段名post\n// 第二个参数为Post字段的表名，也可以直接用 Post 字符串的形式\n// 第三个参数为内部查询条件\nquery.addWhereMatchesQuery( post ,  Post , innerQuery);\nquery.findObjects(this, new FindListener Comment () {\n@Override\npublic void onSuccess(List Comment  object) {\n    // TODO Auto-generated method stub\n    toast( 查询成功: );\n}\n@Override\npublic void onError(int code, String msg) {\n    // TODO Auto-generated method stub\n    toast( 查询失败: +msg);\n}\n});  如上，就是使用内部查询就可以实现你的需求了，只需要将查询条件和表名换成你需要的就可以了～   Q: 如果一个用户要收藏一个产品应该怎么定义对象  A: 可以使用pointer类型   Q: 删除关联关系\n我现在有评论类如下：  public class Comment extends BmobObject {\nprivate String comment;\nprivate Found found;\nprivate Lost lost;\nprivate MyUser user;\n}  如果我想删除Lost类或者Found类的某条数据\n其对应的Comment会被同时删除吗？\n如果不能应该怎么实现同时删除？  A: 不能同时删除，对于不同数据表的数据只能分别执行删除操作。   Q: 查询时 include 两个Pointer字段后会把前一个的数据冲掉\n对表 AaaaEntity 查询时 include 两个Pointer字段后会把前一个的数据冲掉,如:\nbmobQuery.include(\"userAuthor\");\nbmobQuery.include(\"xxxxEntity\");  则:\naaaaEntity.getUserAuthor.getName()返回空  如果去掉后一行\nbmobQuery.include(\"userAuthor\");\n//bmobQuery.include(\"xxxxEntity\");\n或\n移到后面：\nbmobQuery.include(\"xxxxEntity\");\nbmobQuery.include(\"userAuthor\");  aaaaEntity.getUserAuthor.getName() 就能正常返回值  A: include的用法在文档里面已经说明了的(http://docs.bmob.cn/android/de ... clude用法),想include多个就这样用：query.include(\"x1,x2\");", 
            "title": "数据关联"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_4", 
            "text": "Q: 打开了邮箱验证功能，注册成功后未验证也能登录成功？  A: Bmob SDK中，邮箱的验证和用户的注册登录是异步的关系，也就是说，即使用户没有点击邮箱验证功能，也是一样可以登录成功的。如果需要限制用户的登录或者只能查看到登录后的部分功能，可以使用 BmobUser.getEmailVerified 。   Q: Bmob如何实现用户登录之后获取数据读写权限，以及如何实现登出操作的？  A: 用户登录之后，我们会把获取到的用户信息保存在本地文件中，你可以通过 BmobUser.getCurrentUser 方法获取对应的值，当调用  logout 方法之后，这些缓存的数据就会清除。如果不调用 logout 方法，下次重新打开这个应用，还是可以通过 BmobUser.getCurrentUser 方法获得上次登陆的用户信息，从而判断是否登陆过。   Q: BmobUser.logOut(getApplicationContext()); //清除缓存用户对象\n这个只是针对本地缓存，看了源码，只是对本地清除，没有真正向服务端注销登录的账号，请问是怎么去处理这个问题  A: BmobSDK中的BmobUser登录，只是登录成功后缓存用户信息到本地。服务端并没有记录用户的登录状态，所以退出登录并不需要向服务器注销。   Q: Bmob支持第三方登录吗？怎么做？  A: 支持，官方的文档上有介绍。   Q: 为什么邮箱验证还没去验证却可以登录  A: 是可以的，邮箱验证那个字段需要开发者根据需求自行决定要不要使用   Q: 登录时异常退出MyUser declares multiple JSON fields named mobilePhoneNumber  A: MyUser定义了一个Bmob的系统字段呀，你可以看看用户管理那里的文档，里面有介绍说明BmobUser的特有属性，以下摘抄自文档：  BmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\nusername: 用户的用户名（必需）。\npassword: 用户的密码（必需）。\nemail: 用户的电子邮件地址（可选）。\nemailVerified:邮箱认证状态（可选）。\nmobilePhoneNumber：手机号码（可选）。\nmobilePhoneNumberVerified：手机号码的认证状态（可选）。   Q: 第三方登录之后该怎么获得User的objectId呢？  A: 登陆成功之后，系统就会给你生成一个objectId的，你正常的通过 user.getObjectId() 就可以得到了   Q: 如何修改user表中其他用户的数据  A: 直接在web控制台修改或者使用masterkey   Q: 修改数据提示User cannot be altered without sessionToken Error.  A: 这种情况一般都是没有进行用户登录就对用户信息进行更新导致的   Q: 更新用户update时失败，9012错误  A: 9012是context is null,没传上下文对象   Q: 用了getobjectId方法为什么还是显示objectId cant't be empty。  public void setsj(View v){\nfinal User setUser = new User();\nList String  a=new ArrayList String ();\na.add( 5cd431f659 );\na.add( 4c2184e8ea );\nsetUser.setFriends(a);\nsetUser.update(this, setUser.getObjectId(), new UpdateListener() {\n\n    @Override\n    public void onSuccess() {\n        // TODO Auto-generated method stub\n        Log.i( bmob ,  更新成功： );\n        toast( 更新成功 );\n    }\n\n    @Override\n    public void onFailure(int code, String msg) {\n        // TODO Auto-generated method stub\n        Log.i( bmob , 更新失败： +msg);\n        toast( 更新失败 );\n    }\n});\n}  这段代码是通过点击一个button然后更新我写好的数据，可一直显示更新失败，查看logcat显示objectId cant't be empty。可是我有用setUser.getObjectId()啊，为什么还是说ID为空？  A: 你的user并不是通过登录得到的，而是自己生成的，并没有objectid，需要从服务器上获取的数据才有objectid   Q: 更新了用户信息后 服务器都更新了数据 但是本地缓存用户没有更新  A: 更新用户信息后需要从新登陆，本地用户信息才会更新。   Q: 登录后在个人资料中上传头像在用户表，并且要头像和用户要对应。  A: 上传图片成功后，将BmobFile对象更新到当前用户的头像字段中即可。   Q: 在数据下_User 下把email添加后为啥 emailVerified Boolean 这一栏显示的是false 是什么原因呢  A: 该字段需要注册用户点击了验证邮件才会主动设置为true", 
            "title": "用户管理"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_5", 
            "text": "Q: 如何实现Bmob服务端向Android应用发送实时通知？如某个数据过高需要提醒APP用户  A: 以使用实时数据监听功能来实现   Q: 登录之后，怎么获取用户的信息并显示出来  A: 登录成功之后就可以通过getCurrentUser方法获取本地用户信息", 
            "title": "数据实时功能"
        }, 
        {
            "location": "/module/common_problem/README/index.html#acl", 
            "text": "Q: 例如我已经有一个角色叫Chief，我怎么用代码给它添加成员？直接new BmobRole(\"Chief\")然后再getUsers().add然后再save?\n但这个代码不应该是新建一个角色吗？\n如果是用BmobQuery 获取的话获取失败，返回101错误  A:  //创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole hr = new BmobRole( HR );\nBmobRole cashier = new BmobRole( Cashier );\n\n//将hr_zhang和hr_luo归属到hr角色中\nhr.getUsers().add(hr_zhang);\nhr.getUsers().add(hr_luo);\n//保存到云端角色表中（web端可以查看Role表）\nhr.save(this); \n\n//将cashier_xie归属到cashier角色中\ncashier.getUsers().add(cashier_xie);\n//保存到云端角色表中（web端可以查看Role表）\ncashier.save(this);   Q: 是否可以针一行数据的某一个字段控制读写权限 ？\n是否可以针一行数据的某一个字段控制读写权限 ？例如，UserA 发了一条说说，这条说说只有UserA可以写，其它用户可以读，但是其中有一个点赞计数字段，所有用户都可以对这条说说点赞，点赞后，这个点赞计数字段值就加1。  A: 没有针对一个字段控制读写的，如果需要，可以将这些需要控制的另外建一个表，使用pointer字段指向该表来获取", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_6", 
            "text": "Q: 基于地理位置的查询是根据什么排序的  A: 是按照距离从近到远来进行排序的", 
            "title": "地理位置"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_7", 
            "text": "Q: 自动更新生成的表和文档上的不一致  A: 没有调用initAppversion方法   Q: 自动更新，如何实现只获取是否有新版本，不弹出对话框。  A: 目前SDK中暂没有这个功能，后续版本会考虑添加", 
            "title": "自动更新"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_8", 
            "text": "Q: Bmob如何实现储存和传输图片？  A: 通过 BmobFile 类上传图片，上传成功之后，会返回一个 BmobFile ，你从这个 BmobFile 可以得到文件上传之后的url，把这个url保存到你的对应表中。下载的时候，先查询数据表得到url，然后下载这个图片就可以了。    Q: Bmob如何将整批图片下载在本地呢？  A: 首先先查询，得到全部数据，从而得到图片的url列表，再用一些下载文件的代码把图片批量下载下来。   Q: BmobFile类最多可以保存多少张图片？  A:  BmobFile 类只能保存一张图片，你可以用 BmobFile 上传图片，得到图片的url，保存的字段用string或者array。   Q:怎么让表的某个字段包含多张图片？\nA:用array来存储文件的url   Q: 能把json文件放在bmob里，并配置一个专门的地址，然后APP通过这路径下载或者读取吗？  A: 用文件服务实现即可。   Q: 怎么通过objectID获得文件的下载路径？  A:  // 根据objectId查询数据\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.getObject(this,  a203eba875 , new GetListener GameScore () {\n\n@Override\npublic void onSuccess(GameScore object) {\n// TODO Auto-generated method stub\ntoast( 查询成功： );\n//获得playerName的信息\nobject.getPlayerName();\n//获得数据的objectId信息\nobject.getObjectId();\n//获得createdAt数据创建时间（注意是：createdAt，不是createAt）\nobject.getCreatedAt();\n\n// 假设GameScore对象中有一列是BmobFile类型的icon\n// 如下取出查询到的数据中的BmobFile类型，得到下载地址\nBmobFile icon = object.getIcon();\nString url = icon.getFileUrl();\n\n}\n\n@Override\npublic void onFailure(int code, String arg0) {\n// TODO Auto-generated method stub\ntoast( 查询失败： +arg0);\n}\n\n});   Q: 为什么最新的SDK里面的BmobFile没有loadImageThumbnail方法  A: 最新的SDK已经将图像处理的接口去掉了，需要用户自己在本地处理   Q: 怎么去在批量上完图片之后，取得对应的缩略图呢？  A: 缩略图功能已经取消，请在客户端进行图片的处理   Q: 9015your uploading task is canceled. 安卓文件上传无响应  A: 调用了bmobfile.cancel()方法会出错该提示。   Q: 表中有一列数据为BmobFile类型 ，数据为.TXT格式 ，怎么将文件下载下来  A: 查询这一行数据，在结果中从这一列对应的BmobFile对象中用getFileUrl()得到文件的地址，再进行下载。   Q: listview显示Bmob上的图片怎么实现？  A: 图片上传后会返回相应url给客户端的，可以在表中，在需要显示的时候利用url将图片下载下来进行显示   Q: 我通过软件上传了文件到bmob后端云。怎么获得该文件url。  A: 上传后会有url返回   Q: bmob可以通过客户端下载文件吗？  A: 上传到Bmob之后就会返回文件的地址，至于怎么下载，由你来决定。   Q: 为什么我上传的文件(图片)已经删除了，但是通过url仍然可以访问到图片呢？  A: CDN缓存的，过一段时间就会完全删除", 
            "title": "文件"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_9", 
            "text": "Q: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.  A: Cause: com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilityServiceInfoVersionImpl;\nError:Execution failed for task ':app:transformClassesWithDexForDebug'.  这是重复导包造成的，你用的v4和v7包重复了，你需要去掉报错的那个模块   Q: 我使用BmobUser.login接口,返回onFailure的参数code分别对应什么情况?有说明文档么?  A:  android 错误码列表   Q: App_ID is not setted出现什么原因？  A: 初始化BmobSDK时需要传入你自己应用的ApplicationID   Q: Duplicate files copied in APK META-INF/maven/com.squareup.okhttp/okhttp/pom.xml  A: 导了重复的包   Q: bomb_AndroidSDK_V3.4.7_0518 中文乱码  A: SDK的demo的编码格式是gbk,换下格式就行   Q: android Bmobquery 开两个线程 分别查两个不一样的表，返回数据有问题  A: sdk中的很多方法本身就是在子线程中执行的，开发者没必要开子线程(创建子线程和线程池管理SDK都封装好了)。   Q: 查询出了回调函数，List就变空了  A: 请先理解下同步和异步的概念，bmob目前的接口提供的都是异步回调函数，建议在onsucess/onFailure中进行ui操作   Q: Bmob的各个SDK可以使用Application的Context来初始化吗  A: 可以的。最好是用Application的Context来初始化。   Q: bmob的jar包和volley包冲突怎么回事  A: bmob的jar里面包含了volley,无需再次导入   Q: 移动端和WEB端能用BMOB作为云端，实现数据共享么？  A: 可以的，使用同一个app id来进行操作即可   Q: 真机运行时控制台输出 Error:warning: Ignoring InnerClasses attribute for an anonymous inner class  A: 可以试试在你的app的build.gradle的android标签下添加如下：  lintOptions {\nignoreWarnings true\n}   Q: 把应用装到手机很慢，一直在Gradle Build  A: 如果你确定你的应用所需的jar包已经下载完了，可以将gradle设置成离线模式   Q: BmobSDK能导入源码开发编译吗  A: BmobSDK目前并未开源   Q: 3.4.7 sdk java.lang.UnsatisfiedLinkError 怎么破\njava.lang.UnsatisfiedLinkError: Couldn't load bmob from loader dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/top.kiuber.sharemy-1.apk\"],nativeLibraryDirectories=[/data/app-lib/top.kiuber.sharemy-1, /vendor/lib, /system/lib]]]: findLibrary returned null  A: 详情移步到博客http://www.kiuber.top/2016/05/24/android-studio-add-so/\n问题已经被攻克，原因是so库文件未导入。\n解决方法：在project视图下，在main文件夹内新建jniLibs文件夹，把对应so库文件夹及文件复制到jniLibs文件内，然后在MainActivity.java文件   Q: 邮箱验证用哪个SDK  A: 使用数据服务SDK即可   Q: Android studio连接Bmob时报错  java.lang.UnsatisfiedLinkError: com.android.tools.fd.runtime.IncrementalClassLoader$DelegateClassLoader[DexPathList[[dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-support-annotations-23.4.0_eff36cb3dd5776bcc7dfe63d3c4af3d7d0b02909-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_9-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_8-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_7-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_6-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_5-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_4-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_3-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_2-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_1-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-slice_0-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okio-1.7.0_16f89fb230458d29c309937f6ab11ce75258c504-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-okhttp-3.2.0_8f755226a0726d7921fa90d83c674c16a1bd0ee3-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-internal_impl-23.4.0_2c4831db21059d6465959fb999a28d5a6fe10599-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-vector-drawable-23.4.0_eb28b4ae1a0615e1130648d3b547db30e6e89fd0-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-support-v4-23.4.0_c594c96eba293bbb78cda22a0502566240fb4409-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-appcompat-v7-23.4.0_39e8b9d21669eb9eb3df764bcd49eb0facc75e07-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-com.android.support-animated-vector-drawable-23.4.0_613291d2784b41eebf3800d518847e90b2efa55b-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-sdk-3.4.7_3bb8e20fe85419a97fea506c0c8a8a8fe18f45d5-classes.dex , dex file  /data/data/com.example.administrator.bmob2/files/instant-run/dex/slice-bmob-push-0.9_35e71e7e49d7888481221634e134fec14816f381-classes.dex ],nativeLibraryDirectories=[/data/app/com.example.administrator.bmob2-2/lib/arm, /vendor/lib, /system/lib]]] couldn't find  libbmob.so  A: 使用aar格式的SDK，这样就不用导入so库   Q: sdk怎么和Retrofit这些库一起使用呢  A: 出现这个问题的原因是retrofit依赖的okhttp和sdk的远程aar包中的okhttp重复导致的，将会导致编译不过，解决方式有： \n1 下载Retrofit的jar包，采用本地依赖的方式； \n2 compile Retrofit的配置加下exclude，把重复的okhttp除去，如下：  compile ('com.squareup.retrofit2:retrofit:2.1.0'){\n        exclude group : 'com.squareup.okhttp3'\n    }", 
            "title": "其它问题"
        }, 
        {
            "location": "/module/update_log/README/index.html", 
            "text": "v3.5.5 (2017年04月20日)\n\n\n\n\nsdk新增重新设置主域名，类似之前的数据迁移。\n注:此次更新开发者不用修改之前的常用代码。\n\n\n\n\nv3.5.4 (2017年04月12日)\n\n\n\n\n修复若干bug；\n\n\nSDK内部改进。\n注:此次更新开发者不用修改之前的常用代码。\n\n\n\n\nv3.5.3 (2016年11月09日)\n\n\n\n\n增加了对新的短信服务的支持；\n\n\n修复了旧版本使用推送调用BmobInstallation的save()方法导致的内存吃紧问题。\n注:此次更新开发者不用修改之前的常用代码。\n\n\n\n\nv3.5.2 (2016年10月27日)\n\n\n\n\n集成了统计SDK功能,开发者不用额外集成；\n\n\n修复了一键注册登录的用户扩展字段信息没有保存到本地的bug；\n\n\n对文件上传到又拍云回调成功但返回的path为\"null\"的低概率情况加了判断并提示重传；\n\n\n修改了BmobQuery等部分细节代码；\n注:此次更新开发者不用修改之前的常用代码 \n\n\n\n\nv3.5.1 (2016年07月20日)\n\n\n\n\n新增对数据迁移的支持。\n\n\n\n\nv3.5.0 (2016年06月27日)\n\n\n\n\n使用\nRx+okhttp3\n全面重构BmobSDK，所有方法均额外提供Observable形式调用；\n\n\nContext参数变化：除初始化方法外，其余方法均不再需要传递Context参数\n\n\n\n\n回调函数变化：\n    1)、所有回调函数的onSuccess、onFailure方法统一调整为done(T t,BmobException e)形式；\n    2）、合并以下回调函数：\n        GetListener\n-\nQueryListener\n\n        GetCallbackGetCallback-\nQueryListener\n\n        FindCallback-\nQueryListener\n\n        DeleteListener、EmailVerifyListener、ResetPasswordByCodeListener、ResetPasswordByEmailListener、VerifySMSCodeListener-\nUpdateListener\n        GetServerTimeListener-\nQueryListener\n\n        OtherLoginListener--\nLogInListener\n\n        StatisticQueryListener、FindStatisticsListener-\nQueryListener\n\n        GetTableSchemaListener-\nQueryListener\n\n        GetAllTableSchemaListener-\nQueryListListener\n\n        QuerySMSStateListener-\nQueryListener\n\n        RequestSMSCodeListener-\nQueryListener\n\n\n\n\n\n\n新增\nBmobBatch\n批量操作类，\n支持批量添加、批量更新、批量删除的同步提交\n，且批量添加的请求返回objectId字段；\n\n\n\n\n修复由于手机时间与服务器时间相差较大引起的调用文件的upload方法返回\n401 signature error\n错误；\n\n\n解决\nAndroidStudio\n运行BmobSDK后出现\nIgnoring InnerClasses attribute for an anonymous inner class\n的警告；\n\n\n同步更新\nBmobPush_v1.0.0\n推送SDK。\n\n\n\n\nv3.4.7 (2016年5月27日)\n\n\n\n\n文件服务的依赖库升级到okhttp3;\n\n\n修复调用文件的download方法有时成功有时却提示\nfile download error(9015)\n的错误;\n\n\n修复连接网络不稳定的wifi进行文件上传操作时出现\nRuntimeException: json 解析出错\n的问题;\n\n\n数据加解密改用底层so库实现，进一步保证数据安全;\n\n\n将权限管理类PermissionManager分离出SDK以减少依赖关系;\n\n\n修复部分机型出现的z.so无法加载的问题;\n\n\n同步更新BmobPush_v0.9的SDK。\n\n\n\n\nv3.4.6 (2016年4月20日)\n\n\n附加：\n\n\n\n\n关于旧版本自动更新组件出现解析包出错问题的解决方法\n；\n\n\n修复v3.4.6_0413版本中自动更新组件出现的AndroidRuntimeException问题；\n\n\n增加文件服务的AppKey和Wake_Lock权限检测。\n\n\n\n\n新增：\n\n\n\n\n新增CDN文件服务，废弃原来的新旧文件服务，但上传方法名不变；\n\n\n新增文件下载download方法，允许设定文件的下载目录；\n\n\n新增文件批量删除接口（只针对于通过CDN文件服务上传的文件）；\n\n\n新增BmobConfig类，允许开发者设置查询超时时间及文件上传时的每片大小；\n\n\n全面兼容Android6.0系统，并增加权限管理工具类(PermissionManager)，方便开发者对权限进行控制和管理。\n转移：\n文件的批量上传的静态uploadBatch方法由Bmob类转移至BmobFile类。\n修复：\n\n\n修复调用add、addUnique、remove、removeAll、increment、setValue等方法成功后本地用户信息未及时更新的问题；\n\n\n修复自动更新组件中target_size填成英文导致应用奔溃的问题；\n\n\n修复部分机型出现的缓存查询失效的问题；\n\n\n修复同时发送多个查询请求时会出现多次初始化的问题；\n\n\n修复由手机系统时间的修改而导致的sdk time error的问题（需要在应用启动页面的onCreate方法中调用Bmob.getInstance().synchronizeTime(context)方法）。\n\n\n\n\nv3.4.5 (2015年11月11日)\n\n\n\n\n修复特殊网络情况下出现400错误的问题；\n\n\n新增getObjectByKey方法获取当前登陆用户的某一列的值；\n\n\nsetValue方法支持java基本数据类型；\n\n\n强制更新模式下隐藏右上角关闭按钮。\n\n\n\n\nv3.4.4 (2015年9月30日)\n\n\n\n\n新增数组更新方式，并同步支持所有类型的字段更新；\n\n\n自动更新组件回调方法中添加更新错误提示\n\n\n\n\nv3.4.3 (2015年8月20日)\n\n\n\n\n新增修改当前用户密码的方法；\n\n\n修复V3.4.3_0820版本中一键注册或登录方法出错的问题；\n\n\n推送的频道订阅增加去重操作；\n\n\n使用okhttp优化网络框架，提升网络效率。\n\n\n\n\nv3.4.2 (2015年7月27日)\n\n\n\n\n新增获取表结构信息的方法 \n\n\n\n\nv3.4.1 (2015年7月10日)\n\n\n\n\n短信服务允许自定义短信内容； \n\n\n新版文件服务新增获取文件地址的方法；\n\n\n新版文件服务新增文件删除功能；\n\n\n新旧文件服务同步兼容BmobFile对象；\n\n\n优化新版文件上传与下载的进度提示。\n\n\n\n\nv3.4.0 (2015年6月16日)\n\n\n\n\n短信验证统一采用BmobSMS类； \n\n\n修复其他bug。\n\n\n\n\nv3.3.9 (2015年6月12日)\n\n\n\n\n新增短信验证API； \n\n\n用户登录新增多种登录方式：邮箱+密码、手机号码+密码、手机号码+短信验证码； \n\n\n修改第三方账号登录方式，并新增对微信登录的支持；\n\n\n修复自动更新组件多次点击忽略版本的更新按钮报错的bug。\n\n\n\n\nv3.3.8 (2015年5月21日)\n\n\n\n\naddWhereEqualTo方法支持一对多关联关系查询；\n\n\n缓存查询方法允许单独使用； \n\n\n修复BQL查询设置缓存策略后查询出错的问题。\n\n\n\n\nv3.3.7 (2015年5月13日)\n\n\n\n\n新增SQL语句查询，让查询更简单；\n\n\n解决新版文件管理处理本地缩略图时出现OOM的问题； \n\n\n解决新版文件管理提交缩略图任务时modelId无效的问题。\n\n\n\n\nv3.3.6 (2015年4月27日)\n\n\n\n\n新增统计查询方法，可查询总和、平均值、最大值、最小值并支持分组和添加过滤条件。 \n\n\n\n\nv3.3.5 (2015年4月08日)\n\n\n\n\n自动更新组件中修复自动更新方式下无法强制用户更新应用的问题；\n\n\n自动更新组件中支持监听对话框按键操作；\n\n\nBmobPush同步更新到V0.6版本。\n\n\n\n\nv3.3.4 (2015年3月10日)\n\n\n\n\n修复自动更新组件的自动更新方式下“忽略该版”按钮选中再取消后无法再次出现版本更新提示的问题；\n\n\n自动更新组件中允许下载已上传到应用市场的apk文件（须填写应用市场下载地址android_url）;\n\n\n自动更新组件中支持对更新内容根据分隔符“；”进行文字排版;\n\n\n修复某些特定情况下调用BmobUser的update方法后无法获取最近更新的用户信息;\n\n\n修复新版文件管理中开启URL签名认证后无法获取签名地址的问题。\n\n\n\n\nv3.3.3 (2015年2月11日)\n\n\n\n\n修复第三方登陆成功后无法获取本地用户信息的问题；\n\n\n修复设置缓存策略后无法获取本地缓存信息的问题；\n\n\n修复调用云端代码（callEndpoint）方法的成功回调的返回值中含有“results”的问题；\n\n\n新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。\n\n\n\n\nv3.3.2 (2015年1月27日)\n\n\n\n\n整体优化新版文件管理的代码结构和处理流程；\n\n\n修复自动更新的初始化方法无法自动创建AppVersion表的问题。\n\n\n\n\nv3.3.1 (2015年1月21日)\n\n\n\n\n修复新版SDK由于初始化方法未成功返回而导致的sdk time error、internal error等错误；\n\n\n修复调用BmobUser的update方法成功之后再调用getCurrentUser方法无法获取已更新信息的问题。\n\n\n\n\nv3.3.0 (2015年1月19日)\n\n\n\n\n新增数据加密功能，保障数据安全，强烈建议更新SDK；\n\n\n新增文件删除功能；\n\n\nBmobProFile类增加URL签名方法；\n\n\n修复BmobProFile类获取本地缩略图的方法出错的问题；\n\n\n\n\nv3.2.9 (2015年1月12日)\n\n\n\n\n新增新版文件管理BmobProFile类，提供了单一上传、批量上传、下载文件、生成缩略图等功能。\n\n\n\n\nv3.2.8 (2015年1月05日)\n\n\n\n\n修改单一文件upload方法报NullPointerException错误的问题；\n\n\n修改调用loadImageThumbnail来加载缩略图报can not draw recycle bitmap错误的问题。\n\n\n\n\nv3.2.7 (2014年12月09日)\n\n\n\n\n新增安全认证功能，增加SDK安全性；\n\n\n新增批量上传文件的功能；\n\n\n为单一文件上传补充进度提醒（onProgress）方法；\n\n\n解决第三方登陆成功之后无法修改用户信息的问题；\n\n\n支持复合与查询方式。\n\n\n\n\nv3.2.6 (2014年11月03日)\n\n\n\n\n修改Bmob的应用Application ID的本地存储方式。\n\n\n\n\nv3.2.5 (2014年10月27日)\n\n\n\n\n修复SDK调用云端代码出现ArrayIndexOutOfBoundsException(对应的错误码为9015)的问题；\n\n\n修复自动更新组件在切换网络之后出现的解析包错误的问题，增加target_size必填项；\n\n\n更新BmobpushSDK到V0.5，优化推送服务频繁重启的问题，建议使用此版本推送服务。\n\n\n\n\nv3.2.4 (2014年10月13日)\n\n\n\n\n修改调用addWhereWithinGeoBox（查询指定位置的某矩形范围内）和addWhereWithinRadians（查询指定半径范围内）方法查询数据时出错的bug；\n\n\n修改调用BmobObject和BmobUser的update和delete方法出错的bug；\n\n\n第三方账号登录增加OnCancel回调方法；\n\n\n修改批量插入带pointer类型的数据时出现上传后的pointer类型的字段变成BmobObject类型的bug；\n\n\n更新BmobpushSDK到V0.4，优化导致推送延迟或无法接收到推送的问题。\n\n\n\n\nv3.2.3 (2014年9月18日)\n\n\n\n\n第三方账号登陆增加QQ、新浪微博关联与取消关联的方法；\n\n\n自动更新组件新增初始化创建AppVersion表，不再需要手动创建；\n\n\n自动更新组件新增强制更新和忽略版本更新功能；\n\n\n修复调用BmobUser的update(context)方法和BmobObject的save(context)方法报错的bug；\n\n\n修复其他bug。 \n\n\n\n\nv3.2.2 (2014年9月15日)\n\n\n\n\n修改V3.2.1版本文件上传出错的问题； \n\n\n更新Bmobpush到V0.3，增加推送服务稳定性；\n\n\n修复其他bug。 \n\n\n\n\nv3.2.1 (2014年9月02日)\n\n\n\n\n增加删除字段功能\n\n\n增加对数组字段的增删改查功能\n\n\n去除insertObject、updateObject等过期方法\n\n\n修改云端代码返回Json数据时带反斜杠的问题\n\n\n修复其他Bug \n\n\n\n\nv3.2.0 (2014年8月08日)\n\n\n\n\n增加数据实时功能\n\n\n\n\nv3.1.9 (2014年8月05日)\n\n\n\n\n修复文件分片上传失败无限重试的bug\n\n\n增加新浪微博、手机QQ的第三方账号登陆\n\n\n\n\nv3.1.8 (2014年7月23日)\n\n\n\n\n修复文件上传失败的bug\n\n\n更新BmobPushSDK到0.2beta\n\n\n\n\nv3.1.7_Beta (2014年7月17日)\n\n\n\n\n增加BmobQuery对象getObject时include、addQueryKeys等操作的支持\n\n\n\n\nv3.1.6_Beta (2014年7月14日)\n\n\n\n\n修复Pointer类型创建错误的bug\n\n\n修复自动更新点击通知栏崩溃的bug\n\n\n增加推送JSONObject数据的支持\n\n\n修复注册用户成功后在onSuccess回调中获取本地用户为null的bug\n\n\n\n\nv3.1.5_Beta (2014年6月28日)\n\n\n\n\n修复初始化设备表失败的bug\n\n\n恢复NETWORK_ELSE_CACHE查询缓存策略\n\n\n\n\nv3.1.4_Beta (2014年6月19日)\n\n\n\n\n修复findObjects查询无缓存数据时的错误回调\n\n\n修复BmobUser类中Number类型字段增量更新无效的bug\n\n\n修复创建数据对象中包含指针类型为BmobUser时创建失败的bug\n\n\n修复查询对象多继承时，表名获取错误的bug\n\n\n修复第一次保存Installation信息失败的bug\n\n\n增加应用自动更新功能\n\n\n\n\nv3.1.3_Beta (2014年6月10日)\n\n\n\n\n修复同一字段的and查询操作\n\n\n增加用户注册成功后的缓存操作\n\n\n修复同一对象中多个Pointer类型的include查询失效的bug\n\n\nBmobObject对象添加setTableName方法，可自定义表名\n\n\n增加对老版本创建、查询数据方式的支持\n\n\n\n\nv3.1.2_Beta (2014年6月04日)\n\n\n\n\n修复Context为null时的bug\n\n\n修复在onSuccess方法中出现异常时调用onFailure的bug\n\n\nBmobObject实现Serializable支持序列化\n\n\n\n\nv3.1.1_Beta (2014年6月03日)\n\n\n\n\nSaveListener替代InsertListener\n\n\n修复无网络情况下崩溃的bug\n\n\n\n\nv3.1.0_Beta (2014年5月27日)\n\n\n\n\n修复同一个对象不能自增多列的bug\n\n\n增加错误代码机制\n\n\nBmobFile增加获取缩略图功能\n\n\nBmobFile增加分片上传功能\n\n\nBmobObject增加ACL权限控制\n\n\n增加BmobRole角色管理类\n\n\n修复扩展BmobInstallation属性后查询不到的bug\n\n\n\n\nv3.0.9_Beta (2014年5月21日)\n\n\n\n\n添加无初始化时的提示信息\n\n\n修复BmobUser类不支持Pointer类型的bug\n\n\n修复云端代码不支持返回数据类型为String的bug\n\n\n\n\nv3.0.8_Beta (2014年5月14日)\n\n\n\n\n修复重复查询N次后出现内存溢出的bug\n\n\n修复count查询不支持条件的bug\n\n\nBmobFile增加文件上传进度的支持\n\n\n\n\nv3.0.7_Beta (2014年5月05日)\n\n\n\n\n修复云端代码请求失败的bug\n\n\n\n\nv3.0.6_Beta (2014年4月30日)\n\n\n\n\n增加BmobPushManager类, 实现客户端推送消息功能\n\n\n增加BmobInstallation类, 可实现自定义推送\n\n\n同步推出Bmob消息推送SDK 0.1.0Beta版本\n\n\n\n\nv3.0.5_Beta (2014年4月29日)\n\n\n\n\n修复登陆成功时出现空指针异常的bug\n\n\n\n\nv3.0.4_Beta  (2014年4月22日)\n\n\n\n\nBmobUser增加邮件验证功能\n\n\nBmobObject增加批量操作功能，可批量添加、更新、删除\n\n\n\n\nv3.0.3_Beta (2014年4月17日)\n\n\n\n\n增加网络数据包压缩功能，更好的节省客户端流量。\n\n\n增加缓存数据的加密、压缩功能，更好的节省了缓存空间和提高数据的安全性。\n\n\nBmobObject对象增加计数器，可以对任何数字字段进行原子增加（或减少）的功能。\n\n\nBmobObject对象增加关联数据类型的支持，可实现不同对象间的一对一、一对多的数据关联。\n\n\nBmobQuery对象增加对关联数据类型查询的支持，可实现关系查询。\n\n\n修复更新对象时存在系统字段的情况导致更新失败的bug。\n\n\nBmobQuery对象增加复合查询支持，可实现or条件查询。\n\n\n\n\nv3.0.2_Beta (2014年4月10日)\n\n\n\n\n修复addWhereContainedIn和addWhereNotContainedIn添加条件无效的bug\n\n\nBmobQuery对象新增addWhereMatches、addWhereContains、addWhereStartsWith、addWhereEndsWith条件添加方法\n\n\nBmobQuery对象新增地理位置查询等方法\n\n\n修改BmobFile实例化方法\n\n\nBmobUser对象新增getCurrentUser、logOut方法\n\n\n修改BmobUser.resetPassword为静态方法\n\n\nBmobQuery对象增加查询用户表的特殊处理\n\n\nBmobQuery对象新增查询时的缓存策略。\n\n\n\n\nv3.0.1_Beta (2014年4月08日)\n\n\n\n\n优化BmobQuery查询方法getObject、findObjects\n\n\n\n\nv3.0_Beta (2014年4月04日)\n\n\n\n\n新版本3.0beta和之前的版本使用方式有所不同，新的版本使用更加方便和稳定。\n\n\n新版已解决之前在主线程执行操作时抛出的android.os.NetworkOnMainThreadException异常\n\n\n新版的数据请求模块基于Volley网络通信框架，能使网络通信更快，更简单，更健壮。\n\n\n新版的对象解析模块基于Gson,提高接口数据和javaBean之间的转换速度。\n\n\n新增查询指定数据列的功能。\n\n\n具体使用方法请参考示例程序。\n\n\n\n\nv2.2.8_Beta (2014年3月24日)\n\n\n\n\n修复保存文件失败的bug\n\n\n增加获取服务器时间的方法Bmob.getServerTime \n\n\n增加华为云推送功能 \n\n\n\n\nv2.2.7_Beta (2014年1月07日)\n\n\n\n\n修复调用云端代码时BmobClientCallback不能引用的bug \n\n\n修复CountCallback不能引用的bug \n\n\n\n\nv2.2.6_Beta (2013年12月27日)\n\n\n\n\n修正无网络情况下，获取BmobFileUrl为null的bug\n\n\n改善Context为null时出现的bug 3.新增云端代码功能 \n\n\n\n\nv2.2.5_Beta (2013年11月15日)\n\n\n\n\n修正updateAt为null的bug\n\n\n\n\nv2.2.4_Beta (2013年11月13日)\n\n\n\n\n修正Date类型数据格式\n\n\n新增getDate方法获取Date类型数据\n\n\n新增ACL功能，提高数据安全性\n\n\n新增加密码重置功能\n\n\n\n\nv2.2.3_Beta (2013年9月27日)\n\n\n\n\n新增Count查询功能\n\n\n新增地理位置查询功能 \n\n\n修正BmobGeoPoint数据类型的存储格式\n\n\n修正上传文件失败的bug\n\n\n\n\nv2.2.2_Beta (2013年9月18日)\n\n\n\n\n完善缓存策略功能，提供自定义缓存时间，默认缓存时间为5小时\n\n\n更新接口服务，提升响应速度\n\n\n\n\nv2.2.1_Beta  (2013年9月04日)\n\n\n\n\n修正一些崩溃的bug \n\n\n修正更新数据成功后返回的数据结构体 \n\n\n修正查询数据成功后返回的file、GeoPoint、Data等数据类型结构错误的bug \n\n\n修正无效objectId删除成功的bug \n\n\n修正分页查询数据不正确的bug \n\n\n修正未添加网络权限及无网络状态时引起崩溃的bug \n\n\n修正用户使用正确用户名、密码登陆失败的bug \n\n\n修改创建数据成功后返回的数据内容 \n\n\n新增查询数据默认的limit为100，最大limit值不可超过1000 \n\n\n新增查询数据时提供6种缓存策略的功能 \n\n\n增加服务器以扩大集群来支撑更大用户量，明显提高响应速度 \n\n\n\n\nv2.2.0_Beta (2013年4月23日)\n\n\n\n\n修复重复添加数据的bug.\n\n\n更新完善开发者指南，如文件查询方式等.\n\n\n对内部流程的优化精简，减少冗余步骤，提供执行效率.\n\n\n增加一些操作的callback回调方法.\n\n\n优化数据传输格式.\n\n\n提升每一项操作的安全性.\n\n\n\n\nv2.1.0_Beta (2013年2月05日)\n\n\n\n\n修复旧版本发现和反馈的bug.\n\n\n优化SDK的性能，压缩了网络请求的流量损耗.\n\n\n提升了SDK在网络传输过程中的数据安全.\n\n\n进一步提升了后端云的并发承载和存储能力，确保服务高效运行.\n\n\n暂停推送服务，寻求erlang解决方案.\n\n\n\n\nv1.0.4_Beta (2012年4月28日)\n\n\n\n\n修复文件类型、地理坐标类型、JsonArray类型、JsonObject类型更新时出现的错误。\n\n\n\n\nv1.0.3_Beta (2012年4月27日)\n\n\n\n\n修复用户注册功能中存在的Bug。\n\n\n修复更新数据失败的重要Bug。\n\n\n修复更新数据后updateAt(更新时间)字段的值未修改的Bug。\n\n\n修复Bmob初始化等方法中的参数名称顺序颠倒的问题。\n\n\n增加用户登录功能。\n\n\n增加本地用户登录、注销功能。\n\n\n\n\nv1.0.2_Beta (2012年4月24日)\n\n\n\n\n修复创建用户对象时，提示数据表名称不正确的Bug。\n\n\n提供BmobObject数据对象的创建时间、更新时间两个字段值的获取。（BmobObject.getCreatedAt(),BmobObject.getUpdatedAt()）\n\n\n完善文件类型、地理坐标类型、JsonArray类型、JsonObject这几种数据类型的封装，便于更好的从查询结果中获取数据。\n\n\n\n\nv1.0.0_Beta (2012年4月08日)\n\n\n\n\n产品上线", 
            "title": "更新日志"
        }, 
        {
            "location": "/module/update_log/README/index.html#v355-20170420", 
            "text": "sdk新增重新设置主域名，类似之前的数据迁移。\n注:此次更新开发者不用修改之前的常用代码。", 
            "title": "v3.5.5 (2017年04月20日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v354-20170412", 
            "text": "修复若干bug；  SDK内部改进。\n注:此次更新开发者不用修改之前的常用代码。", 
            "title": "v3.5.4 (2017年04月12日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v353-20161109", 
            "text": "增加了对新的短信服务的支持；  修复了旧版本使用推送调用BmobInstallation的save()方法导致的内存吃紧问题。\n注:此次更新开发者不用修改之前的常用代码。", 
            "title": "v3.5.3 (2016年11月09日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v352-20161027", 
            "text": "集成了统计SDK功能,开发者不用额外集成；  修复了一键注册登录的用户扩展字段信息没有保存到本地的bug；  对文件上传到又拍云回调成功但返回的path为\"null\"的低概率情况加了判断并提示重传；  修改了BmobQuery等部分细节代码；\n注:此次更新开发者不用修改之前的常用代码", 
            "title": "v3.5.2 (2016年10月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v351-20160720", 
            "text": "新增对数据迁移的支持。", 
            "title": "v3.5.1 (2016年07月20日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v350-20160627", 
            "text": "使用 Rx+okhttp3 全面重构BmobSDK，所有方法均额外提供Observable形式调用；  Context参数变化：除初始化方法外，其余方法均不再需要传递Context参数   回调函数变化：\n    1)、所有回调函数的onSuccess、onFailure方法统一调整为done(T t,BmobException e)形式；\n    2）、合并以下回调函数：\n        GetListener - QueryListener \n        GetCallbackGetCallback- QueryListener \n        FindCallback- QueryListener \n        DeleteListener、EmailVerifyListener、ResetPasswordByCodeListener、ResetPasswordByEmailListener、VerifySMSCodeListener- UpdateListener\n        GetServerTimeListener- QueryListener \n        OtherLoginListener-- LogInListener \n        StatisticQueryListener、FindStatisticsListener- QueryListener \n        GetTableSchemaListener- QueryListener \n        GetAllTableSchemaListener- QueryListListener \n        QuerySMSStateListener- QueryListener \n        RequestSMSCodeListener- QueryListener    新增 BmobBatch 批量操作类， 支持批量添加、批量更新、批量删除的同步提交 ，且批量添加的请求返回objectId字段；   修复由于手机时间与服务器时间相差较大引起的调用文件的upload方法返回 401 signature error 错误；  解决 AndroidStudio 运行BmobSDK后出现 Ignoring InnerClasses attribute for an anonymous inner class 的警告；  同步更新 BmobPush_v1.0.0 推送SDK。", 
            "title": "v3.5.0 (2016年06月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v347-2016527", 
            "text": "文件服务的依赖库升级到okhttp3;  修复调用文件的download方法有时成功有时却提示 file download error(9015) 的错误;  修复连接网络不稳定的wifi进行文件上传操作时出现 RuntimeException: json 解析出错 的问题;  数据加解密改用底层so库实现，进一步保证数据安全;  将权限管理类PermissionManager分离出SDK以减少依赖关系;  修复部分机型出现的z.so无法加载的问题;  同步更新BmobPush_v0.9的SDK。", 
            "title": "v3.4.7 (2016年5月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v346-2016420", 
            "text": "附加：   关于旧版本自动更新组件出现解析包出错问题的解决方法 ；  修复v3.4.6_0413版本中自动更新组件出现的AndroidRuntimeException问题；  增加文件服务的AppKey和Wake_Lock权限检测。   新增：   新增CDN文件服务，废弃原来的新旧文件服务，但上传方法名不变；  新增文件下载download方法，允许设定文件的下载目录；  新增文件批量删除接口（只针对于通过CDN文件服务上传的文件）；  新增BmobConfig类，允许开发者设置查询超时时间及文件上传时的每片大小；  全面兼容Android6.0系统，并增加权限管理工具类(PermissionManager)，方便开发者对权限进行控制和管理。\n转移：\n文件的批量上传的静态uploadBatch方法由Bmob类转移至BmobFile类。\n修复：  修复调用add、addUnique、remove、removeAll、increment、setValue等方法成功后本地用户信息未及时更新的问题；  修复自动更新组件中target_size填成英文导致应用奔溃的问题；  修复部分机型出现的缓存查询失效的问题；  修复同时发送多个查询请求时会出现多次初始化的问题；  修复由手机系统时间的修改而导致的sdk time error的问题（需要在应用启动页面的onCreate方法中调用Bmob.getInstance().synchronizeTime(context)方法）。", 
            "title": "v3.4.6 (2016年4月20日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v345-20151111", 
            "text": "修复特殊网络情况下出现400错误的问题；  新增getObjectByKey方法获取当前登陆用户的某一列的值；  setValue方法支持java基本数据类型；  强制更新模式下隐藏右上角关闭按钮。", 
            "title": "v3.4.5 (2015年11月11日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v344-2015930", 
            "text": "新增数组更新方式，并同步支持所有类型的字段更新；  自动更新组件回调方法中添加更新错误提示", 
            "title": "v3.4.4 (2015年9月30日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v343-2015820", 
            "text": "新增修改当前用户密码的方法；  修复V3.4.3_0820版本中一键注册或登录方法出错的问题；  推送的频道订阅增加去重操作；  使用okhttp优化网络框架，提升网络效率。", 
            "title": "v3.4.3 (2015年8月20日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v342-2015727", 
            "text": "新增获取表结构信息的方法", 
            "title": "v3.4.2 (2015年7月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v341-2015710", 
            "text": "短信服务允许自定义短信内容；   新版文件服务新增获取文件地址的方法；  新版文件服务新增文件删除功能；  新旧文件服务同步兼容BmobFile对象；  优化新版文件上传与下载的进度提示。", 
            "title": "v3.4.1 (2015年7月10日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v340-2015616", 
            "text": "短信验证统一采用BmobSMS类；   修复其他bug。", 
            "title": "v3.4.0 (2015年6月16日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v339-2015612", 
            "text": "新增短信验证API；   用户登录新增多种登录方式：邮箱+密码、手机号码+密码、手机号码+短信验证码；   修改第三方账号登录方式，并新增对微信登录的支持；  修复自动更新组件多次点击忽略版本的更新按钮报错的bug。", 
            "title": "v3.3.9 (2015年6月12日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v338-2015521", 
            "text": "addWhereEqualTo方法支持一对多关联关系查询；  缓存查询方法允许单独使用；   修复BQL查询设置缓存策略后查询出错的问题。", 
            "title": "v3.3.8 (2015年5月21日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v337-2015513", 
            "text": "新增SQL语句查询，让查询更简单；  解决新版文件管理处理本地缩略图时出现OOM的问题；   解决新版文件管理提交缩略图任务时modelId无效的问题。", 
            "title": "v3.3.7 (2015年5月13日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v336-2015427", 
            "text": "新增统计查询方法，可查询总和、平均值、最大值、最小值并支持分组和添加过滤条件。", 
            "title": "v3.3.6 (2015年4月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v335-2015408", 
            "text": "自动更新组件中修复自动更新方式下无法强制用户更新应用的问题；  自动更新组件中支持监听对话框按键操作；  BmobPush同步更新到V0.6版本。", 
            "title": "v3.3.5 (2015年4月08日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v334-2015310", 
            "text": "修复自动更新组件的自动更新方式下“忽略该版”按钮选中再取消后无法再次出现版本更新提示的问题；  自动更新组件中允许下载已上传到应用市场的apk文件（须填写应用市场下载地址android_url）;  自动更新组件中支持对更新内容根据分隔符“；”进行文字排版;  修复某些特定情况下调用BmobUser的update方法后无法获取最近更新的用户信息;  修复新版文件管理中开启URL签名认证后无法获取签名地址的问题。", 
            "title": "v3.3.4 (2015年3月10日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v333-2015211", 
            "text": "修复第三方登陆成功后无法获取本地用户信息的问题；  修复设置缓存策略后无法获取本地缓存信息的问题；  修复调用云端代码（callEndpoint）方法的成功回调的返回值中含有“results”的问题；  新版文件管理中对本地缩略图的处理方法新增压缩质量的参数。", 
            "title": "v3.3.3 (2015年2月11日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v332-2015127", 
            "text": "整体优化新版文件管理的代码结构和处理流程；  修复自动更新的初始化方法无法自动创建AppVersion表的问题。", 
            "title": "v3.3.2 (2015年1月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v331-2015121", 
            "text": "修复新版SDK由于初始化方法未成功返回而导致的sdk time error、internal error等错误；  修复调用BmobUser的update方法成功之后再调用getCurrentUser方法无法获取已更新信息的问题。", 
            "title": "v3.3.1 (2015年1月21日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v330-2015119", 
            "text": "新增数据加密功能，保障数据安全，强烈建议更新SDK；  新增文件删除功能；  BmobProFile类增加URL签名方法；  修复BmobProFile类获取本地缩略图的方法出错的问题；", 
            "title": "v3.3.0 (2015年1月19日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v329-2015112", 
            "text": "新增新版文件管理BmobProFile类，提供了单一上传、批量上传、下载文件、生成缩略图等功能。", 
            "title": "v3.2.9 (2015年1月12日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v328-2015105", 
            "text": "修改单一文件upload方法报NullPointerException错误的问题；  修改调用loadImageThumbnail来加载缩略图报can not draw recycle bitmap错误的问题。", 
            "title": "v3.2.8 (2015年1月05日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v327-20141209", 
            "text": "新增安全认证功能，增加SDK安全性；  新增批量上传文件的功能；  为单一文件上传补充进度提醒（onProgress）方法；  解决第三方登陆成功之后无法修改用户信息的问题；  支持复合与查询方式。", 
            "title": "v3.2.7 (2014年12月09日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v326-20141103", 
            "text": "修改Bmob的应用Application ID的本地存储方式。", 
            "title": "v3.2.6 (2014年11月03日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v325-20141027", 
            "text": "修复SDK调用云端代码出现ArrayIndexOutOfBoundsException(对应的错误码为9015)的问题；  修复自动更新组件在切换网络之后出现的解析包错误的问题，增加target_size必填项；  更新BmobpushSDK到V0.5，优化推送服务频繁重启的问题，建议使用此版本推送服务。", 
            "title": "v3.2.5 (2014年10月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v324-20141013", 
            "text": "修改调用addWhereWithinGeoBox（查询指定位置的某矩形范围内）和addWhereWithinRadians（查询指定半径范围内）方法查询数据时出错的bug；  修改调用BmobObject和BmobUser的update和delete方法出错的bug；  第三方账号登录增加OnCancel回调方法；  修改批量插入带pointer类型的数据时出现上传后的pointer类型的字段变成BmobObject类型的bug；  更新BmobpushSDK到V0.4，优化导致推送延迟或无法接收到推送的问题。", 
            "title": "v3.2.4 (2014年10月13日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v323-2014918", 
            "text": "第三方账号登陆增加QQ、新浪微博关联与取消关联的方法；  自动更新组件新增初始化创建AppVersion表，不再需要手动创建；  自动更新组件新增强制更新和忽略版本更新功能；  修复调用BmobUser的update(context)方法和BmobObject的save(context)方法报错的bug；  修复其他bug。", 
            "title": "v3.2.3 (2014年9月18日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v322-2014915", 
            "text": "修改V3.2.1版本文件上传出错的问题；   更新Bmobpush到V0.3，增加推送服务稳定性；  修复其他bug。", 
            "title": "v3.2.2 (2014年9月15日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v321-2014902", 
            "text": "增加删除字段功能  增加对数组字段的增删改查功能  去除insertObject、updateObject等过期方法  修改云端代码返回Json数据时带反斜杠的问题  修复其他Bug", 
            "title": "v3.2.1 (2014年9月02日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v320-2014808", 
            "text": "增加数据实时功能", 
            "title": "v3.2.0 (2014年8月08日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v319-2014805", 
            "text": "修复文件分片上传失败无限重试的bug  增加新浪微博、手机QQ的第三方账号登陆", 
            "title": "v3.1.9 (2014年8月05日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v318-2014723", 
            "text": "修复文件上传失败的bug  更新BmobPushSDK到0.2beta", 
            "title": "v3.1.8 (2014年7月23日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v317_beta-2014717", 
            "text": "增加BmobQuery对象getObject时include、addQueryKeys等操作的支持", 
            "title": "v3.1.7_Beta (2014年7月17日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v316_beta-2014714", 
            "text": "修复Pointer类型创建错误的bug  修复自动更新点击通知栏崩溃的bug  增加推送JSONObject数据的支持  修复注册用户成功后在onSuccess回调中获取本地用户为null的bug", 
            "title": "v3.1.6_Beta (2014年7月14日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v315_beta-2014628", 
            "text": "修复初始化设备表失败的bug  恢复NETWORK_ELSE_CACHE查询缓存策略", 
            "title": "v3.1.5_Beta (2014年6月28日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v314_beta-2014619", 
            "text": "修复findObjects查询无缓存数据时的错误回调  修复BmobUser类中Number类型字段增量更新无效的bug  修复创建数据对象中包含指针类型为BmobUser时创建失败的bug  修复查询对象多继承时，表名获取错误的bug  修复第一次保存Installation信息失败的bug  增加应用自动更新功能", 
            "title": "v3.1.4_Beta (2014年6月19日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v313_beta-2014610", 
            "text": "修复同一字段的and查询操作  增加用户注册成功后的缓存操作  修复同一对象中多个Pointer类型的include查询失效的bug  BmobObject对象添加setTableName方法，可自定义表名  增加对老版本创建、查询数据方式的支持", 
            "title": "v3.1.3_Beta (2014年6月10日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v312_beta-2014604", 
            "text": "修复Context为null时的bug  修复在onSuccess方法中出现异常时调用onFailure的bug  BmobObject实现Serializable支持序列化", 
            "title": "v3.1.2_Beta (2014年6月04日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v311_beta-2014603", 
            "text": "SaveListener替代InsertListener  修复无网络情况下崩溃的bug", 
            "title": "v3.1.1_Beta (2014年6月03日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v310_beta-2014527", 
            "text": "修复同一个对象不能自增多列的bug  增加错误代码机制  BmobFile增加获取缩略图功能  BmobFile增加分片上传功能  BmobObject增加ACL权限控制  增加BmobRole角色管理类  修复扩展BmobInstallation属性后查询不到的bug", 
            "title": "v3.1.0_Beta (2014年5月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v309_beta-2014521", 
            "text": "添加无初始化时的提示信息  修复BmobUser类不支持Pointer类型的bug  修复云端代码不支持返回数据类型为String的bug", 
            "title": "v3.0.9_Beta (2014年5月21日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v308_beta-2014514", 
            "text": "修复重复查询N次后出现内存溢出的bug  修复count查询不支持条件的bug  BmobFile增加文件上传进度的支持", 
            "title": "v3.0.8_Beta (2014年5月14日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v307_beta-2014505", 
            "text": "修复云端代码请求失败的bug", 
            "title": "v3.0.7_Beta (2014年5月05日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v306_beta-2014430", 
            "text": "增加BmobPushManager类, 实现客户端推送消息功能  增加BmobInstallation类, 可实现自定义推送  同步推出Bmob消息推送SDK 0.1.0Beta版本", 
            "title": "v3.0.6_Beta (2014年4月30日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v305_beta-2014429", 
            "text": "修复登陆成功时出现空指针异常的bug", 
            "title": "v3.0.5_Beta (2014年4月29日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v304_beta-2014422", 
            "text": "BmobUser增加邮件验证功能  BmobObject增加批量操作功能，可批量添加、更新、删除", 
            "title": "v3.0.4_Beta  (2014年4月22日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v303_beta-2014417", 
            "text": "增加网络数据包压缩功能，更好的节省客户端流量。  增加缓存数据的加密、压缩功能，更好的节省了缓存空间和提高数据的安全性。  BmobObject对象增加计数器，可以对任何数字字段进行原子增加（或减少）的功能。  BmobObject对象增加关联数据类型的支持，可实现不同对象间的一对一、一对多的数据关联。  BmobQuery对象增加对关联数据类型查询的支持，可实现关系查询。  修复更新对象时存在系统字段的情况导致更新失败的bug。  BmobQuery对象增加复合查询支持，可实现or条件查询。", 
            "title": "v3.0.3_Beta (2014年4月17日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v302_beta-2014410", 
            "text": "修复addWhereContainedIn和addWhereNotContainedIn添加条件无效的bug  BmobQuery对象新增addWhereMatches、addWhereContains、addWhereStartsWith、addWhereEndsWith条件添加方法  BmobQuery对象新增地理位置查询等方法  修改BmobFile实例化方法  BmobUser对象新增getCurrentUser、logOut方法  修改BmobUser.resetPassword为静态方法  BmobQuery对象增加查询用户表的特殊处理  BmobQuery对象新增查询时的缓存策略。", 
            "title": "v3.0.2_Beta (2014年4月10日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v301_beta-2014408", 
            "text": "优化BmobQuery查询方法getObject、findObjects", 
            "title": "v3.0.1_Beta (2014年4月08日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v30_beta-2014404", 
            "text": "新版本3.0beta和之前的版本使用方式有所不同，新的版本使用更加方便和稳定。  新版已解决之前在主线程执行操作时抛出的android.os.NetworkOnMainThreadException异常  新版的数据请求模块基于Volley网络通信框架，能使网络通信更快，更简单，更健壮。  新版的对象解析模块基于Gson,提高接口数据和javaBean之间的转换速度。  新增查询指定数据列的功能。  具体使用方法请参考示例程序。", 
            "title": "v3.0_Beta (2014年4月04日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v228_beta-2014324", 
            "text": "修复保存文件失败的bug  增加获取服务器时间的方法Bmob.getServerTime   增加华为云推送功能", 
            "title": "v2.2.8_Beta (2014年3月24日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v227_beta-2014107", 
            "text": "修复调用云端代码时BmobClientCallback不能引用的bug   修复CountCallback不能引用的bug", 
            "title": "v2.2.7_Beta (2014年1月07日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v226_beta-20131227", 
            "text": "修正无网络情况下，获取BmobFileUrl为null的bug  改善Context为null时出现的bug 3.新增云端代码功能", 
            "title": "v2.2.6_Beta (2013年12月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v225_beta-20131115", 
            "text": "修正updateAt为null的bug", 
            "title": "v2.2.5_Beta (2013年11月15日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v224_beta-20131113", 
            "text": "修正Date类型数据格式  新增getDate方法获取Date类型数据  新增ACL功能，提高数据安全性  新增加密码重置功能", 
            "title": "v2.2.4_Beta (2013年11月13日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v223_beta-2013927", 
            "text": "新增Count查询功能  新增地理位置查询功能   修正BmobGeoPoint数据类型的存储格式  修正上传文件失败的bug", 
            "title": "v2.2.3_Beta (2013年9月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v222_beta-2013918", 
            "text": "完善缓存策略功能，提供自定义缓存时间，默认缓存时间为5小时  更新接口服务，提升响应速度", 
            "title": "v2.2.2_Beta (2013年9月18日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v221_beta-2013904", 
            "text": "修正一些崩溃的bug   修正更新数据成功后返回的数据结构体   修正查询数据成功后返回的file、GeoPoint、Data等数据类型结构错误的bug   修正无效objectId删除成功的bug   修正分页查询数据不正确的bug   修正未添加网络权限及无网络状态时引起崩溃的bug   修正用户使用正确用户名、密码登陆失败的bug   修改创建数据成功后返回的数据内容   新增查询数据默认的limit为100，最大limit值不可超过1000   新增查询数据时提供6种缓存策略的功能   增加服务器以扩大集群来支撑更大用户量，明显提高响应速度", 
            "title": "v2.2.1_Beta  (2013年9月04日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v220_beta-2013423", 
            "text": "修复重复添加数据的bug.  更新完善开发者指南，如文件查询方式等.  对内部流程的优化精简，减少冗余步骤，提供执行效率.  增加一些操作的callback回调方法.  优化数据传输格式.  提升每一项操作的安全性.", 
            "title": "v2.2.0_Beta (2013年4月23日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v210_beta-2013205", 
            "text": "修复旧版本发现和反馈的bug.  优化SDK的性能，压缩了网络请求的流量损耗.  提升了SDK在网络传输过程中的数据安全.  进一步提升了后端云的并发承载和存储能力，确保服务高效运行.  暂停推送服务，寻求erlang解决方案.", 
            "title": "v2.1.0_Beta (2013年2月05日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v104_beta-2012428", 
            "text": "修复文件类型、地理坐标类型、JsonArray类型、JsonObject类型更新时出现的错误。", 
            "title": "v1.0.4_Beta (2012年4月28日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v103_beta-2012427", 
            "text": "修复用户注册功能中存在的Bug。  修复更新数据失败的重要Bug。  修复更新数据后updateAt(更新时间)字段的值未修改的Bug。  修复Bmob初始化等方法中的参数名称顺序颠倒的问题。  增加用户登录功能。  增加本地用户登录、注销功能。", 
            "title": "v1.0.3_Beta (2012年4月27日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v102_beta-2012424", 
            "text": "修复创建用户对象时，提示数据表名称不正确的Bug。  提供BmobObject数据对象的创建时间、更新时间两个字段值的获取。（BmobObject.getCreatedAt(),BmobObject.getUpdatedAt()）  完善文件类型、地理坐标类型、JsonArray类型、JsonObject这几种数据类型的封装，便于更好的从查询结果中获取数据。", 
            "title": "v1.0.2_Beta (2012年4月24日)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v100_beta-2012408", 
            "text": "产品上线", 
            "title": "v1.0.0_Beta (2012年4月08日)"
        }
    ]
}