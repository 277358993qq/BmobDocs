{
    "docs": [
        {
            "location": "/index.html", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。\n\n\n\n\n安装BmobSDK\n\n\n直接添加类库方式使用BmobSDK\n\n\n1)将BmobSDK引入项目:\n\n\n在你的XCode项目工程中，添加BmobSDK.framework\n\n\n2)添加使用的系统framework:\n\n\n在你的XCode工程中Project -\nTARGETS -\n Build Phases-\nLink Binary With Libraries引入CoreLocation.framework、Security.framework、CoreGraphics.framework、MobileCoreServices.framework、CFNetwork.framework、CoreTelephony.framework、SystemConfiguration.framework、libz.1.2.5.tbd、libicucore.tbd、libsqlite3.tbd、libc++.tbd 、\nlibWeChatSDK.a\n (可以直接点击下载)\n\n\n使用CocoaPods安装BmobSDK\n\n\n如何使用CocoaPods安装BmobSDK可查看 \n我们提供的文档\n\n\n设置应用的BmobKey\n\n\n在你的XCode工程中的AppDelegate.m文件中创建应用Key，填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下：\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{\n    [Bmob registerWithAppKey:@\n申请的Application ID\n];\n    return YES;\n}\n\n\n\n\n也可以在在main.m文件中，引入头文件 \n#import \nBmobSDK/Bmob.h\n\n\nint main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n         NSString *appKey = @\n申请的Application ID\n;\n         [Bmob registerWithAppKey:appKey];\n\n       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate                     class]));\n    }\n}\n\n\n\n\n添加一行数据\n\n\n//往GameScore表添加一条playerName为小明，分数为78的数据\nBmobObject *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n[gameScore setObject:@\n小明\n forKey:@\nplayerName\n];\n[gameScore setObject:@78 forKey:@\nscore\n];\n[gameScore setObject:[NSNumber numberWithBool:YES] forKey:@\ncheatMode\n];\n[gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    //进行操作\n}];\n\n\n\n\n获取一行数据\n\n\n//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object,NSError *error){\n  if (error){\n          //进行错误处理\n  }else{\n        //表里有id为0c6db13c的数据\n      if (object) {\n            //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@\nplayerName\n];\n          BOOL cheatMode = [[object objectForKey:@\ncheatMode\n] boolValue];\n          NSLog(@\n%@----%i\n,playerName,cheatMode);\n      }\n  }\n}];\n\n\n\n\n修改一行数据\n\n\n//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object,NSError *error){\n  //没有返回错误\n  if (!error) {\n      //对象存在\n      if (object) {\n            BmobObject *obj1 = [BmobObject objectWithoutDatatWithClassName:object.className objectId:object.objectId];\n           //设置cheatMode为YES\n          [obj1 setObject:[NSNumber numberWithBool:YES] forKey:@\ncheatMode\n];\n          //异步更新数据\n          [obj1 updateInBackground];\n      }\n  }else{\n    //进行错误处理\n  }\n}];\n\n\n\n\n删除一行数据\n\n\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object, NSError *error){\n    if (error) {\n        //进行错误处理\n    }\n    else{\n        if (object) {\n            //异步删除object\n            [object deleteInBackground];\n        }\n    }\n}];\n\n\n\n\n源码下载\n\n\n快速入门相关源码下载\n\n\n案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的\n案例教程和源码\n，欢迎大家下载和查看。", 
            "title": "快速入门"
        }, 
        {
            "location": "/index.html#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/index.html#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/index.html#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/index.html#bmobsdk", 
            "text": "", 
            "title": "安装BmobSDK"
        }, 
        {
            "location": "/index.html#bmobsdk_1", 
            "text": "1)将BmobSDK引入项目:  在你的XCode项目工程中，添加BmobSDK.framework  2)添加使用的系统framework:  在你的XCode工程中Project - TARGETS -  Build Phases- Link Binary With Libraries引入CoreLocation.framework、Security.framework、CoreGraphics.framework、MobileCoreServices.framework、CFNetwork.framework、CoreTelephony.framework、SystemConfiguration.framework、libz.1.2.5.tbd、libicucore.tbd、libsqlite3.tbd、libc++.tbd 、 libWeChatSDK.a  (可以直接点击下载)", 
            "title": "直接添加类库方式使用BmobSDK"
        }, 
        {
            "location": "/index.html#cocoapodsbmobsdk", 
            "text": "如何使用CocoaPods安装BmobSDK可查看  我们提供的文档", 
            "title": "使用CocoaPods安装BmobSDK"
        }, 
        {
            "location": "/index.html#bmobkey", 
            "text": "在你的XCode工程中的AppDelegate.m文件中创建应用Key，填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下：  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{\n    [Bmob registerWithAppKey:@ 申请的Application ID ];\n    return YES;\n}  也可以在在main.m文件中，引入头文件  #import  BmobSDK/Bmob.h  int main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n         NSString *appKey = @ 申请的Application ID ;\n         [Bmob registerWithAppKey:appKey];\n\n       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate                     class]));\n    }\n}", 
            "title": "设置应用的BmobKey"
        }, 
        {
            "location": "/index.html#_2", 
            "text": "//往GameScore表添加一条playerName为小明，分数为78的数据\nBmobObject *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n[gameScore setObject:@ 小明  forKey:@ playerName ];\n[gameScore setObject:@78 forKey:@ score ];\n[gameScore setObject:[NSNumber numberWithBool:YES] forKey:@ cheatMode ];\n[gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    //进行操作\n}];", 
            "title": "添加一行数据"
        }, 
        {
            "location": "/index.html#_3", 
            "text": "//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object,NSError *error){\n  if (error){\n          //进行错误处理\n  }else{\n        //表里有id为0c6db13c的数据\n      if (object) {\n            //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@ playerName ];\n          BOOL cheatMode = [[object objectForKey:@ cheatMode ] boolValue];\n          NSLog(@ %@----%i ,playerName,cheatMode);\n      }\n  }\n}];", 
            "title": "获取一行数据"
        }, 
        {
            "location": "/index.html#_4", 
            "text": "//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object,NSError *error){\n  //没有返回错误\n  if (!error) {\n      //对象存在\n      if (object) {\n            BmobObject *obj1 = [BmobObject objectWithoutDatatWithClassName:object.className objectId:object.objectId];\n           //设置cheatMode为YES\n          [obj1 setObject:[NSNumber numberWithBool:YES] forKey:@ cheatMode ];\n          //异步更新数据\n          [obj1 updateInBackground];\n      }\n  }else{\n    //进行错误处理\n  }\n}];", 
            "title": "修改一行数据"
        }, 
        {
            "location": "/index.html#_5", 
            "text": "BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object, NSError *error){\n    if (error) {\n        //进行错误处理\n    }\n    else{\n        if (object) {\n            //异步删除object\n            [object deleteInBackground];\n        }\n    }\n}];", 
            "title": "删除一行数据"
        }, 
        {
            "location": "/index.html#_6", 
            "text": "快速入门相关源码下载  案例教程和源码是快速入门的最简单方法，Bmob也为大家准备了相关的 案例教程和源码 ，欢迎大家下载和查看。", 
            "title": "源码下载"
        }, 
        {
            "location": "/module/developdoc/README/index.html", 
            "text": "简介\n\n\nBmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。\n\n\n安装\n\n\n使用CocoaPods安装BmobSDK\n\n\n如何使用CocoaPods安装BmobSDK可查看 \n我们提供的文档\n\n\n兼容iOS9\n\n\niOS9默认不允许进行http请求，所以在使用SDK的过程中需要往Info.plist添加一些内容，\n\n\n\n\n完全取消http请求限制\n\n\n\n\nkey\nNSAppTransportSecurity\n/key\n \n\ndict\n\n\nkey\nNSAllowsArbitraryLoads\n/key\n\n\ntrue/\n\n\n/dict\n\n\n\n\n\n\n\n指定部分网址支持http\n\n\n\n\nkey\nNSAppTransportSecurity\n/key\n \n\ndict\n\n   \nkey\nNSExceptionDomains\n/key\n\n      \ndict\n     \n            \nkey\nyourserver.com\n/key\n    \n        \ndict\n      \n            \nkey\nNSIncludesSubdomains\n/key\n\n                \ntrue/\n\n                \nkey\nNSTemporaryExceptionAllowsInsecureHTTPLoads\n/key\n\n                \ntrue/\n             \n                \nkey\nNSTemporaryExceptionMinimumTLSVersion\n/key\n       \n                \nstring\nTLSv1.1\n/string\n    \n            \n/dict\n   \n        \n/dict\n\n \n/dict\n\n\n\n\n\n另外，最新版的sdk已支持bitcode。\n\n\n其他一些需要注意兼容iOS9的地方可以 \n参照这里\n\n\n应用程序\n\n\n在Bmob平台注册的每个账户都可以创建多个应用程序，每个应用程序都有其独自的应用程序ID，在后续程序编写中，所有的应用程序将凭其ID来使用Bmob SDK。同一个应用可以分别在测试环境和生产环境中部署不同的版本。\n\n\n应用安全\n\n\n请大家在使用Bmob开发应用程序之前，认真阅读我们给大家提供的“数据与安全”的文档，确保你的应用在发布时安全。文档 \n请点击\n;\n\n\n数据迁移\n\n\n从v2.1.8开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：\n\n\n[Bmob resetDomain:@\nhttp://demo.bmob.cn/\n];\n\n\n\n\n其中，参数为开发者的域名，调用后的所有请求都指向新的域名。\n\n\n对象\n\n\n数据对象\n\n\nBmob存储的数据是建立在BmobObject基础上的，每个BmobObject包含键(Key)-值(value)对的JSON兼容数据。这个数据是无模式的，这意味着不需要提前指定每个BmobObject存在什么键。你只需要设置你想要的键值对让我们在后端存储。\n\n\n例如，假设你要记录一个游戏的得分。一个单一的BmobObject对象可能包含：score: 1337, playerName: \"Sean Plott\", cheatMode: false。键必须是字母、数字的字符串。值可以是字符串、数字、布尔值、Json数组、和BmobObject对象等。\n\n\n每个BmobObject有一个ClassName，它对应后台的表名。例如，我们可以调用的游戏分数对象的ClassName为GameScore，那么它在后台对应的表名就是GameScore。\n\n\n特殊对象\n\n\n为了提供更好的服务，BmobSDK中提供了BmobUser、BmobInstallation两个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。\nBmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的\n用户\n部分。\nBmobInstallation对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的\n消息推送\n部分。\n\n\n数据类型\n\n\n目前为止，我们支持的数据类型有NSString、NSNumber、NSDate、NSArray、NSDictionary以及BmobObject及其子类对象类型。对应后台的类型为String、Number、Date、Array、Object以及Pointer。\n\n\n创建BmobObject对象\n\n\nBmobObject提供以下几种方法对BmobOjbect进行初始化：\n\n\n/**\n *  创建一个带有className的BmobObject对象\n *\n *  @param  className   表示对象名称(类似数据库表名)\n *\n *  @return BmobObject\n */\n+(instancetype )objectWithClassName:(NSString*)className;\n\n\n/**\n *  创建一个带有className 和objectId的BmobObject对象\n *\n *  @param className 表名\n *  @param objectId  对象的id\n *\n *  @return BmobObject对象\n */\n+(instancetype)objectWithoutDataWithClassName:(NSString*)className objectId:(NSString *)objectId;\n\n/**\n *  从字典创建BmobObject\n *\n *  @param dictionary 字典\n *\n *  @return BmobObject 对象\n */\n-(instancetype)initWithDictionary:(NSDictionary *)dictionary;\n\n\n\n\n添加数据\n\n\n添加一条数据有两步，第一步是构造数据，第二步是保存数据至服务器上，有以下两种方法：\n\n\n/**\n *  后台保存BmobObject对象，没有返回结果\n */\n-(void)saveInBackground;\n\n/**\n *  后台保存BmobObject对象，返回保存的结果\n *\n *  @param  block   返回保存的结果是成功还是失败\n */\n-(void)saveInBackgroundWithResultBlock:(BmobBooleanResultBlock)block;\n\n\n\n\n比如，在一个游戏的应用中，当需要保存游戏分数、玩家信息到服务器中的时候，就可以创建GameScore表来添加数据，添加数据的形式类型与iOS中的NSMutableDictionary对象类似，如下：\n\n\n    //在GameScore创建一条数据，如果当前没GameScore表，则会创建GameScore表\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    //score为1200\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@\nscore\n];\n    //设置userName为小明\n    [gameScore setObject:@\n小明\n forKey:@\nplayerName\n];\n    //设置cheatMode为NO\n    [gameScore setObject:[NSNumber numberWithBool:NO] forKey:@\ncheatMode\n];\n    //设置age为18\n    [gameScore setObject:[NSNumber numberWithInt:18] forKey:@\nage\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            //创建对象成功，打印对象值\n            NSLog(@\n%@\n,gameScore);\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n\n\n\n\n\n运行完以上代码后，数据即可保存到服务器端了。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你的应用程序的数据浏览项目中查看。你应该看到类似这样的结果：\n\n\n    objectId: \n0c6db13c\n, score: 1200, playerName: \n小明\n, cheatMode: false, createdAt:\n2012-03-29 10:32:54\n, updatedAt:\n2012-03-29 10:32:54\n\n\n\n\n\n这里需要注意几点：\n\n\n\n\n在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode等字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。\n\n\n如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。\n\n\n每个BmobObject对象有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createAt和updateAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键 (数据列)的创建和数据内容是由服务器端来完成的。\n\n\n在 \n[gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error)\n中，成功创建后，error返回的是nil，可以通过 error.localizedDescription 查看返回的错误信息，之后的类似于 \nxxInBackground\n 中的error也是一样的结构。\n\n\nobjectId，updatedAt，createdAt这些系统属性在调用创建函数（saveInBackground）的时候不需要进行设置，创建成功后，会返回objectId，updatedAt，createdAt。\n\n\n\n\n上述方法中每添加一条数据需要设置一次键值对，如果觉得过于繁琐，可以通过一个NSDictionary来添加数据，利用以下方法即可:\n\n\n    -(void)saveAllWithDictionary:(NSDictionary*)dic;\n\n\n\n\n这个函数。\n\n\n如:\n\n\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    //设置playerName列的值为小黑和age列的值18\n    NSDictionary *dic = @{@\nplayerName\n:@\n小黑\n,@\nscore\n:@18};\n    [gameScore saveAllWithDictionary:dic];\n    //异步保存\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后的动作\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n\n\n\n\n更新数据\n\n\n更新一个对象也是非常简单的，首先获取到要更新的BmobObject对象，进行修改值后再更新数据。例如：\n\n\n- (void)updateObject{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@\nscore\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@\n创建成功,以下为对象值\n);\n            NSLog(@\n%@\n,gameScore);\n\n            //此处是更新操作\n            [gameScore setObject:[NSNumber numberWithInt:110] forKey:@\nscore\n];\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n更新成功，以下为对象值，可以看到score值已经改变\n);\n                    NSLog(@\n%@\n,gameScore);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n}\n\n\n\n\n\n如果列存储的是符合JSON格式的字符串对象，可以单独修改该对象的某个值，如有一列名为userAttibute，其值是: {\"name\":\"John\", \"gender\":\"男\"}，如果要修改name为Mike，可以使用以下代码\n\n\n- (void)updateObjectJSONField{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    NSDictionary *json = @{@\nname\n:@\nJohn\n, @\ngender\n:@\nman\n};\n    [gameScore setObject:json forKey:@\nuserAttibute\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@\n创建成功,以下为对象值\n);\n            NSLog(@\n%@\n,gameScore);\n\n            //此处是更新操作\n            BmobObject *gameScoreChanged = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:gameScore.objectId];\n            [gameScoreChanged setObject:@\nMike\n forKey:@\nuserAttibute.name\n];\n            [gameScoreChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n更新成功，以下为对象值，可以看到json里面的name已经改变\n);\n                    NSLog(@\n%@\n,gameScoreChanged);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n}\n\n\n\n\n此处要注意一点，就是在上传 \ngameScore\n 之后，如果要再次进行更新，请重新构造对象，因为此时的 \ngameScore\n 对象还含有\nuserAttibute\n 的值，下面是错误的代码：\n\n\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    NSDictionary *json = @{@\nname\n:@\nJohn\n, @\ngender\n:@\nman\n};\n    [gameScore setObject:json forKey:@\nuserAttibute\n];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@\n创建成功,以下为对象值\n);\n            NSLog(@\n%@\n,gameScore);\n\n            //错误的做法，直接使用gameScore来设置，请观察gameScore值上传时的值\n            [gameScore setObject:@\nwomen\n forKey:@\nuserAttibute.gender\n];\n            NSLog(@\n上传前的gameScore对象值\\n%@\n,gameScore);\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n更新成功，以下为对象值，可以看到json里面的gender已经改变\n);\n                    NSLog(@\n%@\n,gameScore);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnknow error\n);\n        }\n    }];\n}\n\n\n\n\n运行后查看log，我们可以看到，除了userAttibute属性外，gameScore对象还有userAttibute.gender属性上传至服务器，这样服务器就无法区分客户端到底是要更新 userAttibuteg还是只更新userAttibute中的gender，从而报错。\n\n\n2015-12-14 20:45:55.417 BmobSDKDemo[16867:1430005] 创建成功,以下为对象值\n2015-12-14 20:45:55.418 BmobSDKDemo[16867:1430005] \nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n};\n2015-12-14 20:45:55.419 BmobSDKDemo[16867:1430005] 上传前的gameScore对象值\n\nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n    \nuserAttibute.gender\n = women;\n};\n\n\n\n\n原子计数器\n\n\n为了存储一个计数器类型的数据，Bmob提供对任何数字字段进行原子增加(或者减少)的功能，所以我们可以让score像下面一样增加一个固定的值:\n\n\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@\nGameScore\n];\n    [gameScore setObject:@0 forKey:@\natomicCounter\n];\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            BmobObject *gameScoreToBeChanged = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:gameScore.objectId];\n            [gameScoreToBeChanged incrementKey:@\natomicCounter\n];\n            [gameScoreToBeChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n添加成功，可在后台查看objectID为%@的atomicCounter的值是否为1\n,gameScoreToBeChanged.objectId);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n也提供了\n\n\n//列的值增加amount\n- (void)incrementKey:(NSString *)key byAmount:(NSInteger )amount\n//列的值减去一\n- (void)decrementKey:(NSString *)key\n//列的值减去amount\n- (void)decrementKey:(NSString *)key byAmount:(NSInteger )amount\n\n\n\n\n注意：需要调用更新函数才能完成计数器原子增加(或者减少)。\n\n\n删除数据\n\n\n从服务器删除对象：\n\n\n    BmobObject *bmobObject = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n  objectId:@\nbaaf9cfa1b\n];\n    [bmobObject deleteInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //删除成功后的动作\n            NSLog(@\nsuccessful\n);\n        } else if (error){\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\nUnKnow error\n);\n        }\n    }];\n\n\n\n\n批量数据操作\n\n\nBmob提供了批量操作的类BmobObjectsBatch,使用该类，可以批量增加，修改，删除数据，但一次请求不能超过50条数据。下面是例子程序：\n\n\nBmobObjectsBatch    *batch = [[BmobObjectsBatch alloc] init] ;\n//在GameScore表中创建一条数据\n[batch saveBmobObjectWithClassName:@\nGameScore\n parameters:@{@\naveScore\n: @{@\n数学\n:@90},@\nscore\n:@78}];\n//在GameScore表中更新objectId为27eabbcfec的数据\n[batch updateBmobObjectWithClassName:@\nGameScore\n objectId:@\n27eabbcfec\n parameters:@{@\nscore\n: @85}];\n//在GameScore表中删除objectId为30752bb92f的数据\n[batch deleteBmobObjectWithClassName:@\nGameScore\n objectId:@\n30752bb92f\n];\n[batch batchObjectsInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@\nbatch error %@\n,[error description]);\n}];\n\n\n\n\n查询\n\n\n查询单条数据\n\n\n在某些情况下，如果知道某条数据的objectId，而且想得知该条数据的内容，可以使用BmobQuery检索得到一个完整的BmobObject：\n\n\n//查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@\n0c6db13c\n block:^(BmobObject *object,NSError *error){\n  if (error){\n        //进行错误处理\n  }else{\n      //表里有id为0c6db13c的数据\n      if (object) {\n          //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@\nplayerName\n];\n          BOOL cheatMode = [[object objectForKey:@\ncheatMode\n] boolValue];\n          NSLog(@\n%@----%i\n,playerName,cheatMode);\n          //打印objectId,createdAt,updatedAt\n          NSLog(@\nobject.objectId = %@\n, [object objectId]);\n          NSLog(@\nobject.createdAt = %@\n, [object createdAt]);\n          NSLog(@\nobject.updatedAt = %@\n, [object updatedAt]);\n      }\n  }\n}];\n\n\n\n\n查询多条数据\n\n\n在某些情况下，当需要查询表中多条元素的时候，可以直接使用findObjectsInBackgroundWithBlock函数获取查询结果，默认100条。\n\n\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//查找GameScore表的数据\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@\nobj.playerName = %@\n, [obj objectForKey:@\nplayerName\n]);\n            //打印objectId,createdAt,updatedAt\n            NSLog(@\nobj.objectId = %@\n, [obj objectId]);\n            NSLog(@\nobj.createdAt = %@\n, [obj createdAt]);\n            NSLog(@\nobj.updatedAt = %@\n, [obj updatedAt]);\n    }\n}];\n\n\n\n\n这里需要注意的是：\n\n\n1.默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可\n点击查看查询\n一节中的分页查询。\n\n\n2.当查询的是用户表这种系统表的时候，返回的是BmobUser的数组，设备表，角色表也是这样的。\n\n\n3.查询用户表，设备表、角色表为：\n\n\nBmobQuery   *bquery = [BmobUser query]; //用户表\nBmobQuery   *bquery = [BmobInstallation query]; //设备表\nBmobQuery   *bquery = [BmobRole query]; //角色表\n\n\n\n\n条件查询\n\n\n比较查询\n\n\n当然了，在大多数情况下，开发者还是会通过特定的条件来筛选，过滤某些数据来进行查询。BmobQuery也提供了对应的查询方法。\n\n\n如果要过滤特定键的值可以使用- (void)whereKey:(NSString *)key notEqualTo:(id)object。比如需要查询playerName不等于”小明”的数据时可以这样写：\n\n\n当然，你也可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。\n\n\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n//添加playerName不是小明的约束条件\n[bquery whereKey:@\nplayerName\n notEqualTo:@\n小明\n];\n\n\n\n\n各种不同条件的比较查询，还有\n\n\n各种不同的比较查询：\n[bquery whereKey:@\nage\n lessThan:[NSNumber numberWithInt:18]];//age小于18\n[bquery whereKey:@\nage\n lessThanOrEqualTo:[NSNumber numberWithInt:18]]; //age小于或等18\n[bquery whereKey:@\nage\n greaterThan:[NSNumber numberWithInt:18]]; //age大于18\n[bquery whereKey:@\nage\n greaterThanOrEqualTo:[NSNumber numberWithInt:18]]; //age大于或等于18\n\n\n\n\n这里有点需要注意的是\n\n\n时间搜索的话，等于的情况因为服务器是精确到微秒值，所以比较的值要加1秒。\n\n\n子查询\n\n\n如果你想查询匹配几个不同值的数据，如要查询“小明”，“小红”，“小白”三个人的信息是，可以使用\n\n\n- (void)whereKey:(NSString *)key containedIn:(NSArray *)array;\n\n\n\n\n函数，如下面所示：\n\n\n[bquery whereKey:@\nplayerName\n containedIn:[NSArray arrayWithObjects:@\n小明\n,@\n小红\n,@\n小白\n, nil]];\n\n\n\n\n如果是关联关系，直接在数组里面填写objectId即可，如下\n\n\n [bquery whereKey:@\nauthor\n containedIn:@[@\n063a2d739e\n,@\nb97ca382c3\n]];\n\n\n\n\n相反，要排除这几个人的信息可以用\n\n\n- (void)whereKey:(NSString *)key notContainedIn:(NSArray *)array;\n\n\n\n\n函数，如下所示：\n\n\n[bquery whereKey:@\nplayerName\n notContainedIn:[NSArray arrayWithObjects:@\n小明\n,@\n小红\n,@\n小白\n, nil]];\n\n\n\n\n列值是否存在\n\n\n其他的约束条件有\n\n\n//设置查询中该字段是有值的结果\n-(void)whereKeyExists:(NSString *)key;\n//设置查询中该字段是没有值的结果\n-(void)whereKeyDoesNotExist:(NSString *)key;\n\n\n\n\n例如:\n\n\n//查询表中score列有值的数据\n[bquery whereKeyExists:@\nscore\n];\n\n\n\n\n//查询表中score列没有值的数据\n[bquery whereKeyDoesNotExist:@\nscore\n];\n\n\n\n\n模糊查询\n\n\n对字符串值的模糊查询 比如查询包含字符串的值，有几种方法。如下：\n\n\n//使用正则表达式查询\n-(void)whereKey:(NSString*)key matchesWithRegex:(NSString*)regex;\n//查询以特定字符串开头的值\n-(void)whereKey:(NSString *)key startWithString:(NSString*)start;\n//查询以特定字符串结尾的值\n-(void)whereKey:(NSString *)key endWithString:(NSString*)end;\n\n\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n分页查询\n\n\n有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用limit方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为100，最大有效设置值1000（设置的数值超过1000还是视为1000）。\n\n\nbquery.limit = 3;//限制得到的结果条数为3条\n\n\n\n\n在数据较多的情况下，在limit的基础上分页显示数据是比较合理的解决办法，skip属性可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为0。\n\n\nbquery.skip = 3;//跳过3条数据\n\n\n\n\n排序\n\n\n对应数据的排序，如数字和字符串，可以使用升序或降序的方式来控制查询数据的结果顺序：\n\n\n// 升序\n- (void)orderByAscending:(NSString *)key ;\n// 降序\n- (void)orderByDescending:(NSString *)key ;\n\n\n\n\n例如，分数由高到低的排序可以写成\n\n\n[bquery orderByDescending:@\nscore\n];\n\n\n\n\n当需要组合排序的时候可以这样处理\n\n\n//先按照年龄升序排序，年龄一样再按照更新时间降序排序\n[bquery orderByAscending:@\nage\n]\n[bquery orderByDescending:@\nupdatedAt\n]\n\n\n\n\n复合查询\n\n\n当简单的查询条件，不能满足查询要时，BmobQuery也提供了2种复合查询的方法。\n\n\n//并查询\n-(void)addTheConstraintByAndOperationWithArray:(NSArray*)array;\n//或查询\n-(void)addTheConstraintByOrOperationWithArray:(NSArray *)array;\n\n\n\n\n数组里面存的是若干个条件字典，其格式为\n\n\n@{@\n列名\n:条件值}\n\n\n\n\n例如：\n\n\n//查询score列中值等于5且姓名为Mike的数据\nNSArray *array =  @[@{@\nscore\n:@5},@{@\nname\n:@\nMike\n}];\n[bquery addTheConstraintByAndOperationWithArray:array];\n\n\n\n\n支持的条件符号有\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n$lt\n\n\n小于\n\n\n\n\n\n\n$lte\n\n\n小于等于\n\n\n\n\n\n\n$gt\n\n\n大于\n\n\n\n\n\n\n$gte\n\n\n大于等于\n\n\n\n\n\n\n$ne\n\n\n不等于\n\n\n\n\n\n\n$in\n\n\n在数组中\n\n\n\n\n\n\n$nin\n\n\n不在数组中\n\n\n\n\n\n\n$exists\n\n\n值不为空\n\n\n\n\n\n\n$or\n\n\n合成查询中的或查询\n\n\n\n\n\n\n$and\n\n\n合成查询中的与查询\n\n\n\n\n\n\n$regex\n\n\n匹配PCRE表达式\n\n\n\n\n\n\n\n\n例如:\n\n\n//查询score列中值大于150或者小于5的数据\nNSArray *array =  @[@{@\nscore\n:@{@\n$gt\n:@150}},@{@\nscore\n:@{@\n$lt\n:@5}}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n\n\n\n//查询score列中值大于5和小于150的数据\nNSArray *array =  @[@{@\nscore\n:@{@\n$gt\n:@5}},@{@\nscore\n:@{@\n$lt\n:@150}}];\n[bquery addTheConstraintByAndOperationWithArray:array];\n\n\n\n\n需要注意的是，如果是要查找条件为等于的数据的话，直接构造成{@\"列名\":条件}即可，例如下面的例子:\n\n\n//查找分数为90分跟分数为150分的数据\nNSArray *array =  @[@{@\nscore\n:@90},@{@\nscore\n:@150}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n//查找名字为张三跟李四的数据\nNSArray *array =  @[@{@\nname\n:@\n张三\n},@{@\nname\n:\n李四\n}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n\n\n\n其中日期类型和pointer类型构造的方法比较特殊。\n例如要查询要个时间段的数据，可以构造时间\n\n\n//createdAt大于或等于 2014-07-15 00:00:00\n NSDictionary *condiction1 = @{@\ncreatedAt\n:@{@\n$gte\n:@{@\n__type\n: @\nDate\n, @\niso\n: @\n2014-07-15 00:00:00\n}}}; \n//createdAt小于 2014-10-15 00:00:00\nNSDictionary *condiction2 = @{@\ncreatedAt\n:@{@\n$lt\n:@{@\n__type\n: @\nDate\n, @\niso\n: @\n2014-10-15 00:00:00\n}}};\nNSArray *condictonArray = @[condiction1,condiction2];\n//作用就是查询创建时间在2014年7月15日到2014年10月15日之间的数据\n[bquery addTheConstraintByAndOperationWithArray:condictonArray];\n\n\n\n\n如果查询的条件刚好是pointer类型的话，例如要查询某篇文章的作者是A或者B的话，可以这样构造数据:\n\n\nBmobQuery *query = [BmobQuery queryWithClassName:@\nPost\n];\n//列author为pointer类型，指向用户表\n//假设用户A的objectId为aaaa ,其中classname为表名\nNSDictionary *condiction1 = @{@\nauthor\n:@{@\n__type\n:@\nPointer\n,@\nclassName\n:@\n_User\n,@\nobjectId\n:@\naaaa\n}};\n//假设用户b的objecId为bbbb\nNSDictionary *condiction2= @{@\nauthor\n:@{@\n__type\n:@\nPointer\n,@\nclassName\n:@\n_User\n,@\nobjectId\n:@\nbbbb\n}};\nNSArray *condictionArray = @[condiction1,condiction2];\n//查找作者为用户A或者作者为用户B的数据\n[query addTheConstraintByOrOperationWithArray:condictionArray];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n}];\n\n\n\n\n另外我们还封装了以下方法，方便开发者使用，以下是与查询，注意add之前的查询只能添加一个条件，如果是或查询，将\n[main andOperation];\n换成\n[main orOperation];\n\n\n    BmobQuery   *bquery = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    [bquery whereKey:@\nscore\n equalTo:[NSNumber numberWithDouble:10.3]];\n    BmobQuery   *bquery1 = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    [bquery1 whereKey:@\nplayerName\n equalTo:@\ntest\n];\n\n    BmobQuery   *main = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    [main add:bquery];\n    [main add:bquery1];\n    [main andOperation];\n    [main findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@\n%@\n,obj);\n            NSLog(@\nobj.playerName = %@\n, [obj objectForKey:@\nplayerName\n]);\n        }\n    }];\n\n\n\n\n返回指定列\n\n\n有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用以下方法来只返回需要的列的值\n\n\n//设置查询后返回的字段数组  \n-(void)selectKeys:(NSArray*)keys;\n\n\n\n\n//指定返回查询的结果包括score和playerName两列的数据\n[bquery selectKeys:@[@\nscore\n,@\nplayerName\n]];\n\n\n\n\n查询结果计数\n\n\n如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配的对象的具体数据信息，可以直接使用count替代find。例如，查询一个特定玩家玩的游戏场数：\n\n\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery whereKey:@\nplayerName\n equalTo:@\nBarbie\n];\n[bquery countObjectsInBackgroundWithBlock:^(int number,NSError  *error){\n         NSLog(@\n%d\n,num);\n}];\n\n\n\n\n统计查询\n\n\n如果你想对表进行统计查询，可以采用以下方法。\n\n\n统计查询方法\n\n\n统计方法共有以下几种,分别用于计算总和、平均值、最大值、最小值\n\n\n- (void)sumKeys:(NSArray *)keys\n- (void)averageKeys:(NSArray *)keys\n- (void)maxKeys:(NSArray *)keys\n- (void)minKeys:(NSArray *)keys\n\n\n\n\n设置完成后使用下面的方法来返回结果。\n\n\n- (void)calcInBackgroundWithBlock:(BmobObjectArrayResultBlock)block\n\n\n\n\n例如，如果我们要计算GameScore表所有玩家的得分总和，可以使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *sumArray = [NSArray arrayWithObject:@\nscore\n];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                NSDictionary *dic = [[NSDictionary alloc] init];\n                dic = [array objectAtIndex:0];\n                NSLog(@\nsum of score:%d\n,[[dic objectForKey:@\n_sumScore\n] intValue] );\n            }\n        }\n    }];\n\n\n\n\n计算总和只对Number类型的列有效，列名使用数组存放。返回的字典key值为_sum+首字母大写的列名，其它计算方法与sum类似，其返回的字典key值见下表\n\n\n\n\n\n\n\n\n关键字\n\n\nkey值\n\n\n例子\n\n\n\n\n\n\n\n\n\n\nsum\n\n\n_sum+首字母大写\n\n\n_sumScore\n\n\n\n\n\n\naverage\n\n\n_avg+首字母大写\n\n\n_avgScore\n\n\n\n\n\n\nmax\n\n\n_max+首字母大写\n\n\n_maxScore\n\n\n\n\n\n\nmin\n\n\n_min+首字母大写\n\n\n_minScore\n\n\n\n\n\n\n\n\n分组统计\n\n\n分组可用于获取并不复杂的列值，如我想知道playerName列中有多少个不同的玩家名字，可使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore_LT\n];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@\nplayerName\n];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@\nplayerName\n];\n                    NSLog(@\nplayer:%@\n,playerName);\n                }\n            }\n        }\n    }];\n\n\n\n\n另外，groupby可以结合计算函数来使用，比如我想统计每个玩家的总分，可以使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@\nplayerName\n];\n    NSArray *sumArray = [NSArray arrayWithObject:@\nscore\n];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@\nplayerName\n];\n                    NSString *sum = [dic objectForKey:@\n_sumScore\n];\n                    NSLog(@\nplayer:%@\\tsum:%@\n,playerName,sum);\n                }\n            }\n        }\n    }];\n\n\n\n\n分组记录数\n\n\n有时候，我们还想知道分组统计时每个分组有多少条记录，设置isGroupcount为YES即可,如下：\n\n\n    bquery.isGroupcount = YES;\n\n\n\n\n这样在返回的结果中就会包含类似于以下的键值对：\n\n\n_count = 10\n\n\n\n\n添加过滤条件\n\n\n利用计算方法返回来的值可以通过限制条件来获取我们想关注的结果。添加条件使用以下方法。\n\n\n -(void)constructHavingDic:(NSDictionary *)havingDic\n\n\n\n\n该方法通过构造havingDic来添加限制条件，其使用方法与复杂查询类似。\n\n\n例如，我们统计每个玩家的总分，但我们只需要得到总分大于50的玩家，可以使用以下代码得到：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@\nplayerName\n];\n    [bquery groupbyKeys:groupbyArray];\n    NSArray *sumArray = [NSArray arrayWithObject:@\nscore\n];\n    [bquery sumKeys:sumArray];\n    NSDictionary *condication = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:50],@\n$gt\n, nil];\n    [bquery constructHavingDic:[[NSDictionary alloc] initWithObjectsAndKeys:condication,@\n_sumScore\n, nil]];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\nerror is:%@\n,error);\n        } else{\n            if (array) {\n                NSLog(@\n%@\n,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@\nplayerName\n];\n                    NSString *sum = [dic objectForKey:@\n_sumScore\n];\n                    NSLog(@\nplayer:%@\\tsum:%@\n,playerName,sum);\n                }\n            }\n        }\n    }];\n\n\n\n\n缓存查询\n\n\n缓存查询通常是将查询结果缓存在磁盘上，当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。这样可以让用户不必在按下某个按钮后进行枯燥的等待。 默认的查询操作是没有启用缓存的，开发者可以通过设置BmobCachePolicy来启用缓存功能。例如：优先从网络获取数据，如果获取失败时再从缓存获取数据，这种情况通常用在网络不可用的情况下。\n\n\nbquery.cachePolicy = kBmobCachePolicyNetworkElseCache;\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array,NSError *error){\n}];\n\n\n\n\nBmobSDK提供几种不同的缓存策略，以使用不同应用场景的需求。\n\n\n\n\nkBmobCachePolicyIgnoreCache\n\n\n\n\n只从网络获取数据，且数据不会缓存在本地，这是默认的缓存策略。\n\n\n\n\nkBmobCachePolicyCacheOnly\n\n\n\n\n只从缓存读数据，如果缓存没有数据，返回一个空数组。\n\n\n\n\nkBmobCachePolicyNetworkOnly\n\n\n\n\n只从网络获取数据，同时会在本地缓存数据。\n\n\n\n\nkBmobCachePolicyCacheElseNetwork\n\n\n\n\n先从缓存读取数据，如果没有再从网络获取。\n\n\n\n\nkBmobCachePolicyNetworkElseCache\n\n\n\n\n先从网络获取数据，如果没有，再从缓存读取。\n\n\n\n\nkBmobCachePolicyCacheThenNetwork\n\n\n\n\n先从缓存读取数据，无论结果如何都会再次从网络获取数据，在这种情况下，Block将产生两次调用。通常这种做法是先快速从缓存读取数据显示在界面，然后在后台连接网络获取最新数据，取到后再更新界面。\n\n\n|检查是否存在当前查询条件的缓存数据\n\n\n[bquery hasCachedResult];\n\n\n\n\n存在返回YES，否则返回NO\n|清除当前查询的缓存数据\n\n\n[bquery clearCachedResult];\n\n\n\n\n|清除所有查询结果的缓存数据\n\n\n[BmobQuery clearAllCachedResults];\n\n\n\n\n|设置缓存有限时间，单位为秒\n\n\nbquery.maxCacheAge = 10000;\n\n\n\n\nBQL查询\n\n\nBmob Query Language\n（简称 BQL）是 Bmob 自 \nBmobSDK V1.5.7\n 版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询 API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。\n\n\n具体的 BQL 语法，请参考 \nBmob Query Language 详细指南\n。\n\n\n基本BQL查询\n\n\n可以通过以下方法来进行SQL查询：\n\n\n例如：需要查询所有的游戏得分记录\n\n\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @\nselect * from GameScore_BQL\n;\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result.resultsAry);\n            }\n        }\n    }];\n\n\n\n\n其中result.resultsAry为BmobObject数组。\n\n\n如果需要查询个数，则可以这样：\n\n\n    NSString *bql = @\nselect count(*) from GameScore_BQL\n;\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%d\n,result.count);\n            }\n        }\n    }];\n\n\n\n\n其中result.count为记录条数，需要注意的是如果没有使用count关键字进行查询的话，对象result的count属性是没有意义的。\n\n\n统计BQL查询\n\n\n由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用  \n- (void)statisticsInBackgroundWithBQL:(NSString *)bql block:(BmobBQLArrayResultBlock)block;\n 方法来进行。\n\n\n     NSString *bql = @\nselect sum(score) from GameScore_BQL group by playerName\n;\n    [bmobQuery statisticsInBackgroundWithBQL:bql block:^(NSArray *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result);\n            }\n        }\n    }];\n\n\n\n\n目前统计查询支持的关键字如下表所示，即如果在sql语句中包含以下关键字时，则需要使用统计查询方法才能返回正确结果：\n\n\n\n\n\n\n\n\nkey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ngroup by\n\n\n分组操作\n\n\n\n\n\n\ngroupcount\n\n\n返回每个分组的总记录\n\n\n\n\n\n\nhaving\n\n\n分组中的过滤条件\n\n\n\n\n\n\nsum\n\n\n计算总和\n\n\n\n\n\n\naverage\n\n\n计算平均值\n\n\n\n\n\n\nmax\n\n\n计算最大值\n\n\n\n\n\n\nmin\n\n\n计算最小值\n\n\n\n\n\n\n\n\n占位符查询\n\n\n在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的 \nPreparedStatement\n 使用占位符查询的语法结构。\n\n\n注：目前只有where和limit关键字以及内置函数支持使用占位符。\n\n\n普通查询\n\n\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @\nselect * from GameScore_BQL where playerName = ? and score = ?\n;\n    NSArray *placeholderArray = @[@\nname2\n,@9];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result.resultsAry);\n            }\n        }\n    }];\n\n\n\n\n数组中的数据会依次替换bql中的问号。\n\n\n内置函数\n\n\n对于包含\n内置函数\n的占位符查询，比较特殊，请使用\nBmob Query Language 详细指南\n中的\n内置函数\n中\n占位符查询用到的内置函数\n用到的内置函数列出的形式进行查询操作：\n\n\n举例：我想查询在 '2015-05-14 14:56:30' 后的创建的记录，可以这样：\n\n\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @\nselect * from GameScore_BQL where createdAt \n date(?)\n;\n    NSArray *placeholderArray = @[@\n2015-05-14 14:56:30\n];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            if (result) {\n                NSLog(@\n%@\n,result.resultsAry);\n            }\n        }\n    }];\n\n\n\n\n注\n\n\n1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；\n\n\n2、同样的，统计查询也支持占位符,只需要\n- (void)statisticsInBackgroundWithBQL:(NSString *)bql pvalues:(NSArray*)pvalues block:(BmobBQLArrayResultBlock)block;\n方法即可。\n\n\nBQL缓存策略\n\n\n如果要使用缓存策略，可用 \n- (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;\n 方法，样例代码如下：\n\n\n    NSString *bql = [NSString stringWithFormat:@\nselect * from %@ where %@ = ?\n,TABLENAME,COLPLAYERNAME];\n    NSArray *placeholder = @[@\nname1\n];\n\n    BmobQuery *bmobQueryWriteCache = [[BmobQuery alloc] init];\n    bmobQueryWriteCache.cachePolicy = kBmobCachePolicyNetworkOnly;\n    [bmobQueryWriteCache setBQL:bql];\n    [bmobQueryWriteCache setPlaceholder:placeholder];\n    [bmobQueryWriteCache queryBQLCanCacheInBackgroundWithblock:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (result){\n            NSLog(@\nactual:%@\n,result);\n        }\n    }];\n\n\n\n\n注意：\n\n\n\n\nBQL查询方法中，只有 \n- (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;\n 才能使用缓存策略，其它方法即使设置了缓存策略也无缓存效果；\n\n\n使用\n- (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;\n进行查询时，通过 \n-(void)setBQL:(NSString*)bql;\n 和 \n-(void)setPlaceholder:(NSArray*)ary;\n 来设置BQL语句和占位符。\n\n\n\n\n缓存策略只对普通查询有效，统计查询只支持从网络进行查询。具体使用可参考iOS开发文档中的\n查询\n缓存查询小节。\n\n\n数组\n\n\n为了存储数组型数据，\nBmob\n提供了3种操作来原子性地更改一个数组字段:\n\n\nAdd\n 在一个数组字段的后面添加一些指定的对象(包装在一个数组内)\n\n\nAddUnique\n 只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的\n\n\nRemove\n 从一个数组字段的值内移除指定的数组中的所有对象\n\n\n添加数组数据\n\n\n添加一行记录时创建一个普通的类似于列表的数组类型字段，可以使用以下方法添加：\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[gameScore addObjectsFromArray:@[@\nP1\n,@\nP2\n] forKey:@\nskill\n];\n[gameScore updateInBackground];\n\n\n\n\n删除数组数据\n\n\n当需要移除数组里的数据时可以使用\n\n\n-(void)removeObjectsInArray:(NSArray *)objects forKey:(NSString *)key;\n\n\n\n\n如下面就移除了P3这个元素:\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[gameScore removeObjectsInArray:@[@\nP3\n] forKey:@\nskill\n];\n[gameScore updateInBackground];\n\n\n\n\n更新数组数据\n\n\n每一种方法都会有一个objects，即包含了这些方法将被添加或删除的对象列表，举个例子，技能skills是一个类似于集合的数组类型，那么我们可以在skills中加入一些对象，只有在skills原来的对象中不包含这些值的情况下才会被加入:\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[gameScore addUniqueObjectsFromArray:@[@\nP3\n] forKey:@\nskill\n];\n[gameScore updateInBackground];\n\n\n\n\n查询数组数据\n\n\n对于Key的类型是数组的情况，可以查找Key的数组值中包含有P1的对象。代码如下：\n\n\n    //查询数组中包含某个元素的记录\n    BmobQuery *query = [BmobQuery queryWithClassName:@\nGameScore\n];\n    [query whereKey:@\nskill\n equalTo:@\nP1\n];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@\n%@\n,obj);\n            }\n        }\n    }];\n\n\n\n\n你同样可以使用\"$all\"操作符来找到类型为数组的Key的值中同时包含有P1和P2的对象:\n\n\n    //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@\nGameScore\n    \n];\n    NSArray *array = @[@\nP1\n,@\nP2\n];\n    [query1 whereKey:@\nskill\n equalTo:@{@\n$all\n:array}];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@\n%@\n,obj);\n            }\n        }\n    }];\n\n\n\n\n当然，你也可以使用我们封装好的方法来查找\n\n\n    //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@\nGameScore\n];\n    NSArray *array = @[@\nP1\n,@\nP2\n];\n    [query1 whereKey:@\nskill\n containsAll:array];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@\n%@\n,obj);\n            }\n        }\n    }];\n\n\n\n\n如果要查找包含P1或P2的对象，可以使用复杂查询中的或查\n\n\n    BmobQuery *query = [BmobQuery queryWithClassName:@\nPost\n];\n    NSArray *array =  @[@{@\nskill\n:@{@\n$all\n: @[@\nP1\n]}},@{@\nskill\n:@{@\n$all\n:@[@\nP2\n]}}];\n    [query addTheConstraintByOrOperationWithArray:array];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            NSLog(@\n%d\n,array.count);\n            for (BmobObject *obj in array) {\n                 NSLog(@\n%@\n,obj);\n            }\n\n        }\n    }];\n\n\n\n\n使用索引和对象key修改数组中的对象\n\n\n比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]\n\n\n那么我们要修改projectExperiences数组中第一个对象的name值：\n\n\nBmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@\nGameScore\n objectId:@\nxxxxxxxx\n];\n[bmobObject setObject:@\n项目名称2\n forKey:@\nprojectExperiences.0.name\n];\n[gameScore updateInBackground];\n\n\n\n\n数据关联\n\n\n数据关联章节Demo下载\n\n\n关联关系描述\n\n\n在程序设计中，不同类型的数据之间可能存在某种关系。分别是以下三种：\n1. 一对一，比如车队给司机分车，1个司机对应1台车；\n2. 一对多，比如1个作者会对应多篇贴子；\n3. 多对多，比如1篇帖子会有多个喜欢的读者，而每个读者也会有多篇喜欢的帖子。\n前面的两种关系我们提供Pointer类型来表示，而最后一种关系我们使用Relation类型来表示\n\n\n在下面的讲解中我们可能会使用到以下的两张表，其表结构如下：\n\n\n_User\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nstring\n\n\n\n\n\n\n\n\nusername\n\n\nstring\n\n\n用户名，用户可以是作者发帖子，也可以是读者发评论\n\n\n\n\n\n\n\n\nPost\n\n\n\n\n\n\n\n\n字段\n\n\n类型\n\n\n含义\n\n\n\n\n\n\n\n\n\n\nobjectId\n\n\nstring\n\n\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n帖子标题\n\n\n\n\n\n\ncontent\n\n\nstring\n\n\n帖子内容\n\n\n\n\n\n\nauthor\n\n\nPointer(_User)\n\n\n作者\n\n\n\n\n\n\nlikes\n\n\nRelation(_User)\n\n\n喜欢帖子的读者\n\n\n\n\n\n\n\n\n预先在后台添加记录\n_User表\n\n\n\n\nPost表\n\n\n\n\n\n\nPointer的使用\n\n\n添加关系\n\n\n例如，user1写了一篇帖子，需要在Post表中添加一条记录，并且该记录包含一个关联author1记录的字段数据，可采用以下代码：\n\n\n    BmobObject  *post = [BmobObject objectWithClassName:@\nPost\n];\n    //设置帖子的标题和内容\n    [post setObject:@\ntitle4\n forKey:@\ntitle\n];\n    [post setObject:@\ncontent4\n forKey:@\ncontent\n];\n\n    //设置帖子关联的作者记录\n    BmobUser *author = [BmobUser objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n];\n    [post setObject:author forKey:@\nauthor\n];\n\n    //异步保存\n    [post saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功，返回objectId，updatedAt，createdAt等信息\n            //打印objectId\n            NSLog(@\nobjectid :%@\n,post.objectId);\n        }else{\n            if (error) {\n                NSLog(@\n%@\n,error);\n            }\n        }\n    }];\n\n\n\n\n添加成功后在后台的结果如下图所示，我们可以看到，author列的值是用圆框框起来的，表示这是一个Pointer，显示的值，为对应记录的objectId,点击它可以进入_User表中：\n\n\n\n\n我们可以这么理解关联关系，它就是一个类型为指针的字段，利用它可以指向其它表的某条记录。\n\n\n删除关系\n\n\n如果需要删除某篇帖子关联的作者可以使用\n\n\n- (void)deleteForKey:(id)key\n\n\n\n\n具体代码如下：\n\n\n    BmobQuery   *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n    [bquery getObjectInBackgroundWithId:@\nZqQ7KKKx\n block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@\n%@\n,error);\n        }else{\n            if (object) {\n                BmobObject *post = object;\n                //将author列的值置为空\n                [post deleteForKey:@\nauthor\n];\n                //进行更新\n                [post updateInBackground];\n            }\n        }\n    }];\n\n\n\n\n结果如下，可以看到，author列已经被置空\n\n\n\n\n修改关系\n\n\n如果需要修改某篇帖子关联的作者，可以使用以下代码:\n\n\n    BmobQuery   *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n    //获得objectId查找出先前添加的文章\n    [bquery getObjectInBackgroundWithId:@\nZqQ7KKKx\n block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@\n%@\n,error);\n        }else if (object) {\n            BmobObject *post = object;\n            //获得BmobUser对象\n            BmobUser *user = [BmobUser objectWithoutDataWithClassName:@\n_User\n objectId:@\nqXZeCCCX\n];\n            //设置post的author值为新获得的BmobUser对象\n            [post setObject:user forKey:@\nauthor\n];\n\n            //进行更新\n            [post updateInBackground];\n        }\n    }];\n\n\n\n\n可以看到关联记录已经被修改：\n\n\n\n\n查询关系\n\n\n查询某个特定作者的帖子，可以用 \n-(void)whereKey:(NSString *)key equalTo:(id)object\n,具体代码如下\n\n\n //查询帖子表\n BmobQuery *query = [BmobQuery queryWithClassName:@\nPost\n];\n //构建objectId为vbhGAAAY 的作者\n BmobUser *author = [BmobUser objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n];\n //添加作者是objectId为vbhGAAAY条件\n [query whereKey:@\nauthor\n equalTo:author];\n [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@\n%@\n,[post objectForKey:@\ntitle\n]);\n            }\n        }\n    }];\n\n\n\n\n如我们需要查询帖子，并且需要将该帖子关联的作者的信息（objectId,username）打印出来，我们可以使用以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n\n    //声明该次查询需要将author关联对象信息一并查询出来\n    [bquery includeKey:@\nauthor\n];\n\n    [bquery getObjectInBackgroundWithId:@\nZqQ7KKKx\n block:^(BmobObject *object, NSError *error) {\n\n        //打印文章标题，内容\n        BmobObject *post = object;\n        NSLog(@\ntitle:%@\n,[post objectForKey:@\ntitle\n]);\n        NSLog(@\ncontent:%@\n,[post objectForKey:@\ncontent\n]);\n\n        //取得文章的关联作者对象\n        BmobUser *author = [post objectForKey:@\nauthor\n];\n        //打印文章的关联作者对象的相关信息\n        NSLog(@\nobjectId:%@\n,author.objectId);\n        NSLog(@\nname:%@\n,[author objectForKey:@\nusername\n]);\n    }];\n\n\n\n\n查询关系的核心在于查询前需要将关联的列名include进来，使用下列方法即可\n\n\n- (void)includeKey:(NSString *)key\n\n\n\n\n如果查询多个关联关系，可以使用以下方法，使用逗号(,)操作来使查询中包含多个属性\n\n\n[bquery includeKey:@\ncolumn1,column2,...\n];\n\n\n\n\n如果关联关系存在嵌套，可以使用以下英文字符点号(.)来操作，如下：\n\n\n[bquery includeKey:@\ncolumn1.column2\n];\n\n\n\n\n另外，include 时可以指定返回的字段，如下：\n\n\n//只返回likes列的数据\n[bquery includeKey:@\npost[likes]\n];\n\n//返回title和content列数据\n[bquery includeKey:@\npost[title|content]\n];\n\n\n\n\n约束关联对象值查询\n\n\n我们可以对关联对象的值进行约束，来进行匹配查询。例如，如果我们想找查询出所有关联了user2的文章，可以使用以下代码\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@\n_User\n];\n    [inQuery whereKey:@\nusername\n equalTo:@\nuser2\n];\n\n    //匹配查询\n    [bquery whereKey:@\nauthor\n matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@\n%@\n,[post objectForKey:@\ntitle\n]);\n            }\n        }\n    }];\n\n\n\n\n如果想要查询找所有没有关联user1的文章，则将\n\n\n[bquery whereKey:@\nauthor\n matchesQuery:inQuery];\n\n\n\n\n替换成\n\n\n[bquery whereKey:@\nauthor\n doesNotMatchQuery:inQuery];\n\n\n\n\n即可。\n\n\nPointer本质\n\n\nPointer可以用来表示一对一或者一对多的关系，其实可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针以获得另外关联的对象。当然，我们也可以给这些指针指向的关联记录进行约束，只查询出符合特定条件的记录。\n\n\nRelation的使用\n\n\n添加关联关系\n\n\n如果我们需要在Post表中添加一个字段以记录喜欢该贴子的读者，我们可以使用以下代码：\n\n\n    //获取要添加关联关系的post\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n]];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nqXZeCCCX\n]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@\nlikes\n];\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\nsuccessful\n);\n        }else{\n            NSLog(@\nerror %@\n,[error description]);\n        }\n    }];\n\n\n\n\n可以看到添加了一个 \nlikes\n 列，点击进去可以查看到该列里面存在哪些数据。\n\n\nPost表：\n\n\n\n\n从Post表中的title4记录点击关联关系框进去后查看的结果：\n\n\n\n\n删除关联关系\n\n\n如果要从刚刚的添加的likes列中删去其中一个读者，可采用以下代码。\n\n\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation removeObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nvbhGAAAY\n]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@\nlikes\n];\n\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\nsuccessful\n);\n        }else{\n            NSLog(@\nerror %@\n,[error description]);\n        }\n    }];\n\n\n\n\n从Author表中的author1记录点击关联关系框进去后查看的结果：\n\n\n\n\n修改关联关系\n\n\n如果需要给objectId为ZqQ7KKKx的帖子添加多一个喜欢该帖子的读者可以使用以下代码\n\n\n    BmobObject *author = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@\n_User\n objectId:@\nJ6RU888L\n]];\n    //添加关联关系到postlist列中\n    [author addRelation:relation forKey:@\nlikes\n];\n\n    //异步更新obj的数据\n    [author updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\nsuccessful\n);\n        }else{\n            NSLog(@\nerror %@\n,[error description]);\n        }\n    }];\n\n\n\n\n运行代码后，从Author表中的author1记录点击关联关系框进去后查看的结果：\n\n\n\n\n查询关联关系\n\n\n如果我们需要查询喜欢objectId为ZqQ7KKKx的帖子的所有读者，可以采用下列代码：\n\n\n    //关联对象表\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\n_User\n];\n\n    //需要查询的列\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@\nPost\n objectId:@\nZqQ7KKKx\n];\n    [bquery whereObjectKey:@\nlikes\n relatedTo:post];\n\n\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobObject *user in array) {\n                NSLog(@\n%@\n,[user objectForKey:@\nusername\n]);\n            }\n        }\n    }];\n\n\n\n\n注意：跟Pointer不同的是，这里本质上查询的是_User表。\n\n\nRelation约束关联对象值查询\n\n\n上面的查询是查找喜欢某篇帖子的所有读者，如果反过来，需要查找某个读者喜欢的所有帖子又要怎么做呢？可以参考以下代码：\n\n\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@\nPost\n];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@\n_User\n];\n    [inQuery whereKey:@\nusername\n equalTo:@\nuser3\n];\n\n    //匹配查询\n    [bquery whereKey:@\nlikes\n matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@\n%@\n,[post objectForKey:@\ntitle\n]);\n            }\n        }\n    }];\n\n\n\n\nRelation的本质\n\n\nRelation可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。\n\n\n用户管理\n\n\n属性\n\n\nBmobUser除了从BmobObject继承的属性外，还有几个特定的属性：\n\n\n\n\nusername: 用户的用户名（必需）。\n\n\npassword: 用户的密码（必需）。\n\n\nemail: 用户的电子邮件地址（可选）。\n\n\n\n\nBmobUser自动处理用户账户管理所需的功能。\n\n\n-(void)setUsername:(NSString *)username;//用户名，必需\n-(void)setPassword:(NSString*)password;//密码，必需\n-(void)setEmail:(NSString *)email;//设置邮箱\n-(void)setObject:(id)obj forKey:(id)key;//设置某个属性的值\n-(id)objectForKey:(id)key;//得到某个属性的值\n\n\n\n\n注册\n\n\n应用很常见的一个功能就是，注册用户，使用BmobUser注册用户也不复杂，如下的例子所示\n\n\nBmobUser *bUser = [[BmobUser alloc] init];\n[bUser setUsername:@\n小明\n];\n[bUser setPassword:@\n123456\n];\n[bUser setObject:@18 forKey:@\nage\n];\n[bUser signUpInBackgroundWithBlock:^ (BOOL isSuccessful, NSError *error){\n    if (isSuccessful){\n        NSLog(@\nSign up successfully\n);\n    } else {\n        NSLog(@\n%@\n,error);\n    }\n}];\n\n\n\n\n需要有两点需要注意的是：\n\n\n\n\n有些时候你可能需要在用户注册时发送一封邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-\n邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在用户注册时自动发动一封验证给用户。\n\n\n\n\n\n\n\n\nusername字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。\n\n\n\n\n登录\n\n\n当用户注册成功后，需要让他们以后能够登录到他们的账户使用应用。要做到这点可以使用\n\n\n[BmobUser loginWithUsernameInBackground:@\n小明\n\n    password:@\n123456\n];\n\n\n\n\n也可以使用\n\n\n+ (void)loginWithUsernameInBackground:(NSString *)username\n                              password:(NSString *)password\n                                 block:(BmobUserResultBlock)block;\n\n\n\n\nBmob还提供了用户、email、手机号码均可作为账号进行登录的功能。使用以下方法即可\n\n\n    [BmobUser loginInbackgroundWithAccount:account andPassword:password block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@\n%@\n,user);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n获取当前用户\n\n\n每次你登录成功，都会在本地磁盘中有一个缓存的用户对象作为当前用户，可以获取这个缓存的用户对象来进行登录：\n\n\nBmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n    //进行操作\n}else{\n    //对象为空时，可打开用户注册界面\n}\n\n\n\n\n当然，你也可以用如下的方法清除缓存用户对象：\n\n\n[BmobUser logout];\n\n\n\n\n1.这个用户对象缓存了基本的数据，所以可以通过-(id)objectForKey:(id)key; 这个方法来得到某一列的值\n\n\n2.[BmobUser getCurrentObject] 跟[BmobUser getCurrentUser]功能作用是一样的，因版本升级的原因才保留了[BmobUser getCurrentObject]\n\n\n3.由于是缓存的数据，所以web端的修改，本地是不会更新的!!!需要重新登录才会更新本地缓存数据\n\n\n4.缓存用户的有效期为1年\n\n\n更新用户\n\n\n当用户登录成功后，在本地有个缓存的用户对象，如果开发者希望更改当前用户的某个属性可按如下代码操作:\n\n\nBmobUser *bUser = [BmobUser getCurrentUser];\n//更新number为30\n[bUser setObject:@30 forKey:@\nnumber\n];\n[bUser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@\nerror %@\n,[error description]);\n}];\n\n\n\n\n一般来说，使用当前用户对象来进行资料更新可能会遇到一个问题。如果当前用户上次登录的时间距离当前时间过长，存放在本地的Token就有可能会过期，导致用户更新资料失败，这是需要重新登录，登录成功后才能更新资料。\n\n\n在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封邮件验证信息给用户。\n\n\n查询用户\n\n\n查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：\n\n\n    BmobQuery *query = [BmobUser query];\n    [query whereKey:@\nusername\n equalTo:@\nxiaolv\n];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobUser *user in array) {\n            NSLog(@\nobjectid %@\n,user.objectId);\n        }\n    }];\n\n\n\n\n浏览器中查看用户表\n\n\nUser表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。\n\n\n\n\n修改密码\n\n\n从 \nv1.6.3\n 开始，我们提供使用旧密码来重置新密码的接口，示例如下：\n\n\n    BmobUser *user = [BmobUser getCurrentUser];\n    [user updateCurrentUserPasswordWithOldPassword:@\nold password\n newPassword:@\nnew password\n block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //用新密码登录\n            [BmobUser loginInbackgroundWithAccount:@\nname\n andPassword:@\nnew password\n block:^(BmobUser *user, NSError *error) {\n                if (error) {\n                    NSLog(@\nlogin error:%@\n,error);\n                } else {\n                    NSLog(@\nuser:%@\n,user);\n                }\n            }];\n        } else {\n            NSLog(@\nchange password error:%@\n,error);\n        }\n    }];\n\n\n\n\n找回密码\n\n\n为方便大家了解如何用Bmob开发找回密码的功能，我们为大家准备了另外一份文档，详细见我们在Github中的文档：\n\n\nhttps://github.com/bmob/bmob-cloudcode-demo/blob/master/HOW-TO-FIND-PASSWORD.md\n\n\n邮箱\n\n\n邮箱验证\n\n\n设置邮件验证是可选的一个应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.\n\n\nBmobUser *user = [BmobUser getCurrentUser];\n//应用开启了邮箱验证功能\nif ([user objectForKey:@\nemailVerified\n]) {\n    //用户没验证过邮箱\n    if (![[user objectForKey:@\nemailVerified\n] boolValue]) {\n        [user verifyEmailInBackgroundWithEmailAddress:@\nxxxxxxxxxx\n];\n    }\n}\n\n\n\n\n邮箱修改密码\n\n\n一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。\n\n\n重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可：\n\n\n[BmobUser requestPasswordResetInBackgroundWithEmail:@\nxxxx@qq.com\n];\n\n\n\n\n密码重置流程如下：\n\n\n\n\n用户输入他们的电子邮件，请求重置自己的密码。\n\n\nBmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。\n\n\n用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示，他们可以输入一个新的密码。\n\n\n用户的密码已被重置为新输入的密码。\n\n\n\n\n第三方账号登录\n\n\nBmob提供了非常简单的方法来实现使用第三方账号登陆的功能，目前支持新浪微博、手机QQ账号以及微信账号的登陆。以下是我们提供的一个demo\nThirdPartyLogin\n\n\n新浪微博账号注册登录\n\n\n在\n新浪微博开放平台\n注册应用，然后根据\n新浪微博 iOS SDK使用说明\n安装SDK以及获取，开发者通过新浪微博提供的SDK得到用户的信息后，就可以调用BmobUser提供的方法来注册登录到应用。\n\n\n//得到的新浪微博授权信息，请按照例子来生成NSDictionary\nNSDictionary *dic = @{@\naccess_token\n:token,@\nuid\n:uid,@\nexpirationDate\n:date};\n//通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:dic\n                                      platform:BmobSNSPlatformSinaWeibo\n                                         block:^(BmobUser *user, NSError *error) {\n                                             NSLog(@\nuser objectid is :%@\n,user.objectId);\n                                         }];\n\n\n\n\n手机QQ账号登录\n\n\n同样的，开发者通过QQ授权得到用户的信息后，同样可以调用BmobUser提供的方法来注册登录到应用。下面的例子是通过QQ提供的SDK授权得到的信息，进行登录的：\n\n\n//得到的qq授权信息，请按照例子来生成NSDictionary\n NSDictionary *responseDictionary = @{@\naccess_token\n: _tencentOauth.accessToken,@\nuid\n:_tencentOauth.openId,@\nexpirationDate\n:_tencentOauth.expirationDate};\n //通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformQQ\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@\nerror%@\n,[error description]);\n                                            }];\n\n\n\n\n微信账号登录\n\n\nNSDictionary *responseDictionary = @{@\naccess_token\n: accessToken,@\nuid\n:openId,@\nexpirationDate\n:expirationDate};\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformWeiXin\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@\nerror%@\n,[error description]);\n                                            }];\n\n\n\n\n第三方账号与BmobUser绑定\n\n\n如果你的应用中有其他功能已经使用到了相关第三方平台的功能，比如社交分享功能，那么你可以将已经得到的用户授权信息传递给BmobSDK来便捷地与BmobUser进行绑定。以下代码展示了将第三方账号和已经存在的BmobUser对象进行绑定：\n\n\n//新浪微博账号关联到当前用户\nNSDictionary *dic = @{@\naccess_token\n:token,@\nuid\n:uid,@\nexpirationDate\n:date};\nBmobUser *currentUser = [BmobUser getCurrentUser];\n[currentUser linkedInBackgroundWithAuthorDictionary:dic\n                                           platform:BmobSNSPlatformSinaWeibo\n                                              block:^(BOOL isSuccessful, NSError *error) {\n                                                     NSLog(@\nERROR :%@\n,[error description]);\n                                                 }];\n\n\n\n\n//手机qq账号关联到当前用户\nNSDictionary *responseDictionary = @{@\naccess_token\n: _tencentOauth.accessToken,@\nuid\n:_tencentOauth.openId,@\nexpirationDate\n:_tencentOauth.expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformQQ\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@\nerror%@\n,[error description]);\n                                   }];\n\n\n\n\n//微信账号关联到当前用户\nNSDictionary *responseDictionary = @{@\naccess_token\n: accessToken,@\nuid\n:openId,@\nexpirationDate\n:expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@\nerror%@\n,[error description]);\n                                   }];\n\n\n\n\n解除绑定\n\n\n解除绑定的账号，也是很简单的。下面是例子：\n\n\n//当前用户解除关联的微博账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformSinaWeibo\n                                    block:^(BOOL isSuccessful, NSError *error) {\n                                        NSLog(@\nerror is :%@\n,[error description]);\n                                    }];\n\n\n\n\n//当前用户解除关联的手机QQ账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformQQ\n                                     block:^(BOOL isSuccessful, NSError *error) {\n                                         NSLog(@\nerror is :%@\n,[error description]);\n                                     }];                                                                          \n\n\n\n\n//当前用户取消关联微信账号\nNSDictionary *responseDictionary = @{@\naccess_token\n: accessToken,@\nuid\n:openId,@\nexpirationDate\n:expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@\nerror%@\n,[error description]);\n                                   }];\n\n\n\n\n手机号相关功能\n\n\n从 \nv1.5.8\n 开启Bmob加入了手机注册登录及密码重置等功能。以下介绍的功能可参考我们提供的\nBmobSmsDemo\n（使用前请先在Appdelegate.m中填入你的app id）\n\n\n注：以下的新功能如果需要填入验证码参数的，请先调用请求验证码方法。\n\n\n手机号注册\n\n\n可使用以下代码进行一键注册并登录的操作。在使用前必须先请求手机验证码，注册成功后将以当前的手机号码作为用户名，并且会缓存用户信息在本地，可使用 \n[BmobUser getCurrentUser]\n 获取。\n\n\n[BmobUser signOrLoginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@\n%@\n,user);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n}];\n\n\n\n\n如果希望在用手机注册时为用户添加密码或者其它信息，可以使用以下代码实现：\n\n\n    BmobUser *buser = [[BmobUser alloc] init];\n    buser.mobilePhoneNumber = @\n15123456789\n;\n    buser.password = @\n123\n;\n    buser.email = @\nxxx@gmail.com\n;\n    [buser signUpOrLoginInbackgroundWithSMSCode:@\n6位验证码\n block:^(BOOL isSuccessful, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            BmobUser *user = [BmobUser getCurrentUser];\n            NSLog(@\n%@\n,[BmobUser getCurrentUser]);\n        }\n    }];\n\n\n\n\n手机号登录\n\n\nBmob除了提供手机号验证码一键注册登录功能外，还另外提供了希望只给已存在用户用手机号进行登录的功能。代码如下：\n\n\n\n    [BmobUser loginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@\n%@\n,user);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n绑定手机号\n\n\n绑定手机号的基本思路为，先获取验证码，验证取得的验证码后再更新 \nmobilePhoneNumber\n 和 \nmobilePhoneNumberVerified\n 即可，这是我们推荐的做法。当然，你也可以不通过验证码，直接使用用户输入的手机号来更新 \nmobilePhoneNumber\n 来进行绑定，不过这种方法并不推荐。\n\n\n    //验证\n    [BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andSMSCode:smsCode resultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //修改绑定手机\n            BmobUser *buser = [BmobUser getCurrentUser];\n            buser.mobilePhoneNumber = mobilePhoneNumber;\n            [buser setObject:[NSNumber numberWithBool:YES] forKey:@\nmobilePhoneNumberVerified\n];\n            [buser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@\n%@\n,buser);\n                } else {\n                    NSLog(@\n%@\n,error);\n                }\n            }];\n\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n手机号修改密码\n\n\n通过请求验证码和输入验证码从而进行账号密码重置，代码如下：\n\n\n    [BmobUser resetPasswordInbackgroundWithSMSCode:smsCode andNewPassword:newPassword block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@\n%@\n,@\n重置密码成功\n);\n        } else {\n            NSLog(@\n%@\n,error);\n        }\n    }];\n\n\n\n\n子类化\n\n\n很多时候BmobObject并不能满足用户的需求，用户可能需要继承BmobOject来定制自己的需求。但是当用户需要保存继承类的属性至后台时，还需要做一些额外的处理。因此，我们推出子类化BmobObject的选项，以让用户的代码具备更好的扩展性。\n\n\n子类化的使用\n\n\n先来定义一个BmobObject的子类。\n\n\nTest.h\n\n\n\n@interface Test : BmobObject\n@property (copy, nonatomic) NSString *title;\n@property (copy, nonatomic) NSString *name;\n@property (strong, nonatomic) NSNumber *isStudent;\n@property (strong, nonatomic) NSNumber *age;\n@end\n\n\n\n\nTest.m\n\n\n\n@implementation Test\n\n@synthesize title;\n@synthesize name;\n@synthesize isStudent;\n@synthesize age;\n\n@end\n\n\n\n\n后面你就可以像以下形式那样使用Test类了\n\n\n    Test *test = [[Test alloc] init];\n    test.title = @\ntitle2\n;\n    test.name = @\nname2\n;\n    test.isStudent = [NSNumber numberWithBool:NO];\n    test.age = @22;\n    [test sub_saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,error);\n        NSLog(@\nobjectId %@\n,test.objectId);\n    }];\n\n\n\n\n注意：\n1.当用到添加与更新操作时，要使用类似于sub_XXX的方法，而其它方法保持不变，与BmobObject一致。\n2.子类的方法使用对象类型，不要使用基本类型。例如，要使用整型时，可以声明为NSNumber。\n\n\n针对BmobUser的特别说明\n\n\n如果要使用继承BmobUser的子类来进行登录，在构造其子类时，应用类似于以下的形式。\n\n\n TestUser *user = [[TestUser alloc] initFromBmobObject:[BmobUser getCurrentUser]];\n    user.email = @\nxxxaa@qq.com\n;\n    [user sub_updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\nerror %@\n,error.description);\n    }];\n\n\n\n\n\n注意，此方法无法更新本地用户缓存，因此需要慎重考虑是是否子类化BmobUser。\n\n\n查询\n\n\n查询后需要使用以下方法以得到子类的对象。\n\n\n    BmobQuery *testQuery = [Test query];\n    [testQuery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            Test *t = [[Test alloc] initFromBmobObject:obj];\n\n        }\n    }];\n\n\n\n\n文件管理\n\n\n文件管理章节Demo\n\n\n创建文件对象\n\n\nBmobFile可以让你的应用程序将文件存储到服务器中，比如常见的文件类型图像文件，影像文件、音乐文件和任何其他二进制数据都可以使用。当文件上传成功后，可以通过url属性来获取文件的地址。\n\n\n上传文件\n\n\n1.6.9版本之后，上传服务使用CDN服务\n\n\n上传文件方法\n\n\n如下图的例子，是将cs.txt的文本文件保存到服务器端：\n\n\n-(void)saveInBackground:(BmobBooleanResultBlock)block;\n\n\n\n\n可以在block里面把文件添加到gameScore里面，建议使用异步上传的方法，再在block进行操作。如下面的例子：\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@\nGameScore\n];\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n     //如果文件保存成功，则把文件添加到filetype列\n     if (isSuccessful) {\n         [obj setObject:file1  forKey:@\nfiletype\n];\n         //此处相当于新建一条记录,      //关联至已有的记录请使用 [obj updateInBackground];\n         [obj saveInBackground];\n         //打印file文件的url地址\n         NSLog(@\nfile1 url %@\n,file1.url);\n     }else{\n        //进行处理\n     }\n}];\n\n\n\n\n上传文件进度\n\n\n在上传文件时，有时会需要获取上传文件进度的需求。这时，可以使用\n\n\n-(void)saveInBackground:(BmobBooleanResultBlock)block withProgressBlock:(BmobProgressBlock)progressBlock;\n\n\n\n\n如在下面的例子中，打印上传的进度\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@\ngameScoreFile\n];\nBmobFile *file1 = [[BmobFile alloc] initWithClassName:@\nAsc\n withFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        [obj setObject:file1  forKey:@\nuserFile\n];\n        [obj saveInBackground];\n        NSLog(@\nfile1 url %@\n,file1.url);\n    }\n} withProgressBlock:^(CGFloat progress) {\n    NSLog(@\n上传进度%.2f\n,progress);\n}];\n\n\n\n\n以分片的方式上传文件\n\n\n分片上传文件和上传整个文件的机制有所不同，是先把整个文件进行分片（256KB一片），然后再进行一片一片的上传（具体实现可查看\nRestAPI文档\n）。当文件以分片的方式上传到Bmob服务器时，具有几种优势：\n\n\n\n\n\n\n适合于尺寸较大的文件传输，通过切片来避免单个HTTP数据量过大而导致连接超时；\n\n\n\n\n\n\n在网络条件较差的环境下，较小的尺寸可以有较高的上传成功率，从而避免无休止的失败重试；\n\n\n\n\n\n\n在BmobSDK中对应的函数方法为\n\n\n-(void)saveInBackgroundByDataSharding:(BmobBooleanResultBlock)block;\n\n\n\n\n示例如下：\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\n//上传cs.txt文件\nNSString *fileString = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@\ngameScoreFile\n];\n//创建BmobFile对象\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackgroundByDataSharding:^(BOOL isSuccessful, NSError *error) {\n   if (isSuccessful) {\n        //如果成功，保存文件到userFile\n       [obj setObject:file1  forKey:@\nuserFile\n];\n       [obj saveInBackground];\n   }else{\n       //失败，打印错误信息\n        NSLog(@\nerror: %@\n,[error description]);\n   }\n} ];\n\n\n\n\n批量上传文件\n\n\n有时，开发者需要一次性上传多个文件，这是可以使用SDK提供的多个上传文件的方法来使用\n\n\nNSBundle    *bundle = [NSBundle mainBundle];\n//文件cncc.jpg的路径\nNSString *fileString = [NSString stringWithFormat:@\n%@/cncc.jpg\n ,[bundle bundlePath] ];\n//文件cs.txt的路径\nNSString *fileString2 = [NSString stringWithFormat:@\n%@/cs.txt\n ,[bundle bundlePath] ];\n[BmobFile filesUploadBatchWithPaths:@[fileString,fileString2]\n                      progressBlock:^(int index, float progress) {\n                           //index 上传数组的下标，progress当前文件的进度\n                          NSLog(@\nindex %d progress %f\n,index,progress);\n                      } resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n                      //array 文件数组，isSuccessful 成功或者失败,error 错误信息\n                      BmobObject *obj = [[BmobObject alloc] initWithClassName:@\ngameScoreFile\n];\n                          for (int i = 0 ; i \n array.count ;i ++) {\n                              BmobFile *file = array [i];\n                              NSString *key = [NSString stringWithFormat:@\nuserFile%d\n,i];\n                              [obj setObject:file  forKey:key];\n                          }                          \n                          [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) { \n                              }];\n                      }];\n\n\n\n\n下载文件\n\n\n获取文件对象只需通过-(id)objectForKey:(id)key;来得到，例如，\n\n\nBmobFile *file = (BmobFile*)[gameScore objectForKey:@\nfiletype\n];\n\n\n\n\n可用通过file的url属性(file.url)，来得到文件的地址进行下载。\n\n\n删除文件\n\n\n删除文件接口只能删除1.6.9版本之后上传的文件\n\n\n如果需要删除文件，使用以下接口即可\n\n\n/**\n *  异步请求删除文件\n *\n *  @param block 返回删除结果与信息，如果删除成功，则无返回信息\n */\n-(void)deleteInBackground:(BmobBooleanResultBlock)block;\n\n\n\n\n当开发者需要一次性删除多个文件的时候，可以调用批量删除文件的接口\n\n\n    NSArray *array = @[@\nhttp://bmob-cdn-1.b0.upaiyun.com/jpg/579c8dc6676e460b82d83c8eb5c8aaa5.jpg\n,@\nhttp://bmob-cdn-1.b0.upaiyun.com/jpg/59e3817d6cec416ba99a126c9d42768f.jpg \n]\n\n    [BmobFile filesDeleteBatchWithArray:array resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n        NSLog(@\nfail delete array %@\n,array);\n        NSLog(@\nerror %@\n,error.localizedDescription);\n        NSLog(@\nissuccessful %i\n,isSuccessful);\n    }];\n\n\n\n\n缩略图\n\n\n只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果，\n如图\n，\n具体可参考这里 。\n\n\n数据实时功能\n\n\nBmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。\n\n\n监听功能\n\n\nSDK提供了两个方法来监听数据变化，其中一个方法是针对表，另一个则针对行。\n\n\n-(void)listenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;\n\n\n\n\n这个函数可以监听到表更新（包括该表的行数据的变化）、表删除的行为。例如:\n\n\n-(void)listen{\n    //创建BmobEvent对象\n    _bmobEvent          = [BmobEvent defaultBmobEvent];\n    //设置代理\n    _bmobEvent.delegate = self;\n    //启动连接\n    [_bmobEvent start];\n}\n\n\n\n\n在代理的函数，进行操作\n\n\n//可以进行监听或者取消监听事件\n-(void)bmobEventCanStartListen:(BmobEvent *)event{\n    //监听Post表更新\n    [_bmobEvent listenTableChange:BmobActionTypeUpdateTable tableName:@\nPost\n];\n}\n//接收到得数据\n-(void)bmobEvent:(BmobEvent *)event didReceiveMessage:(NSString *)message{\n    //打印数据\n    NSLog(@\ndidReceiveMessage:%@\n,message);\n}\n\n\n\n\n相对的，也有监听行更新。行删除的函数：\n\n\n-(void)listenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;\n\n\n\n\n当然了表删除，行更新，行删除等行为也可以在代理函数-(void)bmobEventCanStartListen:(BmobEvent *)event上进行监听。例如：\n\n\n-(void)bmobEventCanStartListen:(BmobEvent *)event\n    //监听Test表删除事件，\n    [_bmobEvent listenTableChange:BmobActionTypeDeleteTable tableName:@\nTest\n];\n    //监听Post表中objectId为a1419df47a 的行更新事件\n    [_bmobEvent listenRowChange:BmobActionTypeUpdateRow tableName:@\nPost\n objectId:@\na1419df47a\n];\n    //监听Post表中objectId为wb1o000F 的行删除事件\n    [_bmobEvent listenRowChange:BmobActionTypeDeleteRow tableName:@\nPost\n objectId:@\nwb1o000F\n];\n}\n\n\n\n\n需要注意的是，监听事件后，接收到的数据是json格式的字符串，可以序列化为NSDictionary。\n\n\n取消监听功能\n\n\n当开发者想取消监听某个行为时，可以使用下面的函数\n\n\n//取消订阅表的变化事件,包括表更新，表删除\n-(void)cancleListenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;\n\n\n\n\n和\n\n\n//取消订阅行的变化事件\n-(void)cancleListenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;\n\n\n\n\n这里有个\n实例\n可以参考下。\n\n\nACL和角色\n\n\n大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：\n\n\n\n\n对于私有数据，读写权限可以只局限于数据的所有者。\n\n\n对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。\n\n\n对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。\n\n\n属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。\n\n\n一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。\n\n\n\n\n默认访问权限\n\n\n在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：\n\n\nBmobACL *acl = [BmobACL ACL];\n//设置所有人读权限为true\n[acl setPublicReadAccess];\n//设置所有人写权限为true\n[acl setPublicWriteAccess];\n\n\n\n\n注意：可读可写是默认的权限，不需要写额外的代码。\n\n\n指定用户的访问权限\n\n\n假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：\n\n\nBmobObject *blog = [[BmobObject alloc] initWithClassName:@\nblog\n] ;\n[blog setObject:@\n论电影的七个元素\n forKey:@\ntitle\n];\n[blog setObject:@\n这是blog的具体内容\n forKey:@\ncontent\n];\nBmobACL *acl = [BmobACL ACL];\n[acl setPublicReadAccess];//设置所有人可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：\n\n\nBmobObject *blog = [[BmobObject alloc] initWithClassName:@\nblog\n] ;\n[blog setObject:@\n一个人的秘密\n forKey:@\ntitle\n];\n[blog setObject:@\n这是blog的具体内容\n forKey:@\ncontent\n];\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n角色管理\n\n\n上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：\n\n\n//创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@\nwageinfo\n];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@\nwage\n];\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser *boss        = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *hr_zhang    = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *cashier_xie = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *me          = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n//4个用户对象均可读\n[acl setReadAccessForUser:boss];\n[acl setReadAccessForUser:hr_zhang];\n[acl setReadAccessForUser:cashier_xie];\n[acl setReadAccessForUser:me];\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];\n[acl setWriteAccessForUser:hr_zhang];\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：\n\n\n//创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@\nwageinfo\n];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@\nwage\n];\n//这里创建5个用户对象，分别为老板、人事小张、人事小罗、出纳小谢和自己\nBmobUser *boss           = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *hr_zhang       = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *hr_luo         = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];;\nBmobUser *cashier_xie    = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\nBmobUser *me             = [BmobUser objectWithoutDataWithClassName:@\nUser\n objectId:@\nxxxxxx\n];\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole *hr             = [BmobRole roleWithName:@\nHR\n];\nBmobRole *cashier        = [BmobRole roleWithName:@\nCashier\n];\n//将hr_zhang和hr_luo归属到hr角色中\nBmobRelation *hrRelation = [BmobRelation relation];\n[hrRelation addObject:hr_zhang];\n[hrRelation addObject:hr_luo];\n[hr addUsersRelation:hrRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[hr saveInBackground];\n//将cashier_xie归属到cashier角色中\nBmobRelation *cashierRelation = [BmobRelation relation];\n[cashierRelation addObject:cashier_xie];\n[cashier addUsersRelation:cashierRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[cashier saveInBackground];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:boss];// 假设老板只有一个, 设置读权限\n[acl setReadAccessForUser:me];// 给自己设置读权限\n[acl setReadAccessForRole:hr];// 给hr角色设置读权限\n[acl setReadAccessForRole:cashier];// 给cashier角色设置读权限\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];// 设置老板拥有写权限\n[acl setWriteAccessForRole:hr];// 设置ht角色拥有写权限\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];\n\n\n\n\n需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。\n\n\n角色之间的从属关系\n\n\n下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。\n\n\n//创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole *mobileDep =[BmobRole roleWithName:@\nMobileDep\n];\nBmobRole *androidTeam = [BmobRole roleWithName:@\nAndroidTeam\n];\nBmobRole *iosTeam     = [BmobRole roleWithName:@\niOSTeam\n];\n//保存AndroidTeam和iosTeam角色到云端\n[androidTeam saveInBackground];\n[iosTeam saveInBackground];\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nBmobRelation *relation = [BmobRelation relation];\n[relation addObject:androidTeam];\n[relation addObject:iosTeam];\n[mobileDep addRolesRelation:relation];\n// 假设创建三个代码数据对象\nBmobObject *coreCode = [BmobObject objectWithClassName:@\nCode\n];\nBmobObject *androidCode = [BmobObject objectWithClassName:@\nCode\n];\nBmobObject *iosCode = [BmobObject objectWithClassName:@\nCode\n];\n//......此处省略一些具体的属性设定\n[coreCode saveInBackground];\n[androidCode saveInBackground];\n[iosCode saveInBackground];\n//设置androidTeam角色对androidCode对象的读和写的权限\n[androidCode.ACL setReadAccessForRole:androidTeam];\n[androidCode.ACL setWriteAccessForRole:androidTeam];\n//设置iosTeam角色对iosCode对象的读和写的权限\n[iosCode.ACL setReadAccessForRole:iosTeam];\n[iosCode.ACL setWriteAccessForRole:iosTeam];\n//设置mobileDep角色可以对coreCode对象进行读操作\n[coreCode.ACL setReadAccessForRole:mobileDep];\n\n\n\n\n地理位置\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置息的信查询。你可以在BmobObject的查询中添加一个BmobGeoPoint的对象查询。你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n地理位置对象\n\n\n首先需要创建一个BmobGeoPoint对象。例如，创建一个-东经116.39727786183357度北纬39.913768382429105度的BmobGeoPoint对象：\n\n\nBmobGeoPoint *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\n\n\n\n\n添加地理信息\n\n\n[gameScore setObject:point forKey:@\nlocation\n];\n\n\n\n\n地理查询\n\n\n现在，你的数据表中有了一定的地理坐标对象的数据，这样可以测试找出最接近某个点的信息了。你可以使用BmobQuery对象的whereNear方法来这样做：\n\n\nBmobGeoPoint  *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery whereKey:@\nlocation\n nearGeoPoint:point];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];\n\n\n\n\n要限制查询指定距离范围的数据可以使用whereWithinKilometers(公里)、whereWithinMiles(英里)或whereWithinRadians(弧度)方法。 要查询一个矩形范围内的信息可以使用whereWithinGeoBox来实现：\n\n\nBmobGeoPoint *southwestOfSF = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobGeoPoint* northeastOfSF =[[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:40.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@\nGameScore\n];\n[bquery whereKey:@\nlocation\n withinGeoBoxFromSouthwest:southwestOfSF\n                                           toNortheast:northeastOfSF];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];\n\n\n\n\n注意事项\n\n目前有几个需要注意的地方：\n\n\n\n\n\n\n每个BmobObject数据对象中\n只能\n有一个BmobGeoPoint对象。\n\n\n\n\n\n\n地理位置的点不能超过规定的范围。\n纬度的范围\n应该是在\n-90.0到90.0\n之间。\n经度的范围\n应该是在\n-180.0到180.0\n之间。如果您添加的经纬度超出了以上范围，将导致程序错误。\n\n\n\n\n\n\n地理位置查询最大的距离根据表数据的不同有不同的限制，使用-(void)whereKey:(NSString \n)key nearGeoPoint:(BmobGeoPoint \n)geopoint;默认\n100KM\n。当需要指定距离时，最好指定一下最大距离。\n\n\n\n\n\n\n其它功能\n\n\n获取服务器时间\n\n\n获取服务器时间戳可以直接调用[Bmob getServerTimestamp]，例如：\n\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n        //设置时区\n        [dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\nAsia/Shanghai\n]];\n        //时间格式\n        [dateFormatter setDateFormat:@\nyyyy-MM-dd hh:mm:ss\n];\n        //调用获取服务器时间接口，返回的是时间戳\n        NSString  *timeString = [Bmob getServerTimestamp];\n        //时间戳转化成时间\n        NSDate *date = [NSDate dateWithTimeIntervalSince1970:[timeString intValue]];\n        NSString *dateStr = [dateFormatter stringFromDate:date];\n        NSLog(@\n北京时间:%@\n,dateStr);\n    });\n\n\n\n\n\n设置API网络请求超时时间\n\n\n使用 \n+(void)setBmobRequestTimeOut:(CGFloat)seconds;\n 方法可以设置API中网络请求的超时时间，例如，想要设置访问Bmob后台时超过15s就返回超时错误，可以这样写.\n\n\n[Bmob setBmobRequestTimeOut:15];\n\n\n\n\n\nBmobSDK默认是20s后得不到回复就提示超时，如果没有特别的需求，建议不要设置该时间。\n\n\n获取表结构\n\n\n从 \nv1.6.1\n 开始，我们开放获取表结构的接口。\n\n\n获取特定表的结构\n\n\n可通过表名来获取特定表的结构，样例代码如下：\n\n\n    [Bmob getTableSchemasWithClassName:@\n_User\n callBack:^(BmobTableSchema *bmobTableSchema, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            //直接用description来查看表结构\n            NSLog(@\n%@\n,bmobTableSchema.description);\n\n            /*\n             分别打印表结构\n            */\n            //打印表名\n            NSLog(@\n表名:%@\n,bmobTableSchema.className);\n            //打印表结构\n            NSDictionary *fields = bmobTableSchema.fields;\n            NSArray *allKey = [fields allKeys];\n            for (NSString *key in allKey) {\n                NSLog(@\n列名:%@\n,key);\n                NSDictionary *fieldStrcut = [fields objectForKey:key];\n                NSLog(@\n列类型:%@\n,[fieldStrcut objectForKey:@\ntype\n] );\n                if ([[fieldStrcut objectForKey:@\ntype\n] isEqualToString:@\nPointer\n]) {\n                    NSLog(@\n关联关系指向的表名:%@\n,[fieldStrcut objectForKey:@\ntargetClass\n]);\n                }\n            }\n        }\n    }];\n\n\n\n\n获取所有表的结构\n\n\n可通过以下代码得到所有表的结构\n\n\n    [Bmob getAllTableSchemasWithCallBack:^(NSArray *tableSchemasArray, NSError *error) {\n        if (error) {\n            NSLog(@\n%@\n,error);\n        } else {\n            for (BmobTableSchema* bmobTableSchema in tableSchemasArray) {\n                //直接用description来查看表结构\n                NSLog(@\n%@\n,bmobTableSchema.description);\n\n                /*\n                 分别打印表结构\n                 */\n                //打印表名\n                NSLog(@\n表名:%@\n,bmobTableSchema.className);\n                //打印表结构\n                NSDictionary *fields = bmobTableSchema.fields;\n                NSArray *allKey = [fields allKeys];\n                for (NSString *key in allKey) {\n                    NSLog(@\n列名:%@\n,key);\n                    NSDictionary *fieldStrcut = [fields objectForKey:key];\n                    NSLog(@\n列类型:%@\n,[fieldStrcut objectForKey:@\ntype\n] );\n                    if ([[fieldStrcut objectForKey:@\ntype\n] isEqualToString:@\nPointer\n]) {\n                        NSLog(@\n关联关系指向的表名:%@\n,[fieldStrcut objectForKey:@\ntargetClass\n]);\n                    }\n                }\n            }\n        }\n    }];\n\n\n\n\n\n返回数据说明\n\n\n表结构以 \nBmobTableSchema\n 对象的形式返回，其中属性 \nclassName\n 表示表名，而属性 \nfields\n 是一个字典，里面包含了所有列的类型，其结构如下：\n\n\n{@\n列名1\n:dic,@“列名2”:dic}\n\n\n\n\n而dic的结构为：\n\n\n{@\ntype\n:@\ntypeName\n,@\ntargetClass\n:@\ntableName\n}\n\n\n\n\n其中 \ntype\n 指的是该类的类型， 而 \ntargetClass\n 指的是指向的表名，只有在 \ntype\n 为 \nPointer\n 或者 \nRelation\n 时才有值。\n\n\n具体形式如下：\n\n\n{\n    ACL =     {\n        type = Object;\n    };\n    author =     {\n        targetClass = \n_User\n;\n        type = Pointer;\n    };\n    content =     {\n        type = String;\n    };\n    createdAt =     {\n        type = Date;\n    };\n    likes =     {\n        targetClass = \n_User\n;\n        type = Relation;\n    };\n    objectId =     {\n        type = String;\n    };\n    skill =     {\n        type = Array;\n    };\n    title =     {\n        type = String;\n    };\n    updatedAt =     {\n        type = Date;\n    };\n};", 
            "title": "开发文档"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_1", 
            "text": "Bmob平台为您的移动应用提供了一个完整的后端解决方案，我们提供轻量级的SDK开发包，让开发者以最小的配置和最简单的方式使用Bmob平台提供的服务，进而完全消除开发者编写服务器代码以及维护服务器的操作。", 
            "title": "简介"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_2", 
            "text": "", 
            "title": "安装"
        }, 
        {
            "location": "/module/developdoc/README/index.html#cocoapodsbmobsdk", 
            "text": "如何使用CocoaPods安装BmobSDK可查看  我们提供的文档", 
            "title": "使用CocoaPods安装BmobSDK"
        }, 
        {
            "location": "/module/developdoc/README/index.html#ios9", 
            "text": "iOS9默认不允许进行http请求，所以在使用SDK的过程中需要往Info.plist添加一些内容，   完全取消http请求限制   key NSAppTransportSecurity /key   dict  key NSAllowsArbitraryLoads /key  true/  /dict    指定部分网址支持http   key NSAppTransportSecurity /key   dict \n    key NSExceptionDomains /key \n       dict      \n             key yourserver.com /key     \n         dict       \n             key NSIncludesSubdomains /key \n                 true/ \n                 key NSTemporaryExceptionAllowsInsecureHTTPLoads /key \n                 true/              \n                 key NSTemporaryExceptionMinimumTLSVersion /key        \n                 string TLSv1.1 /string     \n             /dict    \n         /dict \n  /dict   另外，最新版的sdk已支持bitcode。  其他一些需要注意兼容iOS9的地方可以  参照这里", 
            "title": "兼容iOS9"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_3", 
            "text": "在Bmob平台注册的每个账户都可以创建多个应用程序，每个应用程序都有其独自的应用程序ID，在后续程序编写中，所有的应用程序将凭其ID来使用Bmob SDK。同一个应用可以分别在测试环境和生产环境中部署不同的版本。", 
            "title": "应用程序"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_4", 
            "text": "请大家在使用Bmob开发应用程序之前，认真阅读我们给大家提供的“数据与安全”的文档，确保你的应用在发布时安全。文档  请点击 ;", 
            "title": "应用安全"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_5", 
            "text": "从v2.1.8开始，数据SDK新增了能重新设置请求域名的Api，类似数据迁移，调用方式如下：  [Bmob resetDomain:@ http://demo.bmob.cn/ ];  其中，参数为开发者的域名，调用后的所有请求都指向新的域名。", 
            "title": "数据迁移"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_6", 
            "text": "", 
            "title": "对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_7", 
            "text": "Bmob存储的数据是建立在BmobObject基础上的，每个BmobObject包含键(Key)-值(value)对的JSON兼容数据。这个数据是无模式的，这意味着不需要提前指定每个BmobObject存在什么键。你只需要设置你想要的键值对让我们在后端存储。  例如，假设你要记录一个游戏的得分。一个单一的BmobObject对象可能包含：score: 1337, playerName: \"Sean Plott\", cheatMode: false。键必须是字母、数字的字符串。值可以是字符串、数字、布尔值、Json数组、和BmobObject对象等。  每个BmobObject有一个ClassName，它对应后台的表名。例如，我们可以调用的游戏分数对象的ClassName为GameScore，那么它在后台对应的表名就是GameScore。", 
            "title": "数据对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_8", 
            "text": "为了提供更好的服务，BmobSDK中提供了BmobUser、BmobInstallation两个特殊的BmobObject对象来完成不同的功能，在这里我们统一称为特殊对象。\nBmobUser对象主要是针对应用中的用户功能而提供的，它对应着web端的User表，使用BmobUser对象可以很方便的在应用中实现用户的注册、登录、邮箱验证等功能，具体的使用方法可查看文档的 用户 部分。\nBmobInstallation对象主要用于应用的安装设备管理中，它对应着web端的Installation表，任何安装了你应用的设备都会在此表中产生一条数据标示该设备。结合Bmob提供的推送功能，还可以实现将自定义的消息推送给不同的设备终端，具体的使用方法可查看文档的 消息推送 部分。", 
            "title": "特殊对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_9", 
            "text": "目前为止，我们支持的数据类型有NSString、NSNumber、NSDate、NSArray、NSDictionary以及BmobObject及其子类对象类型。对应后台的类型为String、Number、Date、Array、Object以及Pointer。", 
            "title": "数据类型"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bmobobject", 
            "text": "BmobObject提供以下几种方法对BmobOjbect进行初始化：  /**\n *  创建一个带有className的BmobObject对象\n *\n *  @param  className   表示对象名称(类似数据库表名)\n *\n *  @return BmobObject\n */\n+(instancetype )objectWithClassName:(NSString*)className;\n\n\n/**\n *  创建一个带有className 和objectId的BmobObject对象\n *\n *  @param className 表名\n *  @param objectId  对象的id\n *\n *  @return BmobObject对象\n */\n+(instancetype)objectWithoutDataWithClassName:(NSString*)className objectId:(NSString *)objectId;\n\n/**\n *  从字典创建BmobObject\n *\n *  @param dictionary 字典\n *\n *  @return BmobObject 对象\n */\n-(instancetype)initWithDictionary:(NSDictionary *)dictionary;", 
            "title": "创建BmobObject对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_10", 
            "text": "添加一条数据有两步，第一步是构造数据，第二步是保存数据至服务器上，有以下两种方法：  /**\n *  后台保存BmobObject对象，没有返回结果\n */\n-(void)saveInBackground;\n\n/**\n *  后台保存BmobObject对象，返回保存的结果\n *\n *  @param  block   返回保存的结果是成功还是失败\n */\n-(void)saveInBackgroundWithResultBlock:(BmobBooleanResultBlock)block;  比如，在一个游戏的应用中，当需要保存游戏分数、玩家信息到服务器中的时候，就可以创建GameScore表来添加数据，添加数据的形式类型与iOS中的NSMutableDictionary对象类似，如下：      //在GameScore创建一条数据，如果当前没GameScore表，则会创建GameScore表\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    //score为1200\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@ score ];\n    //设置userName为小明\n    [gameScore setObject:@ 小明  forKey:@ playerName ];\n    //设置cheatMode为NO\n    [gameScore setObject:[NSNumber numberWithBool:NO] forKey:@ cheatMode ];\n    //设置age为18\n    [gameScore setObject:[NSNumber numberWithInt:18] forKey:@ age ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            //创建对象成功，打印对象值\n            NSLog(@ %@ ,gameScore);\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];  运行完以上代码后，数据即可保存到服务器端了。为了确认数据是否真的已经保存成功，你可以在Bmob服务器端你的应用程序的数据浏览项目中查看。你应该看到类似这样的结果：      objectId:  0c6db13c , score: 1200, playerName:  小明 , cheatMode: false, createdAt: 2012-03-29 10:32:54 , updatedAt: 2012-03-29 10:32:54   这里需要注意几点：   在运行以上代码时，如果服务器端你创建的应用程序中已经存在GameScore数据表和相应的score、playerName、cheatMode等字段，那么你此时添加的数据和数据类型也应该和服务器端的表结构一致，否则将保存数据失败。  如果服务器端不存在GameScore数据表，那么Bmob将根据你第一次(也就是运行的以上代码)保存的GameSocre对象在服务器为你创建此数据表并插入相应数据。  每个BmobObject对象有几个默认的键(数据列)是不需要开发者指定的，objectId是每个保存成功数据的唯一标识符。createAt和updateAt代表每个对象(每条数据)在服务器上创建和最后修改的时间。这些键 (数据列)的创建和数据内容是由服务器端来完成的。  在  [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) 中，成功创建后，error返回的是nil，可以通过 error.localizedDescription 查看返回的错误信息，之后的类似于  xxInBackground  中的error也是一样的结构。  objectId，updatedAt，createdAt这些系统属性在调用创建函数（saveInBackground）的时候不需要进行设置，创建成功后，会返回objectId，updatedAt，createdAt。   上述方法中每添加一条数据需要设置一次键值对，如果觉得过于繁琐，可以通过一个NSDictionary来添加数据，利用以下方法即可:      -(void)saveAllWithDictionary:(NSDictionary*)dic;  这个函数。  如:      BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    //设置playerName列的值为小黑和age列的值18\n    NSDictionary *dic = @{@ playerName :@ 小黑 ,@ score :@18};\n    [gameScore saveAllWithDictionary:dic];\n    //异步保存\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后的动作\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];", 
            "title": "添加数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_11", 
            "text": "更新一个对象也是非常简单的，首先获取到要更新的BmobObject对象，进行修改值后再更新数据。例如：  - (void)updateObject{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    [gameScore setObject:[NSNumber numberWithInt:1200] forKey:@ score ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@ 创建成功,以下为对象值 );\n            NSLog(@ %@ ,gameScore);\n\n            //此处是更新操作\n            [gameScore setObject:[NSNumber numberWithInt:110] forKey:@ score ];\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 更新成功，以下为对象值，可以看到score值已经改变 );\n                    NSLog(@ %@ ,gameScore);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];\n}  如果列存储的是符合JSON格式的字符串对象，可以单独修改该对象的某个值，如有一列名为userAttibute，其值是: {\"name\":\"John\", \"gender\":\"男\"}，如果要修改name为Mike，可以使用以下代码  - (void)updateObjectJSONField{\n    //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    NSDictionary *json = @{@ name :@ John , @ gender :@ man };\n    [gameScore setObject:json forKey:@ userAttibute ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@ 创建成功,以下为对象值 );\n            NSLog(@ %@ ,gameScore);\n\n            //此处是更新操作\n            BmobObject *gameScoreChanged = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:gameScore.objectId];\n            [gameScoreChanged setObject:@ Mike  forKey:@ userAttibute.name ];\n            [gameScoreChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 更新成功，以下为对象值，可以看到json里面的name已经改变 );\n                    NSLog(@ %@ ,gameScoreChanged);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];\n}  此处要注意一点，就是在上传  gameScore  之后，如果要再次进行更新，请重新构造对象，因为此时的  gameScore  对象还含有 userAttibute  的值，下面是错误的代码：      //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    NSDictionary *json = @{@ name :@ John , @ gender :@ man };\n    [gameScore setObject:json forKey:@ userAttibute ];\n\n    //异步保存到服务器\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功后会返回objectId，updatedAt，createdAt等信息\n            NSLog(@ 创建成功,以下为对象值 );\n            NSLog(@ %@ ,gameScore);\n\n            //错误的做法，直接使用gameScore来设置，请观察gameScore值上传时的值\n            [gameScore setObject:@ women  forKey:@ userAttibute.gender ];\n            NSLog(@ 上传前的gameScore对象值\\n%@ ,gameScore);\n            [gameScore updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 更新成功，以下为对象值，可以看到json里面的gender已经改变 );\n                    NSLog(@ %@ ,gameScore);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else if (error){\n            //发生错误后的动作\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ Unknow error );\n        }\n    }];\n}  运行后查看log，我们可以看到，除了userAttibute属性外，gameScore对象还有userAttibute.gender属性上传至服务器，这样服务器就无法区分客户端到底是要更新 userAttibuteg还是只更新userAttibute中的gender，从而报错。  2015-12-14 20:45:55.417 BmobSDKDemo[16867:1430005] 创建成功,以下为对象值\n2015-12-14 20:45:55.418 BmobSDKDemo[16867:1430005] \nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n};\n2015-12-14 20:45:55.419 BmobSDKDemo[16867:1430005] 上传前的gameScore对象值\n\nclassName = GameScore;\nobjectId = 0f3d45dbc5;\ncreatedAt = 2015-12-14 12:45:55 +0000;\nupdatedAt = 2015-12-14 12:45:55 +0000;\ndate = {\n    userAttibute =     {\n        gender = man;\n        name = John;\n    };\n     userAttibute.gender  = women;\n};", 
            "title": "更新数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_12", 
            "text": "为了存储一个计数器类型的数据，Bmob提供对任何数字字段进行原子增加(或者减少)的功能，所以我们可以让score像下面一样增加一个固定的值:      //创建一条数据，并上传至服务器\n    BmobObject  *gameScore = [BmobObject objectWithClassName:@ GameScore ];\n    [gameScore setObject:@0 forKey:@ atomicCounter ];\n    [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            BmobObject *gameScoreToBeChanged = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:gameScore.objectId];\n            [gameScoreToBeChanged incrementKey:@ atomicCounter ];\n            [gameScoreToBeChanged updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ 添加成功，可在后台查看objectID为%@的atomicCounter的值是否为1 ,gameScoreToBeChanged.objectId);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];  也提供了  //列的值增加amount\n- (void)incrementKey:(NSString *)key byAmount:(NSInteger )amount\n//列的值减去一\n- (void)decrementKey:(NSString *)key\n//列的值减去amount\n- (void)decrementKey:(NSString *)key byAmount:(NSInteger )amount  注意：需要调用更新函数才能完成计数器原子增加(或者减少)。", 
            "title": "原子计数器"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_13", 
            "text": "从服务器删除对象：      BmobObject *bmobObject = [BmobObject objectWithoutDataWithClassName:@ GameScore   objectId:@ baaf9cfa1b ];\n    [bmobObject deleteInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //删除成功后的动作\n            NSLog(@ successful );\n        } else if (error){\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ UnKnow error );\n        }\n    }];", 
            "title": "删除数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_14", 
            "text": "Bmob提供了批量操作的类BmobObjectsBatch,使用该类，可以批量增加，修改，删除数据，但一次请求不能超过50条数据。下面是例子程序：  BmobObjectsBatch    *batch = [[BmobObjectsBatch alloc] init] ;\n//在GameScore表中创建一条数据\n[batch saveBmobObjectWithClassName:@ GameScore  parameters:@{@ aveScore : @{@ 数学 :@90},@ score :@78}];\n//在GameScore表中更新objectId为27eabbcfec的数据\n[batch updateBmobObjectWithClassName:@ GameScore  objectId:@ 27eabbcfec  parameters:@{@ score : @85}];\n//在GameScore表中删除objectId为30752bb92f的数据\n[batch deleteBmobObjectWithClassName:@ GameScore  objectId:@ 30752bb92f ];\n[batch batchObjectsInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@ batch error %@ ,[error description]);\n}];", 
            "title": "批量数据操作"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_15", 
            "text": "", 
            "title": "查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_16", 
            "text": "在某些情况下，如果知道某条数据的objectId，而且想得知该条数据的内容，可以使用BmobQuery检索得到一个完整的BmobObject：  //查找GameScore表\nBmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表里面id为0c6db13c的数据\n[bquery getObjectInBackgroundWithId:@ 0c6db13c  block:^(BmobObject *object,NSError *error){\n  if (error){\n        //进行错误处理\n  }else{\n      //表里有id为0c6db13c的数据\n      if (object) {\n          //得到playerName和cheatMode\n          NSString *playerName = [object objectForKey:@ playerName ];\n          BOOL cheatMode = [[object objectForKey:@ cheatMode ] boolValue];\n          NSLog(@ %@----%i ,playerName,cheatMode);\n          //打印objectId,createdAt,updatedAt\n          NSLog(@ object.objectId = %@ , [object objectId]);\n          NSLog(@ object.createdAt = %@ , [object createdAt]);\n          NSLog(@ object.updatedAt = %@ , [object updatedAt]);\n      }\n  }\n}];", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_17", 
            "text": "在某些情况下，当需要查询表中多条元素的时候，可以直接使用findObjectsInBackgroundWithBlock函数获取查询结果，默认100条。  BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//查找GameScore表的数据\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@ obj.playerName = %@ , [obj objectForKey:@ playerName ]);\n            //打印objectId,createdAt,updatedAt\n            NSLog(@ obj.objectId = %@ , [obj objectId]);\n            NSLog(@ obj.createdAt = %@ , [obj createdAt]);\n            NSLog(@ obj.updatedAt = %@ , [obj updatedAt]);\n    }\n}];  这里需要注意的是：  1.默认情况下，系统实际上并不会返回所有的数据，而是默认返回10条数据记录，你可以通过setLimit方法设置返回的记录数量。更多细节可 点击查看查询 一节中的分页查询。  2.当查询的是用户表这种系统表的时候，返回的是BmobUser的数组，设备表，角色表也是这样的。  3.查询用户表，设备表、角色表为：  BmobQuery   *bquery = [BmobUser query]; //用户表\nBmobQuery   *bquery = [BmobInstallation query]; //设备表\nBmobQuery   *bquery = [BmobRole query]; //角色表", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_18", 
            "text": "", 
            "title": "条件查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_19", 
            "text": "当然了，在大多数情况下，开发者还是会通过特定的条件来筛选，过滤某些数据来进行查询。BmobQuery也提供了对应的查询方法。  如果要过滤特定键的值可以使用- (void)whereKey:(NSString *)key notEqualTo:(id)object。比如需要查询playerName不等于”小明”的数据时可以这样写：  当然，你也可以在你的查询操作中添加多个约束条件，来查询符合要求的数据。  BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n//添加playerName不是小明的约束条件\n[bquery whereKey:@ playerName  notEqualTo:@ 小明 ];  各种不同条件的比较查询，还有  各种不同的比较查询：\n[bquery whereKey:@ age  lessThan:[NSNumber numberWithInt:18]];//age小于18\n[bquery whereKey:@ age  lessThanOrEqualTo:[NSNumber numberWithInt:18]]; //age小于或等18\n[bquery whereKey:@ age  greaterThan:[NSNumber numberWithInt:18]]; //age大于18\n[bquery whereKey:@ age  greaterThanOrEqualTo:[NSNumber numberWithInt:18]]; //age大于或等于18  这里有点需要注意的是  时间搜索的话，等于的情况因为服务器是精确到微秒值，所以比较的值要加1秒。", 
            "title": "比较查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_20", 
            "text": "如果你想查询匹配几个不同值的数据，如要查询“小明”，“小红”，“小白”三个人的信息是，可以使用  - (void)whereKey:(NSString *)key containedIn:(NSArray *)array;  函数，如下面所示：  [bquery whereKey:@ playerName  containedIn:[NSArray arrayWithObjects:@ 小明 ,@ 小红 ,@ 小白 , nil]];  如果是关联关系，直接在数组里面填写objectId即可，如下   [bquery whereKey:@ author  containedIn:@[@ 063a2d739e ,@ b97ca382c3 ]];  相反，要排除这几个人的信息可以用  - (void)whereKey:(NSString *)key notContainedIn:(NSArray *)array;  函数，如下所示：  [bquery whereKey:@ playerName  notContainedIn:[NSArray arrayWithObjects:@ 小明 ,@ 小红 ,@ 小白 , nil]];", 
            "title": "子查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_21", 
            "text": "其他的约束条件有  //设置查询中该字段是有值的结果\n-(void)whereKeyExists:(NSString *)key;\n//设置查询中该字段是没有值的结果\n-(void)whereKeyDoesNotExist:(NSString *)key;  例如:  //查询表中score列有值的数据\n[bquery whereKeyExists:@ score ];  //查询表中score列没有值的数据\n[bquery whereKeyDoesNotExist:@ score ];", 
            "title": "列值是否存在"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_22", 
            "text": "对字符串值的模糊查询 比如查询包含字符串的值，有几种方法。如下：  //使用正则表达式查询\n-(void)whereKey:(NSString*)key matchesWithRegex:(NSString*)regex;\n//查询以特定字符串开头的值\n-(void)whereKey:(NSString *)key startWithString:(NSString*)start;\n//查询以特定字符串结尾的值\n-(void)whereKey:(NSString *)key endWithString:(NSString*)end;  注:模糊查询只对付费用户开放，付费后可直接使用。", 
            "title": "模糊查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_23", 
            "text": "有时，在数据比较多的情况下，你希望查询出的符合要求的所有数据能按照多少条为一页来显示，这时可以使用limit方法来限制查询结果的数据条数来进行分页。默认情况下，Limit的值为100，最大有效设置值1000（设置的数值超过1000还是视为1000）。  bquery.limit = 3;//限制得到的结果条数为3条  在数据较多的情况下，在limit的基础上分页显示数据是比较合理的解决办法，skip属性可以做到跳过查询的前多少条数据来实现分页查询的功能。默认情况下Skip的值为0。  bquery.skip = 3;//跳过3条数据", 
            "title": "分页查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_24", 
            "text": "对应数据的排序，如数字和字符串，可以使用升序或降序的方式来控制查询数据的结果顺序：  // 升序\n- (void)orderByAscending:(NSString *)key ;\n// 降序\n- (void)orderByDescending:(NSString *)key ;  例如，分数由高到低的排序可以写成  [bquery orderByDescending:@ score ];  当需要组合排序的时候可以这样处理  //先按照年龄升序排序，年龄一样再按照更新时间降序排序\n[bquery orderByAscending:@ age ]\n[bquery orderByDescending:@ updatedAt ]", 
            "title": "排序"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_25", 
            "text": "当简单的查询条件，不能满足查询要时，BmobQuery也提供了2种复合查询的方法。  //并查询\n-(void)addTheConstraintByAndOperationWithArray:(NSArray*)array;\n//或查询\n-(void)addTheConstraintByOrOperationWithArray:(NSArray *)array;  数组里面存的是若干个条件字典，其格式为  @{@ 列名 :条件值}  例如：  //查询score列中值等于5且姓名为Mike的数据\nNSArray *array =  @[@{@ score :@5},@{@ name :@ Mike }];\n[bquery addTheConstraintByAndOperationWithArray:array];  支持的条件符号有     Key  Operation      $lt  小于    $lte  小于等于    $gt  大于    $gte  大于等于    $ne  不等于    $in  在数组中    $nin  不在数组中    $exists  值不为空    $or  合成查询中的或查询    $and  合成查询中的与查询    $regex  匹配PCRE表达式     例如:  //查询score列中值大于150或者小于5的数据\nNSArray *array =  @[@{@ score :@{@ $gt :@150}},@{@ score :@{@ $lt :@5}}];\n[bquery addTheConstraintByOrOperationWithArray:array];  //查询score列中值大于5和小于150的数据\nNSArray *array =  @[@{@ score :@{@ $gt :@5}},@{@ score :@{@ $lt :@150}}];\n[bquery addTheConstraintByAndOperationWithArray:array];  需要注意的是，如果是要查找条件为等于的数据的话，直接构造成{@\"列名\":条件}即可，例如下面的例子:  //查找分数为90分跟分数为150分的数据\nNSArray *array =  @[@{@ score :@90},@{@ score :@150}];\n[bquery addTheConstraintByOrOperationWithArray:array];\n\n//查找名字为张三跟李四的数据\nNSArray *array =  @[@{@ name :@ 张三 },@{@ name : 李四 }];\n[bquery addTheConstraintByOrOperationWithArray:array];  其中日期类型和pointer类型构造的方法比较特殊。\n例如要查询要个时间段的数据，可以构造时间  //createdAt大于或等于 2014-07-15 00:00:00\n NSDictionary *condiction1 = @{@ createdAt :@{@ $gte :@{@ __type : @ Date , @ iso : @ 2014-07-15 00:00:00 }}}; \n//createdAt小于 2014-10-15 00:00:00\nNSDictionary *condiction2 = @{@ createdAt :@{@ $lt :@{@ __type : @ Date , @ iso : @ 2014-10-15 00:00:00 }}};\nNSArray *condictonArray = @[condiction1,condiction2];\n//作用就是查询创建时间在2014年7月15日到2014年10月15日之间的数据\n[bquery addTheConstraintByAndOperationWithArray:condictonArray];  如果查询的条件刚好是pointer类型的话，例如要查询某篇文章的作者是A或者B的话，可以这样构造数据:  BmobQuery *query = [BmobQuery queryWithClassName:@ Post ];\n//列author为pointer类型，指向用户表\n//假设用户A的objectId为aaaa ,其中classname为表名\nNSDictionary *condiction1 = @{@ author :@{@ __type :@ Pointer ,@ className :@ _User ,@ objectId :@ aaaa }};\n//假设用户b的objecId为bbbb\nNSDictionary *condiction2= @{@ author :@{@ __type :@ Pointer ,@ className :@ _User ,@ objectId :@ bbbb }};\nNSArray *condictionArray = @[condiction1,condiction2];\n//查找作者为用户A或者作者为用户B的数据\n[query addTheConstraintByOrOperationWithArray:condictionArray];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n}];  另外我们还封装了以下方法，方便开发者使用，以下是与查询，注意add之前的查询只能添加一个条件，如果是或查询，将 [main andOperation]; 换成 [main orOperation];      BmobQuery   *bquery = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    [bquery whereKey:@ score  equalTo:[NSNumber numberWithDouble:10.3]];\n    BmobQuery   *bquery1 = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    [bquery1 whereKey:@ playerName  equalTo:@ test ];\n\n    BmobQuery   *main = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    [main add:bquery];\n    [main add:bquery1];\n    [main andOperation];\n    [main findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            //打印playerName\n            NSLog(@ %@ ,obj);\n            NSLog(@ obj.playerName = %@ , [obj objectForKey:@ playerName ]);\n        }\n    }];", 
            "title": "复合查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_26", 
            "text": "有的时候，一张表的数据列比较多，而我们只想查询返回某些列的数据时，我们可以使用以下方法来只返回需要的列的值  //设置查询后返回的字段数组  \n-(void)selectKeys:(NSArray*)keys;  //指定返回查询的结果包括score和playerName两列的数据\n[bquery selectKeys:@[@ score ,@ playerName ]];", 
            "title": "返回指定列"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_27", 
            "text": "如果你只是想统计满足查询对象的数量，你并不需要获取所有匹配的对象的具体数据信息，可以直接使用count替代find。例如，查询一个特定玩家玩的游戏场数：  BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery whereKey:@ playerName  equalTo:@ Barbie ];\n[bquery countObjectsInBackgroundWithBlock:^(int number,NSError  *error){\n         NSLog(@ %d ,num);\n}];", 
            "title": "查询结果计数"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_28", 
            "text": "如果你想对表进行统计查询，可以采用以下方法。", 
            "title": "统计查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_29", 
            "text": "统计方法共有以下几种,分别用于计算总和、平均值、最大值、最小值  - (void)sumKeys:(NSArray *)keys\n- (void)averageKeys:(NSArray *)keys\n- (void)maxKeys:(NSArray *)keys\n- (void)minKeys:(NSArray *)keys  设置完成后使用下面的方法来返回结果。  - (void)calcInBackgroundWithBlock:(BmobObjectArrayResultBlock)block  例如，如果我们要计算GameScore表所有玩家的得分总和，可以使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *sumArray = [NSArray arrayWithObject:@ score ];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                NSDictionary *dic = [[NSDictionary alloc] init];\n                dic = [array objectAtIndex:0];\n                NSLog(@ sum of score:%d ,[[dic objectForKey:@ _sumScore ] intValue] );\n            }\n        }\n    }];  计算总和只对Number类型的列有效，列名使用数组存放。返回的字典key值为_sum+首字母大写的列名，其它计算方法与sum类似，其返回的字典key值见下表     关键字  key值  例子      sum  _sum+首字母大写  _sumScore    average  _avg+首字母大写  _avgScore    max  _max+首字母大写  _maxScore    min  _min+首字母大写  _minScore", 
            "title": "统计查询方法"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_30", 
            "text": "分组可用于获取并不复杂的列值，如我想知道playerName列中有多少个不同的玩家名字，可使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore_LT ];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@ playerName ];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@ playerName ];\n                    NSLog(@ player:%@ ,playerName);\n                }\n            }\n        }\n    }];  另外，groupby可以结合计算函数来使用，比如我想统计每个玩家的总分，可以使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@ playerName ];\n    NSArray *sumArray = [NSArray arrayWithObject:@ score ];\n    [bquery groupbyKeys:groupbyArray];\n    [bquery sumKeys:sumArray];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@ playerName ];\n                    NSString *sum = [dic objectForKey:@ _sumScore ];\n                    NSLog(@ player:%@\\tsum:%@ ,playerName,sum);\n                }\n            }\n        }\n    }];", 
            "title": "分组统计"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_31", 
            "text": "有时候，我们还想知道分组统计时每个分组有多少条记录，设置isGroupcount为YES即可,如下：      bquery.isGroupcount = YES;  这样在返回的结果中就会包含类似于以下的键值对：  _count = 10", 
            "title": "分组记录数"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_32", 
            "text": "利用计算方法返回来的值可以通过限制条件来获取我们想关注的结果。添加条件使用以下方法。   -(void)constructHavingDic:(NSDictionary *)havingDic  该方法通过构造havingDic来添加限制条件，其使用方法与复杂查询类似。  例如，我们统计每个玩家的总分，但我们只需要得到总分大于50的玩家，可以使用以下代码得到：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *groupbyArray = [NSArray arrayWithObject:@ playerName ];\n    [bquery groupbyKeys:groupbyArray];\n    NSArray *sumArray = [NSArray arrayWithObject:@ score ];\n    [bquery sumKeys:sumArray];\n    NSDictionary *condication = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:50],@ $gt , nil];\n    [bquery constructHavingDic:[[NSDictionary alloc] initWithObjectsAndKeys:condication,@ _sumScore , nil]];\n    [bquery calcInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ error is:%@ ,error);\n        } else{\n            if (array) {\n                NSLog(@ %@ ,array);\n                for (NSDictionary *dic in array) {\n                    NSString *playerName = [dic objectForKey:@ playerName ];\n                    NSString *sum = [dic objectForKey:@ _sumScore ];\n                    NSLog(@ player:%@\\tsum:%@ ,playerName,sum);\n                }\n            }\n        }\n    }];", 
            "title": "添加过滤条件"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_33", 
            "text": "缓存查询通常是将查询结果缓存在磁盘上，当用户的设备处于离线状态时，就可以从缓存中获取数据来显示。或者在应用界面刚刚启动，从网络获取数据还未得到结果时，先使用缓存数据来显示。这样可以让用户不必在按下某个按钮后进行枯燥的等待。 默认的查询操作是没有启用缓存的，开发者可以通过设置BmobCachePolicy来启用缓存功能。例如：优先从网络获取数据，如果获取失败时再从缓存获取数据，这种情况通常用在网络不可用的情况下。  bquery.cachePolicy = kBmobCachePolicyNetworkElseCache;\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array,NSError *error){\n}];  BmobSDK提供几种不同的缓存策略，以使用不同应用场景的需求。   kBmobCachePolicyIgnoreCache   只从网络获取数据，且数据不会缓存在本地，这是默认的缓存策略。   kBmobCachePolicyCacheOnly   只从缓存读数据，如果缓存没有数据，返回一个空数组。   kBmobCachePolicyNetworkOnly   只从网络获取数据，同时会在本地缓存数据。   kBmobCachePolicyCacheElseNetwork   先从缓存读取数据，如果没有再从网络获取。   kBmobCachePolicyNetworkElseCache   先从网络获取数据，如果没有，再从缓存读取。   kBmobCachePolicyCacheThenNetwork   先从缓存读取数据，无论结果如何都会再次从网络获取数据，在这种情况下，Block将产生两次调用。通常这种做法是先快速从缓存读取数据显示在界面，然后在后台连接网络获取最新数据，取到后再更新界面。  |检查是否存在当前查询条件的缓存数据  [bquery hasCachedResult];  存在返回YES，否则返回NO\n|清除当前查询的缓存数据  [bquery clearCachedResult];  |清除所有查询结果的缓存数据  [BmobQuery clearAllCachedResults];  |设置缓存有限时间，单位为秒  bquery.maxCacheAge = 10000;", 
            "title": "缓存查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bql", 
            "text": "Bmob Query Language （简称 BQL）是 Bmob 自  BmobSDK V1.5.7  版本开始，为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询 API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。  具体的 BQL 语法，请参考  Bmob Query Language 详细指南 。", 
            "title": "BQL查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bql_1", 
            "text": "可以通过以下方法来进行SQL查询：  例如：需要查询所有的游戏得分记录      BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @ select * from GameScore_BQL ;\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result.resultsAry);\n            }\n        }\n    }];  其中result.resultsAry为BmobObject数组。  如果需要查询个数，则可以这样：      NSString *bql = @ select count(*) from GameScore_BQL ;\n    BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    [bmobQuery queryInBackgroundWithBQL:bql block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %d ,result.count);\n            }\n        }\n    }];  其中result.count为记录条数，需要注意的是如果没有使用count关键字进行查询的话，对象result的count属性是没有意义的。", 
            "title": "基本BQL查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bql_2", 
            "text": "由于统计查询的结果是不定的，故BQL提供了另外一种查询方法来进行统计查询，可以使用   - (void)statisticsInBackgroundWithBQL:(NSString *)bql block:(BmobBQLArrayResultBlock)block;  方法来进行。       NSString *bql = @ select sum(score) from GameScore_BQL group by playerName ;\n    [bmobQuery statisticsInBackgroundWithBQL:bql block:^(NSArray *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result);\n            }\n        }\n    }];  目前统计查询支持的关键字如下表所示，即如果在sql语句中包含以下关键字时，则需要使用统计查询方法才能返回正确结果：     key  Operation      group by  分组操作    groupcount  返回每个分组的总记录    having  分组中的过滤条件    sum  计算总和    average  计算平均值    max  计算最大值    min  计算最小值", 
            "title": "统计BQL查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_34", 
            "text": "在更多的时候，一个查询语句中间会有很多的值是可变值，为此，我们也提供了类似 Java JDBC 里的  PreparedStatement  使用占位符查询的语法结构。  注：目前只有where和limit关键字以及内置函数支持使用占位符。", 
            "title": "占位符查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_35", 
            "text": "BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @ select * from GameScore_BQL where playerName = ? and score = ? ;\n    NSArray *placeholderArray = @[@ name2 ,@9];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result.resultsAry);\n            }\n        }\n    }];  数组中的数据会依次替换bql中的问号。", 
            "title": "普通查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_36", 
            "text": "对于包含 内置函数 的占位符查询，比较特殊，请使用 Bmob Query Language 详细指南 中的 内置函数 中 占位符查询用到的内置函数 用到的内置函数列出的形式进行查询操作：  举例：我想查询在 '2015-05-14 14:56:30' 后的创建的记录，可以这样：      BmobQuery *bmobQuery = [[BmobQuery alloc] init];\n    NSString *bql = @ select * from GameScore_BQL where createdAt   date(?) ;\n    NSArray *placeholderArray = @[@ 2015-05-14 14:56:30 ];\n    [bmobQuery queryInBackgroundWithBQL:bql pvalues:placeholderArray block:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            if (result) {\n                NSLog(@ %@ ,result.resultsAry);\n            }\n        }\n    }];  注  1、我们更推荐使用占位符语法，理论上会降低 BQL 转换的性能开销；  2、同样的，统计查询也支持占位符,只需要 - (void)statisticsInBackgroundWithBQL:(NSString *)bql pvalues:(NSArray*)pvalues block:(BmobBQLArrayResultBlock)block; 方法即可。", 
            "title": "内置函数"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bql_3", 
            "text": "如果要使用缓存策略，可用  - (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;  方法，样例代码如下：      NSString *bql = [NSString stringWithFormat:@ select * from %@ where %@ = ? ,TABLENAME,COLPLAYERNAME];\n    NSArray *placeholder = @[@ name1 ];\n\n    BmobQuery *bmobQueryWriteCache = [[BmobQuery alloc] init];\n    bmobQueryWriteCache.cachePolicy = kBmobCachePolicyNetworkOnly;\n    [bmobQueryWriteCache setBQL:bql];\n    [bmobQueryWriteCache setPlaceholder:placeholder];\n    [bmobQueryWriteCache queryBQLCanCacheInBackgroundWithblock:^(BQLQueryResult *result, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (result){\n            NSLog(@ actual:%@ ,result);\n        }\n    }];  注意：   BQL查询方法中，只有  - (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block;  才能使用缓存策略，其它方法即使设置了缓存策略也无缓存效果；  使用 - (void)queryBQLCanCacheInBackgroundWithblock:(BmobBQLObjectResultBlock)block; 进行查询时，通过  -(void)setBQL:(NSString*)bql;  和  -(void)setPlaceholder:(NSArray*)ary;  来设置BQL语句和占位符。   缓存策略只对普通查询有效，统计查询只支持从网络进行查询。具体使用可参考iOS开发文档中的 查询 缓存查询小节。", 
            "title": "BQL缓存策略"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_37", 
            "text": "为了存储数组型数据， Bmob 提供了3种操作来原子性地更改一个数组字段:  Add  在一个数组字段的后面添加一些指定的对象(包装在一个数组内)  AddUnique  只会在原本数组字段中没有这些对象的情形下才会添加入数组，插入数组的位置不固定的  Remove  从一个数组字段的值内移除指定的数组中的所有对象", 
            "title": "数组"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_38", 
            "text": "添加一行记录时创建一个普通的类似于列表的数组类型字段，可以使用以下方法添加：  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[gameScore addObjectsFromArray:@[@ P1 ,@ P2 ] forKey:@ skill ];\n[gameScore updateInBackground];", 
            "title": "添加数组数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_39", 
            "text": "当需要移除数组里的数据时可以使用  -(void)removeObjectsInArray:(NSArray *)objects forKey:(NSString *)key;  如下面就移除了P3这个元素:  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[gameScore removeObjectsInArray:@[@ P3 ] forKey:@ skill ];\n[gameScore updateInBackground];", 
            "title": "删除数组数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_40", 
            "text": "每一种方法都会有一个objects，即包含了这些方法将被添加或删除的对象列表，举个例子，技能skills是一个类似于集合的数组类型，那么我们可以在skills中加入一些对象，只有在skills原来的对象中不包含这些值的情况下才会被加入:  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[gameScore addUniqueObjectsFromArray:@[@ P3 ] forKey:@ skill ];\n[gameScore updateInBackground];", 
            "title": "更新数组数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_41", 
            "text": "对于Key的类型是数组的情况，可以查找Key的数组值中包含有P1的对象。代码如下：      //查询数组中包含某个元素的记录\n    BmobQuery *query = [BmobQuery queryWithClassName:@ GameScore ];\n    [query whereKey:@ skill  equalTo:@ P1 ];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@ %@ ,obj);\n            }\n        }\n    }];  你同样可以使用\"$all\"操作符来找到类型为数组的Key的值中同时包含有P1和P2的对象:      //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@ GameScore\n     ];\n    NSArray *array = @[@ P1 ,@ P2 ];\n    [query1 whereKey:@ skill  equalTo:@{@ $all :array}];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@ %@ ,obj);\n            }\n        }\n    }];  当然，你也可以使用我们封装好的方法来查找      //查询数组中包含某些元素的记录\n    BmobQuery *query1 = [BmobQuery queryWithClassName:@ GameScore ];\n    NSArray *array = @[@ P1 ,@ P2 ];\n    [query1 whereKey:@ skill  containsAll:array];\n    [query1 findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *obj in array) {\n                NSLog(@ %@ ,obj);\n            }\n        }\n    }];  如果要查找包含P1或P2的对象，可以使用复杂查询中的或查      BmobQuery *query = [BmobQuery queryWithClassName:@ Post ];\n    NSArray *array =  @[@{@ skill :@{@ $all : @[@ P1 ]}},@{@ skill :@{@ $all :@[@ P2 ]}}];\n    [query addTheConstraintByOrOperationWithArray:array];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            NSLog(@ %d ,array.count);\n            for (BmobObject *obj in array) {\n                 NSLog(@ %@ ,obj);\n            }\n\n        }\n    }];", 
            "title": "查询数组数据"
        }, 
        {
            "location": "/module/developdoc/README/index.html#key", 
            "text": "比如你当前行有一列叫用户的工作经验projectExperiences，是一个Array数组列，里面包含了多个对象值：[{\"name\":\"项目名称\",\"descr\":\"项目描述\"，\"startTime\":\"开始时间\"，\"endTime\":\"结束时间\"}, ...]  那么我们要修改projectExperiences数组中第一个对象的name值：  BmobObject *gameScore = [BmobObject objectWithoutDataWithClassName:@ GameScore  objectId:@ xxxxxxxx ];\n[bmobObject setObject:@ 项目名称2  forKey:@ projectExperiences.0.name ];\n[gameScore updateInBackground];", 
            "title": "使用索引和对象key修改数组中的对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_42", 
            "text": "数据关联章节Demo下载", 
            "title": "数据关联"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_43", 
            "text": "在程序设计中，不同类型的数据之间可能存在某种关系。分别是以下三种：\n1. 一对一，比如车队给司机分车，1个司机对应1台车；\n2. 一对多，比如1个作者会对应多篇贴子；\n3. 多对多，比如1篇帖子会有多个喜欢的读者，而每个读者也会有多篇喜欢的帖子。\n前面的两种关系我们提供Pointer类型来表示，而最后一种关系我们使用Relation类型来表示  在下面的讲解中我们可能会使用到以下的两张表，其表结构如下：  _User     字段  类型  含义      objectId  string     username  string  用户名，用户可以是作者发帖子，也可以是读者发评论     Post     字段  类型  含义      objectId  string     title  string  帖子标题    content  string  帖子内容    author  Pointer(_User)  作者    likes  Relation(_User)  喜欢帖子的读者     预先在后台添加记录\n_User表   Post表", 
            "title": "关联关系描述"
        }, 
        {
            "location": "/module/developdoc/README/index.html#pointer", 
            "text": "", 
            "title": "Pointer的使用"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_44", 
            "text": "例如，user1写了一篇帖子，需要在Post表中添加一条记录，并且该记录包含一个关联author1记录的字段数据，可采用以下代码：      BmobObject  *post = [BmobObject objectWithClassName:@ Post ];\n    //设置帖子的标题和内容\n    [post setObject:@ title4  forKey:@ title ];\n    [post setObject:@ content4  forKey:@ content ];\n\n    //设置帖子关联的作者记录\n    BmobUser *author = [BmobUser objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ];\n    [post setObject:author forKey:@ author ];\n\n    //异步保存\n    [post saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //创建成功，返回objectId，updatedAt，createdAt等信息\n            //打印objectId\n            NSLog(@ objectid :%@ ,post.objectId);\n        }else{\n            if (error) {\n                NSLog(@ %@ ,error);\n            }\n        }\n    }];  添加成功后在后台的结果如下图所示，我们可以看到，author列的值是用圆框框起来的，表示这是一个Pointer，显示的值，为对应记录的objectId,点击它可以进入_User表中：   我们可以这么理解关联关系，它就是一个类型为指针的字段，利用它可以指向其它表的某条记录。", 
            "title": "添加关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_45", 
            "text": "如果需要删除某篇帖子关联的作者可以使用  - (void)deleteForKey:(id)key  具体代码如下：      BmobQuery   *bquery = [BmobQuery queryWithClassName:@ Post ];\n    [bquery getObjectInBackgroundWithId:@ ZqQ7KKKx  block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@ %@ ,error);\n        }else{\n            if (object) {\n                BmobObject *post = object;\n                //将author列的值置为空\n                [post deleteForKey:@ author ];\n                //进行更新\n                [post updateInBackground];\n            }\n        }\n    }];  结果如下，可以看到，author列已经被置空", 
            "title": "删除关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_46", 
            "text": "如果需要修改某篇帖子关联的作者，可以使用以下代码:      BmobQuery   *bquery = [BmobQuery queryWithClassName:@ Post ];\n    //获得objectId查找出先前添加的文章\n    [bquery getObjectInBackgroundWithId:@ ZqQ7KKKx  block:^(BmobObject *object,NSError *error){\n        if (error){\n            NSLog(@ %@ ,error);\n        }else if (object) {\n            BmobObject *post = object;\n            //获得BmobUser对象\n            BmobUser *user = [BmobUser objectWithoutDataWithClassName:@ _User  objectId:@ qXZeCCCX ];\n            //设置post的author值为新获得的BmobUser对象\n            [post setObject:user forKey:@ author ];\n\n            //进行更新\n            [post updateInBackground];\n        }\n    }];  可以看到关联记录已经被修改：", 
            "title": "修改关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_47", 
            "text": "查询某个特定作者的帖子，可以用  -(void)whereKey:(NSString *)key equalTo:(id)object ,具体代码如下   //查询帖子表\n BmobQuery *query = [BmobQuery queryWithClassName:@ Post ];\n //构建objectId为vbhGAAAY 的作者\n BmobUser *author = [BmobUser objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ];\n //添加作者是objectId为vbhGAAAY条件\n [query whereKey:@ author  equalTo:author];\n [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@ %@ ,[post objectForKey:@ title ]);\n            }\n        }\n    }];  如我们需要查询帖子，并且需要将该帖子关联的作者的信息（objectId,username）打印出来，我们可以使用以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ Post ];\n\n    //声明该次查询需要将author关联对象信息一并查询出来\n    [bquery includeKey:@ author ];\n\n    [bquery getObjectInBackgroundWithId:@ ZqQ7KKKx  block:^(BmobObject *object, NSError *error) {\n\n        //打印文章标题，内容\n        BmobObject *post = object;\n        NSLog(@ title:%@ ,[post objectForKey:@ title ]);\n        NSLog(@ content:%@ ,[post objectForKey:@ content ]);\n\n        //取得文章的关联作者对象\n        BmobUser *author = [post objectForKey:@ author ];\n        //打印文章的关联作者对象的相关信息\n        NSLog(@ objectId:%@ ,author.objectId);\n        NSLog(@ name:%@ ,[author objectForKey:@ username ]);\n    }];  查询关系的核心在于查询前需要将关联的列名include进来，使用下列方法即可  - (void)includeKey:(NSString *)key  如果查询多个关联关系，可以使用以下方法，使用逗号(,)操作来使查询中包含多个属性  [bquery includeKey:@ column1,column2,... ];  如果关联关系存在嵌套，可以使用以下英文字符点号(.)来操作，如下：  [bquery includeKey:@ column1.column2 ];  另外，include 时可以指定返回的字段，如下：  //只返回likes列的数据\n[bquery includeKey:@ post[likes] ];\n\n//返回title和content列数据\n[bquery includeKey:@ post[title|content] ];", 
            "title": "查询关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_48", 
            "text": "我们可以对关联对象的值进行约束，来进行匹配查询。例如，如果我们想找查询出所有关联了user2的文章，可以使用以下代码      BmobQuery *bquery = [BmobQuery queryWithClassName:@ Post ];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@ _User ];\n    [inQuery whereKey:@ username  equalTo:@ user2 ];\n\n    //匹配查询\n    [bquery whereKey:@ author  matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@ %@ ,[post objectForKey:@ title ]);\n            }\n        }\n    }];  如果想要查询找所有没有关联user1的文章，则将  [bquery whereKey:@ author  matchesQuery:inQuery];  替换成  [bquery whereKey:@ author  doesNotMatchQuery:inQuery];  即可。", 
            "title": "约束关联对象值查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#pointer_1", 
            "text": "Pointer可以用来表示一对一或者一对多的关系，其实可以看成是我们将一个指向某条记录的指针记录下来，我们查询时可以通过该指针以获得另外关联的对象。当然，我们也可以给这些指针指向的关联记录进行约束，只查询出符合特定条件的记录。", 
            "title": "Pointer本质"
        }, 
        {
            "location": "/module/developdoc/README/index.html#relation", 
            "text": "", 
            "title": "Relation的使用"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_49", 
            "text": "如果我们需要在Post表中添加一个字段以记录喜欢该贴子的读者，我们可以使用以下代码：      //获取要添加关联关系的post\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ]];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ qXZeCCCX ]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@ likes ];\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ successful );\n        }else{\n            NSLog(@ error %@ ,[error description]);\n        }\n    }];  可以看到添加了一个  likes  列，点击进去可以查看到该列里面存在哪些数据。  Post表：   从Post表中的title4记录点击关联关系框进去后查看的结果：", 
            "title": "添加关联关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_50", 
            "text": "如果要从刚刚的添加的likes列中删去其中一个读者，可采用以下代码。      BmobObject *post = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation removeObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ vbhGAAAY ]];\n\n    //添加关联关系到likes列中\n    [post addRelation:relation forKey:@ likes ];\n\n    //异步更新obj的数据\n    [post updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ successful );\n        }else{\n            NSLog(@ error %@ ,[error description]);\n        }\n    }];  从Author表中的author1记录点击关联关系框进去后查看的结果：", 
            "title": "删除关联关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_51", 
            "text": "如果需要给objectId为ZqQ7KKKx的帖子添加多一个喜欢该帖子的读者可以使用以下代码      BmobObject *author = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n\n    //新建relation对象\n    BmobRelation *relation = [[BmobRelation alloc] init];\n    [relation addObject:[BmobObject objectWithoutDataWithClassName:@ _User  objectId:@ J6RU888L ]];\n    //添加关联关系到postlist列中\n    [author addRelation:relation forKey:@ likes ];\n\n    //异步更新obj的数据\n    [author updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ successful );\n        }else{\n            NSLog(@ error %@ ,[error description]);\n        }\n    }];  运行代码后，从Author表中的author1记录点击关联关系框进去后查看的结果：", 
            "title": "修改关联关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_52", 
            "text": "如果我们需要查询喜欢objectId为ZqQ7KKKx的帖子的所有读者，可以采用下列代码：      //关联对象表\n    BmobQuery *bquery = [BmobQuery queryWithClassName:@ _User ];\n\n    //需要查询的列\n    BmobObject *post = [BmobObject objectWithoutDataWithClassName:@ Post  objectId:@ ZqQ7KKKx ];\n    [bquery whereObjectKey:@ likes  relatedTo:post];\n\n\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobObject *user in array) {\n                NSLog(@ %@ ,[user objectForKey:@ username ]);\n            }\n        }\n    }];  注意：跟Pointer不同的是，这里本质上查询的是_User表。", 
            "title": "查询关联关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#relation_1", 
            "text": "上面的查询是查找喜欢某篇帖子的所有读者，如果反过来，需要查找某个读者喜欢的所有帖子又要怎么做呢？可以参考以下代码：      BmobQuery *bquery = [BmobQuery queryWithClassName:@ Post ];\n\n    //构造约束条件\n    BmobQuery *inQuery = [BmobQuery queryWithClassName:@ _User ];\n    [inQuery whereKey:@ username  equalTo:@ user3 ];\n\n    //匹配查询\n    [bquery whereKey:@ likes  matchesQuery:inQuery];\n    [bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else if (array){\n            for (BmobObject *post in array) {\n                NSLog(@ %@ ,[post objectForKey:@ title ]);\n            }\n        }\n    }];", 
            "title": "Relation约束关联对象值查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#relation_2", 
            "text": "Relation可以理解为其存储的是一个对象，而这个对象中存储的是多个指向其它记录的指针。", 
            "title": "Relation的本质"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_53", 
            "text": "", 
            "title": "用户管理"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_54", 
            "text": "BmobUser除了从BmobObject继承的属性外，还有几个特定的属性：   username: 用户的用户名（必需）。  password: 用户的密码（必需）。  email: 用户的电子邮件地址（可选）。   BmobUser自动处理用户账户管理所需的功能。  -(void)setUsername:(NSString *)username;//用户名，必需\n-(void)setPassword:(NSString*)password;//密码，必需\n-(void)setEmail:(NSString *)email;//设置邮箱\n-(void)setObject:(id)obj forKey:(id)key;//设置某个属性的值\n-(id)objectForKey:(id)key;//得到某个属性的值", 
            "title": "属性"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_55", 
            "text": "应用很常见的一个功能就是，注册用户，使用BmobUser注册用户也不复杂，如下的例子所示  BmobUser *bUser = [[BmobUser alloc] init];\n[bUser setUsername:@ 小明 ];\n[bUser setPassword:@ 123456 ];\n[bUser setObject:@18 forKey:@ age ];\n[bUser signUpInBackgroundWithBlock:^ (BOOL isSuccessful, NSError *error){\n    if (isSuccessful){\n        NSLog(@ Sign up successfully );\n    } else {\n        NSLog(@ %@ ,error);\n    }\n}];  需要有两点需要注意的是：   有些时候你可能需要在用户注册时发送一封邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置- 邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在用户注册时自动发动一封验证给用户。     username字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。", 
            "title": "注册"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_56", 
            "text": "当用户注册成功后，需要让他们以后能够登录到他们的账户使用应用。要做到这点可以使用  [BmobUser loginWithUsernameInBackground:@ 小明 \n    password:@ 123456 ];  也可以使用  + (void)loginWithUsernameInBackground:(NSString *)username\n                              password:(NSString *)password\n                                 block:(BmobUserResultBlock)block;  Bmob还提供了用户、email、手机号码均可作为账号进行登录的功能。使用以下方法即可      [BmobUser loginInbackgroundWithAccount:account andPassword:password block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@ %@ ,user);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "登录"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_57", 
            "text": "每次你登录成功，都会在本地磁盘中有一个缓存的用户对象作为当前用户，可以获取这个缓存的用户对象来进行登录：  BmobUser *bUser = [BmobUser getCurrentObject];\nif (bUser) {\n    //进行操作\n}else{\n    //对象为空时，可打开用户注册界面\n}  当然，你也可以用如下的方法清除缓存用户对象：  [BmobUser logout];  1.这个用户对象缓存了基本的数据，所以可以通过-(id)objectForKey:(id)key; 这个方法来得到某一列的值  2.[BmobUser getCurrentObject] 跟[BmobUser getCurrentUser]功能作用是一样的，因版本升级的原因才保留了[BmobUser getCurrentObject]  3.由于是缓存的数据，所以web端的修改，本地是不会更新的!!!需要重新登录才会更新本地缓存数据  4.缓存用户的有效期为1年", 
            "title": "获取当前用户"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_58", 
            "text": "当用户登录成功后，在本地有个缓存的用户对象，如果开发者希望更改当前用户的某个属性可按如下代码操作:  BmobUser *bUser = [BmobUser getCurrentUser];\n//更新number为30\n[bUser setObject:@30 forKey:@ number ];\n[bUser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    NSLog(@ error %@ ,[error description]);\n}];  一般来说，使用当前用户对象来进行资料更新可能会遇到一个问题。如果当前用户上次登录的时间距离当前时间过长，存放在本地的Token就有可能会过期，导致用户更新资料失败，这是需要重新登录，登录成功后才能更新资料。  在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封邮件验证信息给用户。", 
            "title": "更新用户"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_59", 
            "text": "查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：      BmobQuery *query = [BmobUser query];\n    [query whereKey:@ username  equalTo:@ xiaolv ];\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobUser *user in array) {\n            NSLog(@ objectid %@ ,user.objectId);\n        }\n    }];  浏览器中查看用户表  User表是一个特殊的表，专门存储BmobUser对象。在浏览器端，你会看到一个User表旁边有一个小人的图标。", 
            "title": "查询用户"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_60", 
            "text": "从  v1.6.3  开始，我们提供使用旧密码来重置新密码的接口，示例如下：      BmobUser *user = [BmobUser getCurrentUser];\n    [user updateCurrentUserPasswordWithOldPassword:@ old password  newPassword:@ new password  block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //用新密码登录\n            [BmobUser loginInbackgroundWithAccount:@ name  andPassword:@ new password  block:^(BmobUser *user, NSError *error) {\n                if (error) {\n                    NSLog(@ login error:%@ ,error);\n                } else {\n                    NSLog(@ user:%@ ,user);\n                }\n            }];\n        } else {\n            NSLog(@ change password error:%@ ,error);\n        }\n    }];", 
            "title": "修改密码"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_61", 
            "text": "为方便大家了解如何用Bmob开发找回密码的功能，我们为大家准备了另外一份文档，详细见我们在Github中的文档：  https://github.com/bmob/bmob-cloudcode-demo/blob/master/HOW-TO-FIND-PASSWORD.md", 
            "title": "找回密码"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_62", 
            "text": "", 
            "title": "邮箱"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_63", 
            "text": "设置邮件验证是可选的一个应用设置, 这样可以对已经确认过邮件的用户提供一部分保留的体验，邮件验证功能会在用户(User)对象中加入emailVerified字段, 当一个用户的邮件被新添加或者修改过的话，emailVerified会默认被设为false，如果应用设置中开启了邮箱认证功能，Bmob会对用户填写的邮箱发送一个链接, 这个链接可以把emailVerified设置为 true.  BmobUser *user = [BmobUser getCurrentUser];\n//应用开启了邮箱验证功能\nif ([user objectForKey:@ emailVerified ]) {\n    //用户没验证过邮箱\n    if (![[user objectForKey:@ emailVerified ] boolValue]) {\n        [user verifyEmailInBackgroundWithEmailAddress:@ xxxxxxxxxx ];\n    }\n}", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_64", 
            "text": "一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。  重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可：  [BmobUser requestPasswordResetInBackgroundWithEmail:@ xxxx@qq.com ];  密码重置流程如下：   用户输入他们的电子邮件，请求重置自己的密码。  Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。  用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示，他们可以输入一个新的密码。  用户的密码已被重置为新输入的密码。", 
            "title": "邮箱修改密码"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_65", 
            "text": "Bmob提供了非常简单的方法来实现使用第三方账号登陆的功能，目前支持新浪微博、手机QQ账号以及微信账号的登陆。以下是我们提供的一个demo ThirdPartyLogin", 
            "title": "第三方账号登录"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_66", 
            "text": "在 新浪微博开放平台 注册应用，然后根据 新浪微博 iOS SDK使用说明 安装SDK以及获取，开发者通过新浪微博提供的SDK得到用户的信息后，就可以调用BmobUser提供的方法来注册登录到应用。  //得到的新浪微博授权信息，请按照例子来生成NSDictionary\nNSDictionary *dic = @{@ access_token :token,@ uid :uid,@ expirationDate :date};\n//通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:dic\n                                      platform:BmobSNSPlatformSinaWeibo\n                                         block:^(BmobUser *user, NSError *error) {\n                                             NSLog(@ user objectid is :%@ ,user.objectId);\n                                         }];", 
            "title": "新浪微博账号注册登录"
        }, 
        {
            "location": "/module/developdoc/README/index.html#qq", 
            "text": "同样的，开发者通过QQ授权得到用户的信息后，同样可以调用BmobUser提供的方法来注册登录到应用。下面的例子是通过QQ提供的SDK授权得到的信息，进行登录的：  //得到的qq授权信息，请按照例子来生成NSDictionary\n NSDictionary *responseDictionary = @{@ access_token : _tencentOauth.accessToken,@ uid :_tencentOauth.openId,@ expirationDate :_tencentOauth.expirationDate};\n //通过授权信息注册登录\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformQQ\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@ error%@ ,[error description]);\n                                            }];", 
            "title": "手机QQ账号登录"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_67", 
            "text": "NSDictionary *responseDictionary = @{@ access_token : accessToken,@ uid :openId,@ expirationDate :expirationDate};\n[BmobUser loginInBackgroundWithAuthorDictionary:responseDictionary\n                                       platform:BmobSNSPlatformWeiXin\n                                          block:^(BmobUser *user, NSError *error) {\n                                            NSLog(@ error%@ ,[error description]);\n                                            }];", 
            "title": "微信账号登录"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bmobuser", 
            "text": "如果你的应用中有其他功能已经使用到了相关第三方平台的功能，比如社交分享功能，那么你可以将已经得到的用户授权信息传递给BmobSDK来便捷地与BmobUser进行绑定。以下代码展示了将第三方账号和已经存在的BmobUser对象进行绑定：  //新浪微博账号关联到当前用户\nNSDictionary *dic = @{@ access_token :token,@ uid :uid,@ expirationDate :date};\nBmobUser *currentUser = [BmobUser getCurrentUser];\n[currentUser linkedInBackgroundWithAuthorDictionary:dic\n                                           platform:BmobSNSPlatformSinaWeibo\n                                              block:^(BOOL isSuccessful, NSError *error) {\n                                                     NSLog(@ ERROR :%@ ,[error description]);\n                                                 }];  //手机qq账号关联到当前用户\nNSDictionary *responseDictionary = @{@ access_token : _tencentOauth.accessToken,@ uid :_tencentOauth.openId,@ expirationDate :_tencentOauth.expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformQQ\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@ error%@ ,[error description]);\n                                   }];  //微信账号关联到当前用户\nNSDictionary *responseDictionary = @{@ access_token : accessToken,@ uid :openId,@ expirationDate :expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user linkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@ error%@ ,[error description]);\n                                   }];", 
            "title": "第三方账号与BmobUser绑定"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_68", 
            "text": "解除绑定的账号，也是很简单的。下面是例子：  //当前用户解除关联的微博账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformSinaWeibo\n                                    block:^(BOOL isSuccessful, NSError *error) {\n                                        NSLog(@ error is :%@ ,[error description]);\n                                    }];  //当前用户解除关联的手机QQ账号\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithPlatform:BmobSNSPlatformQQ\n                                     block:^(BOOL isSuccessful, NSError *error) {\n                                         NSLog(@ error is :%@ ,[error description]);\n                                     }];                                                                            //当前用户取消关联微信账号\nNSDictionary *responseDictionary = @{@ access_token : accessToken,@ uid :openId,@ expirationDate :expirationDate};\nBmobUser *user = [BmobUser getCurrentUser];\n[user cancelLinkedInBackgroundWithAuthorDictionary:responseDictionary\n                                platform:BmobSNSPlatformWeiXin\n                                   block:^(BOOL isSuccessful, NSError *error) {\n                                       NSLog(@ error%@ ,[error description]);\n                                   }];", 
            "title": "解除绑定"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_69", 
            "text": "从  v1.5.8  开启Bmob加入了手机注册登录及密码重置等功能。以下介绍的功能可参考我们提供的 BmobSmsDemo （使用前请先在Appdelegate.m中填入你的app id）  注：以下的新功能如果需要填入验证码参数的，请先调用请求验证码方法。", 
            "title": "手机号相关功能"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_70", 
            "text": "可使用以下代码进行一键注册并登录的操作。在使用前必须先请求手机验证码，注册成功后将以当前的手机号码作为用户名，并且会缓存用户信息在本地，可使用  [BmobUser getCurrentUser]  获取。  [BmobUser signOrLoginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@ %@ ,user);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n}];  如果希望在用手机注册时为用户添加密码或者其它信息，可以使用以下代码实现：      BmobUser *buser = [[BmobUser alloc] init];\n    buser.mobilePhoneNumber = @ 15123456789 ;\n    buser.password = @ 123 ;\n    buser.email = @ xxx@gmail.com ;\n    [buser signUpOrLoginInbackgroundWithSMSCode:@ 6位验证码  block:^(BOOL isSuccessful, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            BmobUser *user = [BmobUser getCurrentUser];\n            NSLog(@ %@ ,[BmobUser getCurrentUser]);\n        }\n    }];", 
            "title": "手机号注册"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_71", 
            "text": "Bmob除了提供手机号验证码一键注册登录功能外，还另外提供了希望只给已存在用户用手机号进行登录的功能。代码如下：  \n    [BmobUser loginInbackgroundWithMobilePhoneNumber:mobilePhoneNumber andSMSCode:smsCode block:^(BmobUser *user, NSError *error) {\n        if (user) {\n            NSLog(@ %@ ,user);\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "手机号登录"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_72", 
            "text": "绑定手机号的基本思路为，先获取验证码，验证取得的验证码后再更新  mobilePhoneNumber  和  mobilePhoneNumberVerified  即可，这是我们推荐的做法。当然，你也可以不通过验证码，直接使用用户输入的手机号来更新  mobilePhoneNumber  来进行绑定，不过这种方法并不推荐。      //验证\n    [BmobSMS verifySMSCodeInBackgroundWithPhoneNumber:mobilePhoneNumber andSMSCode:smsCode resultBlock:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            //修改绑定手机\n            BmobUser *buser = [BmobUser getCurrentUser];\n            buser.mobilePhoneNumber = mobilePhoneNumber;\n            [buser setObject:[NSNumber numberWithBool:YES] forKey:@ mobilePhoneNumberVerified ];\n            [buser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n                if (isSuccessful) {\n                    NSLog(@ %@ ,buser);\n                } else {\n                    NSLog(@ %@ ,error);\n                }\n            }];\n\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "绑定手机号"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_73", 
            "text": "通过请求验证码和输入验证码从而进行账号密码重置，代码如下：      [BmobUser resetPasswordInbackgroundWithSMSCode:smsCode andNewPassword:newPassword block:^(BOOL isSuccessful, NSError *error) {\n        if (isSuccessful) {\n            NSLog(@ %@ ,@ 重置密码成功 );\n        } else {\n            NSLog(@ %@ ,error);\n        }\n    }];", 
            "title": "手机号修改密码"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_74", 
            "text": "很多时候BmobObject并不能满足用户的需求，用户可能需要继承BmobOject来定制自己的需求。但是当用户需要保存继承类的属性至后台时，还需要做一些额外的处理。因此，我们推出子类化BmobObject的选项，以让用户的代码具备更好的扩展性。", 
            "title": "子类化"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_75", 
            "text": "先来定义一个BmobObject的子类。  Test.h  \n@interface Test : BmobObject\n@property (copy, nonatomic) NSString *title;\n@property (copy, nonatomic) NSString *name;\n@property (strong, nonatomic) NSNumber *isStudent;\n@property (strong, nonatomic) NSNumber *age;\n@end  Test.m  \n@implementation Test\n\n@synthesize title;\n@synthesize name;\n@synthesize isStudent;\n@synthesize age;\n\n@end  后面你就可以像以下形式那样使用Test类了      Test *test = [[Test alloc] init];\n    test.title = @ title2 ;\n    test.name = @ name2 ;\n    test.isStudent = [NSNumber numberWithBool:NO];\n    test.age = @22;\n    [test sub_saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,error);\n        NSLog(@ objectId %@ ,test.objectId);\n    }];  注意：\n1.当用到添加与更新操作时，要使用类似于sub_XXX的方法，而其它方法保持不变，与BmobObject一致。\n2.子类的方法使用对象类型，不要使用基本类型。例如，要使用整型时，可以声明为NSNumber。", 
            "title": "子类化的使用"
        }, 
        {
            "location": "/module/developdoc/README/index.html#bmobuser_1", 
            "text": "如果要使用继承BmobUser的子类来进行登录，在构造其子类时，应用类似于以下的形式。   TestUser *user = [[TestUser alloc] initFromBmobObject:[BmobUser getCurrentUser]];\n    user.email = @ xxxaa@qq.com ;\n    [user sub_updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ error %@ ,error.description);\n    }];  注意，此方法无法更新本地用户缓存，因此需要慎重考虑是是否子类化BmobUser。", 
            "title": "针对BmobUser的特别说明"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_76", 
            "text": "查询后需要使用以下方法以得到子类的对象。      BmobQuery *testQuery = [Test query];\n    [testQuery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        for (BmobObject *obj in array) {\n            Test *t = [[Test alloc] initFromBmobObject:obj];\n\n        }\n    }];", 
            "title": "查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_77", 
            "text": "文件管理章节Demo", 
            "title": "文件管理"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_78", 
            "text": "BmobFile可以让你的应用程序将文件存储到服务器中，比如常见的文件类型图像文件，影像文件、音乐文件和任何其他二进制数据都可以使用。当文件上传成功后，可以通过url属性来获取文件的地址。", 
            "title": "创建文件对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_79", 
            "text": "1.6.9版本之后，上传服务使用CDN服务", 
            "title": "上传文件"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_80", 
            "text": "如下图的例子，是将cs.txt的文本文件保存到服务器端：  -(void)saveInBackground:(BmobBooleanResultBlock)block;  可以在block里面把文件添加到gameScore里面，建议使用异步上传的方法，再在block进行操作。如下面的例子：  NSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@ GameScore ];\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n     //如果文件保存成功，则把文件添加到filetype列\n     if (isSuccessful) {\n         [obj setObject:file1  forKey:@ filetype ];\n         //此处相当于新建一条记录,      //关联至已有的记录请使用 [obj updateInBackground];\n         [obj saveInBackground];\n         //打印file文件的url地址\n         NSLog(@ file1 url %@ ,file1.url);\n     }else{\n        //进行处理\n     }\n}];", 
            "title": "上传文件方法"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_81", 
            "text": "在上传文件时，有时会需要获取上传文件进度的需求。这时，可以使用  -(void)saveInBackground:(BmobBooleanResultBlock)block withProgressBlock:(BmobProgressBlock)progressBlock;  如在下面的例子中，打印上传的进度  NSBundle    *bundle = [NSBundle mainBundle];\nNSString *fileString = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@ gameScoreFile ];\nBmobFile *file1 = [[BmobFile alloc] initWithClassName:@ Asc  withFilePath:fileString];\n[file1 saveInBackground:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        [obj setObject:file1  forKey:@ userFile ];\n        [obj saveInBackground];\n        NSLog(@ file1 url %@ ,file1.url);\n    }\n} withProgressBlock:^(CGFloat progress) {\n    NSLog(@ 上传进度%.2f ,progress);\n}];", 
            "title": "上传文件进度"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_82", 
            "text": "分片上传文件和上传整个文件的机制有所不同，是先把整个文件进行分片（256KB一片），然后再进行一片一片的上传（具体实现可查看 RestAPI文档 ）。当文件以分片的方式上传到Bmob服务器时，具有几种优势：    适合于尺寸较大的文件传输，通过切片来避免单个HTTP数据量过大而导致连接超时；    在网络条件较差的环境下，较小的尺寸可以有较高的上传成功率，从而避免无休止的失败重试；    在BmobSDK中对应的函数方法为  -(void)saveInBackgroundByDataSharding:(BmobBooleanResultBlock)block;  示例如下：  NSBundle    *bundle = [NSBundle mainBundle];\n//上传cs.txt文件\nNSString *fileString = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\nBmobObject *obj = [[BmobObject alloc] initWithClassName:@ gameScoreFile ];\n//创建BmobFile对象\nBmobFile *file1 = [[BmobFile alloc] initWithFilePath:fileString];\n[file1 saveInBackgroundByDataSharding:^(BOOL isSuccessful, NSError *error) {\n   if (isSuccessful) {\n        //如果成功，保存文件到userFile\n       [obj setObject:file1  forKey:@ userFile ];\n       [obj saveInBackground];\n   }else{\n       //失败，打印错误信息\n        NSLog(@ error: %@ ,[error description]);\n   }\n} ];", 
            "title": "以分片的方式上传文件"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_83", 
            "text": "有时，开发者需要一次性上传多个文件，这是可以使用SDK提供的多个上传文件的方法来使用  NSBundle    *bundle = [NSBundle mainBundle];\n//文件cncc.jpg的路径\nNSString *fileString = [NSString stringWithFormat:@ %@/cncc.jpg  ,[bundle bundlePath] ];\n//文件cs.txt的路径\nNSString *fileString2 = [NSString stringWithFormat:@ %@/cs.txt  ,[bundle bundlePath] ];\n[BmobFile filesUploadBatchWithPaths:@[fileString,fileString2]\n                      progressBlock:^(int index, float progress) {\n                           //index 上传数组的下标，progress当前文件的进度\n                          NSLog(@ index %d progress %f ,index,progress);\n                      } resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n                      //array 文件数组，isSuccessful 成功或者失败,error 错误信息\n                      BmobObject *obj = [[BmobObject alloc] initWithClassName:@ gameScoreFile ];\n                          for (int i = 0 ; i   array.count ;i ++) {\n                              BmobFile *file = array [i];\n                              NSString *key = [NSString stringWithFormat:@ userFile%d ,i];\n                              [obj setObject:file  forKey:key];\n                          }                          \n                          [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) { \n                              }];\n                      }];", 
            "title": "批量上传文件"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_84", 
            "text": "获取文件对象只需通过-(id)objectForKey:(id)key;来得到，例如，  BmobFile *file = (BmobFile*)[gameScore objectForKey:@ filetype ];  可用通过file的url属性(file.url)，来得到文件的地址进行下载。", 
            "title": "下载文件"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_85", 
            "text": "删除文件接口只能删除1.6.9版本之后上传的文件  如果需要删除文件，使用以下接口即可  /**\n *  异步请求删除文件\n *\n *  @param block 返回删除结果与信息，如果删除成功，则无返回信息\n */\n-(void)deleteInBackground:(BmobBooleanResultBlock)block;  当开发者需要一次性删除多个文件的时候，可以调用批量删除文件的接口      NSArray *array = @[@ http://bmob-cdn-1.b0.upaiyun.com/jpg/579c8dc6676e460b82d83c8eb5c8aaa5.jpg ,@ http://bmob-cdn-1.b0.upaiyun.com/jpg/59e3817d6cec416ba99a126c9d42768f.jpg  ]\n\n    [BmobFile filesDeleteBatchWithArray:array resultBlock:^(NSArray *array, BOOL isSuccessful, NSError *error) {\n        NSLog(@ fail delete array %@ ,array);\n        NSLog(@ error %@ ,error.localizedDescription);\n        NSLog(@ issuccessful %i ,isSuccessful);\n    }];", 
            "title": "删除文件"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_86", 
            "text": "只需要在图片上传成功返回的url后面拼接特定参数即可实现缩放，加水印等效果， 如图 ， 具体可参考这里 。", 
            "title": "缩略图"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_87", 
            "text": "Bmob提供了数据实时功能，当开发者监听某个变化事件，例如监听表更新时，表的内容一旦变化，服务器就会通知SDK，SDK提供了相应回调函数来给开发者使用。当然开发者也可以取消相对应的监听，这样就不会收到数据变化的消息了。", 
            "title": "数据实时功能"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_88", 
            "text": "SDK提供了两个方法来监听数据变化，其中一个方法是针对表，另一个则针对行。  -(void)listenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;  这个函数可以监听到表更新（包括该表的行数据的变化）、表删除的行为。例如:  -(void)listen{\n    //创建BmobEvent对象\n    _bmobEvent          = [BmobEvent defaultBmobEvent];\n    //设置代理\n    _bmobEvent.delegate = self;\n    //启动连接\n    [_bmobEvent start];\n}  在代理的函数，进行操作  //可以进行监听或者取消监听事件\n-(void)bmobEventCanStartListen:(BmobEvent *)event{\n    //监听Post表更新\n    [_bmobEvent listenTableChange:BmobActionTypeUpdateTable tableName:@ Post ];\n}\n//接收到得数据\n-(void)bmobEvent:(BmobEvent *)event didReceiveMessage:(NSString *)message{\n    //打印数据\n    NSLog(@ didReceiveMessage:%@ ,message);\n}  相对的，也有监听行更新。行删除的函数：  -(void)listenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;  当然了表删除，行更新，行删除等行为也可以在代理函数-(void)bmobEventCanStartListen:(BmobEvent *)event上进行监听。例如：  -(void)bmobEventCanStartListen:(BmobEvent *)event\n    //监听Test表删除事件，\n    [_bmobEvent listenTableChange:BmobActionTypeDeleteTable tableName:@ Test ];\n    //监听Post表中objectId为a1419df47a 的行更新事件\n    [_bmobEvent listenRowChange:BmobActionTypeUpdateRow tableName:@ Post  objectId:@ a1419df47a ];\n    //监听Post表中objectId为wb1o000F 的行删除事件\n    [_bmobEvent listenRowChange:BmobActionTypeDeleteRow tableName:@ Post  objectId:@ wb1o000F ];\n}  需要注意的是，监听事件后，接收到的数据是json格式的字符串，可以序列化为NSDictionary。", 
            "title": "监听功能"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_89", 
            "text": "当开发者想取消监听某个行为时，可以使用下面的函数  //取消订阅表的变化事件,包括表更新，表删除\n-(void)cancleListenTableChange:(BmobActionType)actionType tableName:(NSString *)tableName;  和  //取消订阅行的变化事件\n-(void)cancleListenRowChange:(BmobActionType)actionType tableName:(NSString *)tableName objectId:(NSString *)objectId;  这里有个 实例 可以参考下。", 
            "title": "取消监听功能"
        }, 
        {
            "location": "/module/developdoc/README/index.html#acl", 
            "text": "大多数应用程序需要对不同的数据进行灵活的访问和控制，这就可以使用Bmob提供的ACL模式来实现。例如：   对于私有数据，读写权限可以只局限于数据的所有者。  对于一个论坛，会员和版主有写的权限，一般的游客只有读的权限。  对于日志数据只有开发者才能够访问，ACL可以拒绝所有的访问权限。  属于一个被授权的用户或者开发者所创建的数据，可以有公共的读的权限，但是写入权限仅限于管理者角色。  一个用户发送给另外一个用户的消息，可以只给这些用户赋予读写的权限。\n用Bmob SDK，你可以对这些数据设置一个默认的ACL，这样，即使黑客反编译了你的应用，获取到Application Key，也仍然无法操作和破坏你的用户数据，确保了用户数据的安全可靠。而作为开发者，当你需要对这些数据进行管理时，可以通过超级权限Key（Master Key）进行。", 
            "title": "ACL和角色"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_90", 
            "text": "在没有显示指定的情况下，每一个BmobObject(表)中的ACL(列)属性的默认值是所有人可读可写的。在客户端想要修改这个权限设置，只需要简单简单调用BmobACL的setPublicReadAccess方法和setPublicWriteAccess方法，即：  BmobACL *acl = [BmobACL ACL];\n//设置所有人读权限为true\n[acl setPublicReadAccess];\n//设置所有人写权限为true\n[acl setPublicWriteAccess];  注意：可读可写是默认的权限，不需要写额外的代码。", 
            "title": "默认访问权限"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_91", 
            "text": "假如你想实现一个分享日志类的应用时，这可能会需要针对不同的日志设定不同的访问权限。比如，公开的日志，发布者有更改和修改的权限，其他用户只有读的权限，那么可用如下代码实现：  BmobObject *blog = [[BmobObject alloc] initWithClassName:@ blog ] ;\n[blog setObject:@ 论电影的七个元素  forKey:@ title ];\n[blog setObject:@ 这是blog的具体内容  forKey:@ content ];\nBmobACL *acl = [BmobACL ACL];\n[acl setPublicReadAccess];//设置所有人可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];  有时，用户想发表一篇不公开的日志，这种情况只有发布者才对这篇日志拥有读写权限，相应的代码如下：  BmobObject *blog = [[BmobObject alloc] initWithClassName:@ blog ] ;\n[blog setObject:@ 一个人的秘密  forKey:@ title ];\n[blog setObject:@ 这是blog的具体内容  forKey:@ content ];\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可读\n[acl setWriteAccessForUser:[BmobUser getCurrentUser]];//设置只有当前用户可写\nblog.ACL= acl;\n[blog saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];", 
            "title": "指定用户的访问权限"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_92", 
            "text": "上面的指定用户访问权限虽然很方便，但是对于有些应用可能会有一定的局限性。比如一家公司的工资系统，员工和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。要实现这种功能，你也可以通过设置每个用户的ACL权限来实现，如下：  //创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@ wageinfo ];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@ wage ];\n//这里创建四个用户对象，分别为老板、人事小张、出纳小谢和自己\nBmobUser *boss        = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *hr_zhang    = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *cashier_xie = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *me          = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n//4个用户对象均可读\n[acl setReadAccessForUser:boss];\n[acl setReadAccessForUser:hr_zhang];\n[acl setReadAccessForUser:cashier_xie];\n[acl setReadAccessForUser:me];\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];\n[acl setWriteAccessForUser:hr_zhang];\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];  但是，一个公司的人事、出纳和员工不仅仅只有一个人，同时还会有离职、调换岗位以及新员工加入等问题存在。如果用上面的代码对公司的每个人进行一一设置的话是不现实的，既麻烦也很难维护。针对这个问题，我们可以利用BmobRole来解决。我们只需要对用户进行分类，每个分类赋予不同的权限。如下代码实现：  //创建公司某用户的工资对象\nBmobObject *wageinfo  = [[BmobObject alloc] initWithClassName:@ wageinfo ];\n[wageinfo setObject:[NSNumber numberWithUnsignedInteger:100000] forKey:@ wage ];\n//这里创建5个用户对象，分别为老板、人事小张、人事小罗、出纳小谢和自己\nBmobUser *boss           = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *hr_zhang       = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *hr_luo         = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];;\nBmobUser *cashier_xie    = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\nBmobUser *me             = [BmobUser objectWithoutDataWithClassName:@ User  objectId:@ xxxxxx ];\n//创建HR和Cashier两个用户角色（这里为了举例BmobRole的使用，将这段代码写在这里，正常情况下放在员工管理界面会更合适）\nBmobRole *hr             = [BmobRole roleWithName:@ HR ];\nBmobRole *cashier        = [BmobRole roleWithName:@ Cashier ];\n//将hr_zhang和hr_luo归属到hr角色中\nBmobRelation *hrRelation = [BmobRelation relation];\n[hrRelation addObject:hr_zhang];\n[hrRelation addObject:hr_luo];\n[hr addUsersRelation:hrRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[hr saveInBackground];\n//将cashier_xie归属到cashier角色中\nBmobRelation *cashierRelation = [BmobRelation relation];\n[cashierRelation addObject:cashier_xie];\n[cashier addUsersRelation:cashierRelation];\n//保存到云端角色表中（web端可以查看Role表）\n[cashier saveInBackground];\n//创建ACL对象\nBmobACL *acl = [BmobACL ACL];\n[acl setReadAccessForUser:boss];// 假设老板只有一个, 设置读权限\n[acl setReadAccessForUser:me];// 给自己设置读权限\n[acl setReadAccessForRole:hr];// 给hr角色设置读权限\n[acl setReadAccessForRole:cashier];// 给cashier角色设置读权限\n//设置boss跟hr_zhang 写的权限\n[acl setWriteAccessForUser:boss];// 设置老板拥有写权限\n[acl setWriteAccessForRole:hr];// 设置ht角色拥有写权限\nwageinfo.ACL= acl;\n[wageinfo saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n    if (isSuccessful) {\n        //进行操作\n    }else{\n        //进行操作\n    }\n}];  需要说明一点的是，Web端的Role表也具有ACL的列，你可以将角色管理的权限赋予某些用户。", 
            "title": "角色管理"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_93", 
            "text": "下面我们来说一下角色与角色之间的从属关系。用一个例子来说明下：一个互联网企业有移动部门，部门中有不同的小组，如Android开发组和IOS开发组。每个小组只拥有自己小组的代码读写权限，但这两个小组同时拥有核心库代码的读权限。  //创建MobileDep（移动研发部）、AndroidTeam（android开发组）和iOSTeam（ios开发组）三个角色\nBmobRole *mobileDep =[BmobRole roleWithName:@ MobileDep ];\nBmobRole *androidTeam = [BmobRole roleWithName:@ AndroidTeam ];\nBmobRole *iosTeam     = [BmobRole roleWithName:@ iOSTeam ];\n//保存AndroidTeam和iosTeam角色到云端\n[androidTeam saveInBackground];\n[iosTeam saveInBackground];\n//将androidTeam和iosTeam两种角色添加到移动部门角色中\nBmobRelation *relation = [BmobRelation relation];\n[relation addObject:androidTeam];\n[relation addObject:iosTeam];\n[mobileDep addRolesRelation:relation];\n// 假设创建三个代码数据对象\nBmobObject *coreCode = [BmobObject objectWithClassName:@ Code ];\nBmobObject *androidCode = [BmobObject objectWithClassName:@ Code ];\nBmobObject *iosCode = [BmobObject objectWithClassName:@ Code ];\n//......此处省略一些具体的属性设定\n[coreCode saveInBackground];\n[androidCode saveInBackground];\n[iosCode saveInBackground];\n//设置androidTeam角色对androidCode对象的读和写的权限\n[androidCode.ACL setReadAccessForRole:androidTeam];\n[androidCode.ACL setWriteAccessForRole:androidTeam];\n//设置iosTeam角色对iosCode对象的读和写的权限\n[iosCode.ACL setReadAccessForRole:iosTeam];\n[iosCode.ACL setWriteAccessForRole:iosTeam];\n//设置mobileDep角色可以对coreCode对象进行读操作\n[coreCode.ACL setReadAccessForRole:mobileDep];", 
            "title": "角色之间的从属关系"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_94", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置息的信查询。你可以在BmobObject的查询中添加一个BmobGeoPoint的对象查询。你就可以实现轻松查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_95", 
            "text": "首先需要创建一个BmobGeoPoint对象。例如，创建一个-东经116.39727786183357度北纬39.913768382429105度的BmobGeoPoint对象：  BmobGeoPoint *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];  添加地理信息  [gameScore setObject:point forKey:@ location ];", 
            "title": "地理位置对象"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_96", 
            "text": "现在，你的数据表中有了一定的地理坐标对象的数据，这样可以测试找出最接近某个点的信息了。你可以使用BmobQuery对象的whereNear方法来这样做：  BmobGeoPoint  *point = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery whereKey:@ location  nearGeoPoint:point];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];  要限制查询指定距离范围的数据可以使用whereWithinKilometers(公里)、whereWithinMiles(英里)或whereWithinRadians(弧度)方法。 要查询一个矩形范围内的信息可以使用whereWithinGeoBox来实现：  BmobGeoPoint *southwestOfSF = [[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:39.913768382429105];\nBmobGeoPoint* northeastOfSF =[[BmobGeoPoint alloc] initWithLongitude:116.39727786183357 WithLatitude:40.913768382429105];\nBmobQuery *bquery = [BmobQuery queryWithClassName:@ GameScore ];\n[bquery whereKey:@ location  withinGeoBoxFromSouthwest:southwestOfSF\n                                           toNortheast:northeastOfSF];\n[bquery setLimit:10];\n[bquery findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n    //进行操作\n}];  注意事项 \n目前有几个需要注意的地方：    每个BmobObject数据对象中 只能 有一个BmobGeoPoint对象。    地理位置的点不能超过规定的范围。 纬度的范围 应该是在 -90.0到90.0 之间。 经度的范围 应该是在 -180.0到180.0 之间。如果您添加的经纬度超出了以上范围，将导致程序错误。    地理位置查询最大的距离根据表数据的不同有不同的限制，使用-(void)whereKey:(NSString  )key nearGeoPoint:(BmobGeoPoint  )geopoint;默认 100KM 。当需要指定距离时，最好指定一下最大距离。", 
            "title": "地理查询"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_97", 
            "text": "", 
            "title": "其它功能"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_98", 
            "text": "获取服务器时间戳可以直接调用[Bmob getServerTimestamp]，例如：      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n        //设置时区\n        [dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@ Asia/Shanghai ]];\n        //时间格式\n        [dateFormatter setDateFormat:@ yyyy-MM-dd hh:mm:ss ];\n        //调用获取服务器时间接口，返回的是时间戳\n        NSString  *timeString = [Bmob getServerTimestamp];\n        //时间戳转化成时间\n        NSDate *date = [NSDate dateWithTimeIntervalSince1970:[timeString intValue]];\n        NSString *dateStr = [dateFormatter stringFromDate:date];\n        NSLog(@ 北京时间:%@ ,dateStr);\n    });", 
            "title": "获取服务器时间"
        }, 
        {
            "location": "/module/developdoc/README/index.html#api", 
            "text": "使用  +(void)setBmobRequestTimeOut:(CGFloat)seconds;  方法可以设置API中网络请求的超时时间，例如，想要设置访问Bmob后台时超过15s就返回超时错误，可以这样写.  [Bmob setBmobRequestTimeOut:15];  BmobSDK默认是20s后得不到回复就提示超时，如果没有特别的需求，建议不要设置该时间。", 
            "title": "设置API网络请求超时时间"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_99", 
            "text": "从  v1.6.1  开始，我们开放获取表结构的接口。", 
            "title": "获取表结构"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_100", 
            "text": "可通过表名来获取特定表的结构，样例代码如下：      [Bmob getTableSchemasWithClassName:@ _User  callBack:^(BmobTableSchema *bmobTableSchema, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            //直接用description来查看表结构\n            NSLog(@ %@ ,bmobTableSchema.description);\n\n            /*\n             分别打印表结构\n            */\n            //打印表名\n            NSLog(@ 表名:%@ ,bmobTableSchema.className);\n            //打印表结构\n            NSDictionary *fields = bmobTableSchema.fields;\n            NSArray *allKey = [fields allKeys];\n            for (NSString *key in allKey) {\n                NSLog(@ 列名:%@ ,key);\n                NSDictionary *fieldStrcut = [fields objectForKey:key];\n                NSLog(@ 列类型:%@ ,[fieldStrcut objectForKey:@ type ] );\n                if ([[fieldStrcut objectForKey:@ type ] isEqualToString:@ Pointer ]) {\n                    NSLog(@ 关联关系指向的表名:%@ ,[fieldStrcut objectForKey:@ targetClass ]);\n                }\n            }\n        }\n    }];", 
            "title": "获取特定表的结构"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_101", 
            "text": "可通过以下代码得到所有表的结构      [Bmob getAllTableSchemasWithCallBack:^(NSArray *tableSchemasArray, NSError *error) {\n        if (error) {\n            NSLog(@ %@ ,error);\n        } else {\n            for (BmobTableSchema* bmobTableSchema in tableSchemasArray) {\n                //直接用description来查看表结构\n                NSLog(@ %@ ,bmobTableSchema.description);\n\n                /*\n                 分别打印表结构\n                 */\n                //打印表名\n                NSLog(@ 表名:%@ ,bmobTableSchema.className);\n                //打印表结构\n                NSDictionary *fields = bmobTableSchema.fields;\n                NSArray *allKey = [fields allKeys];\n                for (NSString *key in allKey) {\n                    NSLog(@ 列名:%@ ,key);\n                    NSDictionary *fieldStrcut = [fields objectForKey:key];\n                    NSLog(@ 列类型:%@ ,[fieldStrcut objectForKey:@ type ] );\n                    if ([[fieldStrcut objectForKey:@ type ] isEqualToString:@ Pointer ]) {\n                        NSLog(@ 关联关系指向的表名:%@ ,[fieldStrcut objectForKey:@ targetClass ]);\n                    }\n                }\n            }\n        }\n    }];", 
            "title": "获取所有表的结构"
        }, 
        {
            "location": "/module/developdoc/README/index.html#_102", 
            "text": "表结构以  BmobTableSchema  对象的形式返回，其中属性  className  表示表名，而属性  fields  是一个字典，里面包含了所有列的类型，其结构如下：  {@ 列名1 :dic,@“列名2”:dic}  而dic的结构为：  {@ type :@ typeName ,@ targetClass :@ tableName }  其中  type  指的是该类的类型， 而  targetClass  指的是指向的表名，只有在  type  为  Pointer  或者  Relation  时才有值。  具体形式如下：  {\n    ACL =     {\n        type = Object;\n    };\n    author =     {\n        targetClass =  _User ;\n        type = Pointer;\n    };\n    content =     {\n        type = String;\n    };\n    createdAt =     {\n        type = Date;\n    };\n    likes =     {\n        targetClass =  _User ;\n        type = Relation;\n    };\n    objectId =     {\n        type = String;\n    };\n    skill =     {\n        type = Array;\n    };\n    title =     {\n        type = String;\n    };\n    updatedAt =     {\n        type = Date;\n    };\n};", 
            "title": "返回数据说明"
        }, 
        {
            "location": "/module/example/README/index.html", 
            "text": "失物招领案例教程\n\n\n需求描述\n\n\n为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布和呈现，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表。\n\n\n说明一点的是，因为是演示案例，所以信息的添加并没有进行用户身份验证。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1、  添加数据\n添加失物/招领信息到服务器中。\n\n\n2、  查找数据\n\n\n在列表中显示所有用户发布的失物/招领信息。\n\n\n本案例最终实现的部分界面效果如下：\n\n\n \n\n\n失物招领软件闪图\n\n\n \n\n\n招领列表页\n\n\n \n\n\n添加失物信息\n\n\n数据结构设计\n\n\n本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步\n快速入门指南\n查看相关教程）：\n\n\n\n    \n\n        \n失物表（Lost）\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \ndescribe\nString\n失物的描述信息\n\n    \n\n    \n\n        \nphone\nString\n联系的手机号码\n\n    \n\n    \n\n        \ntitle\nString\n失物的标题信息\n\n    \n\n\n\n\n\n\n\n\n    \n\n        \n招领表（Found）\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \ndescribe\nString\n招领的描述信息\n\n    \n\n    \n\n        \nphone\nString\n联系的手机号码\n\n    \n\n    \n\n        \ntitle\nString\n招领的标题信息\n\n    \n\n\n\n\n\n初始化SDK\n\n\nBmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥-\nApplication ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看main.m文件）：\n\n\nint main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n        //registerWithAppKey需要使用Application ID进行初始化\n        [Bmob registerWithAppKey:@\ne9bbe5f23a1aa1d60d525871e1d7db99\n];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n\n\n\n添加失物及招领信息\n\n\n用户填写了失物信息之后，只需要构造一个BmobObject实例，然后简单调用setObject方法就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddViewController.m文件）：\n\n\n        //创建BmobObject对象，指定对应要操作的数据表名称\n        BmobObject *obj = [[BmobObject alloc] initWithClassName:className];\n        //设置字段值\n        [obj setObject:titleTextField.text forKey:@\ntitle\n];\n        [obj setObject:phoneTextField.text forKey:@\nphone\n];\n        [obj setObject:desTextField.text forKey:@\ndescribe\n];\n        //执行保存操作\n        [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n\n            if (!error) {\n                //其他代码\n            }\n\n        }];\n\n\n\n\n获取失物及招领列表\n\n\nBmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和orderByDescending方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：\n\n\n    //创建BmobQuery实例，指定对应要操作的数据表名称\n    BmobQuery *query = [BmobQuery queryWithClassName:className];\n    //按updatedAt进行降序排列\n    [query orderByDescending:@\nupdatedAt\n];\n    //返回最多20个结果\n    query.limit = 20;\n    //执行查询\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            News *info    = [[News alloc] init];\n            if ([obj objectForKey:@\ntitle\n]) {\n                info.title    = [obj objectForKey:@\ntitle\n];\n            }\n            if ([obj objectForKey:@\ndescribe\n]) {\n                info.content  = [obj objectForKey:@\ndescribe\n];\n            }\n            if ([obj objectForKey:@\nphone\n]) {\n                info.phoneNum = [obj objectForKey:@\nphone\n];\n            }\n            info.time     = [_dateFormatter stringFromDate:obj.updatedAt];\n            [_infoMutableArray addObject:info];\n        }\n\n        [_tableView reloadData];\n    }];\n\n\n\n\n后记\n\n\n本案例只是演示如何用Bmob进行快速的数据添加和查询，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的\n开发文档\n或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n案例下载\n\n\n失物招领案例下载\n\n\n推送案例教程\n\n\n推送案例需求描述\n\n\n用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。\n\n\n本案例将使用到Bmob的如下功能：\n\n\n1、  推送服务\n\n\n将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。\n\n\n2、  数据存储服务\n\n\n添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。\n\n\n本案例最终实现的界面效果如下：\n\n\n \n\n\n发送反馈截图\n\n\n \n\n\n查看反馈意见截图\n\n\n推送案例数据结构设计\n\n\n在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步快速入门指南查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）\n\n\n\n    \n\n        \nFeedback表\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \nContact\nString\n用户的联系方式\n\n    \n\n    \n\n        \ndeviceType\nString\n系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化\n\n    \n\n    \n\n        \ncontent\nString\n反馈内容\n\n    \n\n\n\n\n\n\n    \n\n        \nInstallation表\n\n    \n\n    \n\n        \n字段名\n类型\n描述\n\n    \n\n    \n\n        \ninstallationId\nString\n系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的\n\n    \n\n    \n\n        \ndeviceToken\nString\n系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的\n\n    \n\n    \n\n        \nbadge\nNumber\n系统字段，表示iOS 设备最新已知的应用badge\n\n    \n\n    \n\n        \ntimeZone\nString\n系统字段，表示安装的这个设备的系统时区\n\n    \n\n    \n\n        \nchannels\nArray\n系统字段，表示这个安装对象的订阅频道列表\n\n    \n\n    \n\n        \nappIdentifiter\nString\niOS应用的Bundle identifier\n\n    \n\n    \n\n        \nisDeveloper\nBoolean\n是否是开发者（是的话则用于接收推送信息）\n\n    \n\n\n\n\n\n推送案例安装和初始化\n\n\n还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。\n\n\n推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在main.m调用registerWithAppKey方法即可：\n\n\nint main(int argc, char * argv[])\n{\n\n    //可更换为您的应用的key\n    [Bmob registerWithAppKey:@\n3124f50157a5df138aba77a85e1d8909\n];\n\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n\n\n\n发送反馈功能的开发\n\n\n这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。\n\n\n为实现将数据保存到云数据库的功能，你需要先创建BmobObject对象，该对象通过initWithClassName方法与云端数据库的Feedback表对应起来，然后通过setObject方法设置数据对象。实现代码如下：\n\n\nBmobObject *feedbackObj = [[BmobObject alloc] initWithClassName:@\nFeedback\n];\n\n//联系方式\n[feedbackObj setObject:contactTextfield.text forKey:@\ncontact\n];\n\n//反馈内容\n    [feedbackObj setObject:ncTextView.text forKey:@\ncontent\n];\n\n\n\n\n接着，你就可以直接调用BmobObject对象的saveInBackgroundWithResultBlock方法，将数据插入到云数据库中了。实现代码如下：\n\n\n//保存反馈信息到Bmob云数据库中\n[feedbackObj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\nif (isSuccessful) {\n        NSLog(@”保存成功”);\n    }else{\nNSLog(@”保存失败”);\n}\n}];\n\n\n\n\n保存成功之后，你可以推送一条信息到BmobInstallation安装表中isDeveloper字段值为true的设备中。实现代码如下：\n\n\n/**\n * 推送反馈信息给isDeveloper的设备\n * @param message 反馈信息\n */\n\n-(void)sendPush:(NSString*) message {\n    //发送推送\n    BmobPush *push = [BmobPush push];\n    BmobQuery *query = [BmobInstallation query];\n    //条件为isDeveloper是true\n    [query whereKey:@\nisDeveloper\n equalTo:[NSNumber numberWithBool:YES] ];\n    [push setQuery:query];\n    //推送内容为反馈的内容\n    [push setMessage: message];\n    [push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@\npush error =====\n%@\n,[error description]);\n    }];\n}\n\n\n\n\n查看反馈功能的开发\n\n\n为了接收用户端推送过来的反馈信息，需要在AppDelegate类中注册通知功能（application类registerForRemoteNotificationTypes方法）、设置推送消息到达之后的处理方法（BmobPush类handlePush方法），当然了，还需要将接收推送信息的当前机器信息添加到云端数据库中的设备安装表中（BmobInstallation）。实现代码如下：\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    //注册通知功能\n[application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert|\nUIRemoteNotificationTypeBadge|\nUIRemoteNotificationTypeSound];\n    ……\n    return YES;\n}\n\n//接收推送信息的处理服务\n-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{\n    NSLog(@\nuserInfo %@\n,[userInfo description]);\n    [BmobPush handlePush:userInfo];\n}\n\n//往云端数据库中的设备表注册信息\n-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n    BmobInstallation    *installation = [BmobInstallation currentInstallation];\n    [installation setDeviceTokenFromData:deviceToken];\n    //设置isDeveloper为true\n    [installation setObject:[NSNumber numberWithBool:YES] forKey:@\nisDeveloper\n];\n    [installation saveInBackground];\n}\n\n\n\n\n查看反馈列表的功能实现很简单，只需要调用BmobQuery的findObjectsInBackgroundWithBlock方法就可以了，实现代码如下：\n\n\n//创建BmobQuery查询对象，对应查询云端数据库中的Feedback表\nBmobQuery *query = [BmobQuery queryWithClassName:@\nFeedback\n];\n//按updatedAt降序排列\n[query orderByDescending:@\nupdatedAt\n];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n            [dic setObject:[obj objectForKey:@\ncontent\n] forKey:@\ncontent\n];\n            [dic setObject:[obj objectForKey:@\ncontact\n] forKey:@\ncontact\n];\n            [dic setObject:obj.createdAt forKey:@\ntime\n];\n            [_feedbacksArray addObject:dic];\n            [_feedbackTableView reloadData];\n        }\n }];\n\n\n\n\n推送案例后记\n\n\n当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～\n\n\n推送案例下载\n\n\n反馈案例下载\n\n\n其他案例\n\n\n快速入门相关源码:\nhttps://github.com/bmob/bmob-ios-demo\n\n\n数据关联章节Demo下载:\nhttps://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobRelationDemo\n\n\n第三方登录Demo:\nhttps://github.com/bmob/bmob-ios-demo\n\n\n文件管理Demo:\nhttps://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobFileDemo\n\n\n数据实时更新Demo:\nhttps://github.com/bmob/bmob-ios-demo/blob/master/BmobDataDemo_iOS.zip\n\n\nBmobIMSDK源代码：\nhttps://github.com/bmob/bmob-iOS-im-sdk\n\n\nSwift使用BmobSDK案例源码:\nhttps://github.com/bmob/bmob-app-demo-show/blob/master/download/BmobSwift.zip\n\n\n踢球吧源码\nhttps://github.com/bmob/BmobTiQiuBa\n\n\nmexiQQ开发者实现的iOS实践案例\nhttps://github.com/bmob/VReader-iOS\n\n\niOS云端逻辑案例:\nhttps://github.com/bmob/bmob-ios-demo/blob/master/CloudFunction.zip\n\n\niOS BmobSDK API使用案例:\nhttps://github.com/bmob/bmob-ios-demo/blob/master/BmobStorageDemo.zip", 
            "title": "示例和功能"
        }, 
        {
            "location": "/module/example/README/index.html#_1", 
            "text": "", 
            "title": "失物招领案例教程"
        }, 
        {
            "location": "/module/example/README/index.html#_2", 
            "text": "为演示Bmob提供的云数据库的功能，本文制作了一个失物招领的简单案例，实现物品的发布和呈现，展示如何使用Bmob快速开发一个有后端数据库的应用软件。使用场景如下：用户捡到物品，打开手机软件，填写物品的招领信息（标题、描述和联系方式）；用户丢失物品，打开手机软件，填写物品的丢失信息（标题、描述和联系方式）；任何人都可以查看到失物和招领的信息列表。  说明一点的是，因为是演示案例，所以信息的添加并没有进行用户身份验证。  本案例将使用到Bmob的如下功能：  1、  添加数据\n添加失物/招领信息到服务器中。  2、  查找数据  在列表中显示所有用户发布的失物/招领信息。  本案例最终实现的部分界面效果如下：     失物招领软件闪图     招领列表页     添加失物信息", 
            "title": "需求描述"
        }, 
        {
            "location": "/module/example/README/index.html#_3", 
            "text": "本案例的数据结构非常简单，只需要设计两个表，一个是失物表（Lost表），一个是招领表（Found表），对应的数据结构如下（省略对常用默认字段objectId、createAt、updateAt的描述，对于还不知道怎么创建应用和添加数据表的开发朋友请先移步 快速入门指南 查看相关教程）：  \n     \n         失物表（Lost） \n     \n     \n         字段名 类型 描述 \n     \n     \n         describe String 失物的描述信息 \n     \n     \n         phone String 联系的手机号码 \n     \n     \n         title String 失物的标题信息 \n        \n     \n         招领表（Found） \n     \n     \n         字段名 类型 描述 \n     \n     \n         describe String 招领的描述信息 \n     \n     \n         phone String 联系的手机号码 \n     \n     \n         title String 招领的标题信息", 
            "title": "数据结构设计"
        }, 
        {
            "location": "/module/example/README/index.html#sdk", 
            "text": "Bmob为每个应用都提供了一个唯一标识（对应为开发者后台应用中的“应用密钥- Application ID”），使用Bmob开发的应用都要首先使用这个Application ID”进行初始化。对应代码如下（详细代码实现参看main.m文件）：  int main(int argc, char * argv[])\n{\n\n    @autoreleasepool {\n        //registerWithAppKey需要使用Application ID进行初始化\n        [Bmob registerWithAppKey:@ e9bbe5f23a1aa1d60d525871e1d7db99 ];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}", 
            "title": "初始化SDK"
        }, 
        {
            "location": "/module/example/README/index.html#_4", 
            "text": "用户填写了失物信息之后，只需要构造一个BmobObject实例，然后简单调用setObject方法就可以将信息添加到云数据库中，实现代码如下（详细代码实现参看AddViewController.m文件）：          //创建BmobObject对象，指定对应要操作的数据表名称\n        BmobObject *obj = [[BmobObject alloc] initWithClassName:className];\n        //设置字段值\n        [obj setObject:titleTextField.text forKey:@ title ];\n        [obj setObject:phoneTextField.text forKey:@ phone ];\n        [obj setObject:desTextField.text forKey:@ describe ];\n        //执行保存操作\n        [obj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\n\n            if (!error) {\n                //其他代码\n            }\n\n        }];", 
            "title": "添加失物及招领信息"
        }, 
        {
            "location": "/module/example/README/index.html#_5", 
            "text": "Bmob提供了复杂和简单的查询方法，可以对查询结果进行排序，可以对结果进行缓存。本案例只使用到Bmob提供的最简单的查询和排序功能，直接调用BmobQuery类的findObjects方法和orderByDescending方法来获取失物列表，实现代码如下（详细代码实现参看MainActivity类）：      //创建BmobQuery实例，指定对应要操作的数据表名称\n    BmobQuery *query = [BmobQuery queryWithClassName:className];\n    //按updatedAt进行降序排列\n    [query orderByDescending:@ updatedAt ];\n    //返回最多20个结果\n    query.limit = 20;\n    //执行查询\n    [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            News *info    = [[News alloc] init];\n            if ([obj objectForKey:@ title ]) {\n                info.title    = [obj objectForKey:@ title ];\n            }\n            if ([obj objectForKey:@ describe ]) {\n                info.content  = [obj objectForKey:@ describe ];\n            }\n            if ([obj objectForKey:@ phone ]) {\n                info.phoneNum = [obj objectForKey:@ phone ];\n            }\n            info.time     = [_dateFormatter stringFromDate:obj.updatedAt];\n            [_infoMutableArray addObject:info];\n        }\n\n        [_tableView reloadData];\n    }];", 
            "title": "获取失物及招领列表"
        }, 
        {
            "location": "/module/example/README/index.html#_6", 
            "text": "本案例只是演示如何用Bmob进行快速的数据添加和查询，在真实的应用环境下，你还可能还需要使用到用户系统、文件服务、更复杂的数据结构和服务，这些都可以使用Bmob就可以实现。如果想要获取更多的信息，请各位查看Bmob的 开发文档 或者联系技术客服。欢迎砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "后记"
        }, 
        {
            "location": "/module/example/README/index.html#_7", 
            "text": "失物招领案例下载", 
            "title": "案例下载"
        }, 
        {
            "location": "/module/example/README/index.html#_8", 
            "text": "", 
            "title": "推送案例教程"
        }, 
        {
            "location": "/module/example/README/index.html#_9", 
            "text": "用户反馈是移动开发中最常见的功能，可以用来收集我们的用户对软件的意见和建议。通常在开发用户反馈功能时，我们都会将用户反馈的信息保存到服务器中，定期登录后台管理系统查看，这样很难做到实时查看用户反馈信息。本文结合Bmob推送服务和数据存储服务开发用户反馈功能，实现用户提交反馈信息保存在Bmob云数据库的同时，也将用户的反馈信息推送到运营/研发人员的设备中。  本案例将使用到Bmob的如下功能：  1、  推送服务  将用户的反馈信息实时推送到订阅了接收反馈信息的设备中，实现端到端的消息传递。  2、  数据存储服务  添加和查看反馈信息，使用到了添加、查询和按时间排序的功能。  本案例最终实现的界面效果如下：     发送反馈截图     查看反馈意见截图", 
            "title": "推送案例需求描述"
        }, 
        {
            "location": "/module/example/README/index.html#_10", 
            "text": "在Bmob开发者后台创建一个应用（还不知道怎么创建应用和添加数据表的开发朋友请先移步快速入门指南查看相关教程），添加两个表，分别是Feedback（用户反馈信息表，存储用户提交的反馈信息）和Installation（设备安装表，存储需要接收推送信息的设备信息）。以下是对这两个表的数据结构的详细描述（省略对常用默认字段objectId、createAt、updateAt的描述）  \n     \n         Feedback表 \n     \n     \n         字段名 类型 描述 \n     \n     \n         Contact String 用户的联系方式 \n     \n     \n         deviceType String 系统字段，是一个必须的字段, 必须被设置为 \"ios\" 或者 \"android\", 而且自这个对象生成以后就不能变化 \n     \n     \n         content String 反馈内容 \n       \n     \n         Installation表 \n     \n     \n         字段名 类型 描述 \n     \n     \n         installationId String 系统字段，是一个Bmob生成的字符串标志, 而且如果 deviceType 是 android 的话是一个必填字段, 如果是 ios 的话则可选. 它只要对象被生成了就不能发生改变, 而且对一个 app 来说是不可重复的 \n     \n     \n         deviceToken String 系统字段，是一个 Apple 生成的字符串标志, 在 deviceType 为 ios 上的设备是必须的, 而且自对象生成开始就不能改动, 对于一个 app 来说也是不可重复的 \n     \n     \n         badge Number 系统字段，表示iOS 设备最新已知的应用badge \n     \n     \n         timeZone String 系统字段，表示安装的这个设备的系统时区 \n     \n     \n         channels Array 系统字段，表示这个安装对象的订阅频道列表 \n     \n     \n         appIdentifiter String iOS应用的Bundle identifier \n     \n     \n         isDeveloper Boolean 是否是开发者（是的话则用于接收推送信息）", 
            "title": "推送案例数据结构设计"
        }, 
        {
            "location": "/module/example/README/index.html#_11", 
            "text": "还不知道怎么安装使用Bmob数据存储Sdk的开发朋友请先移步快速入门指南查看相关教程。  推送服务的SDK初始化和Bmob数据存储SDK一样，只需要在main.m调用registerWithAppKey方法即可：  int main(int argc, char * argv[])\n{\n\n    //可更换为您的应用的key\n    [Bmob registerWithAppKey:@ 3124f50157a5df138aba77a85e1d8909 ];\n\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}", 
            "title": "推送案例安装和初始化"
        }, 
        {
            "location": "/module/example/README/index.html#_12", 
            "text": "这里要实现的是当用户点击“发送”反馈按钮之后，先把用户的反馈信息上传到Bmob云数据库中，然后发送一条推送信息到Installation表中isDeveloper为true的设备中去。  为实现将数据保存到云数据库的功能，你需要先创建BmobObject对象，该对象通过initWithClassName方法与云端数据库的Feedback表对应起来，然后通过setObject方法设置数据对象。实现代码如下：  BmobObject *feedbackObj = [[BmobObject alloc] initWithClassName:@ Feedback ];\n\n//联系方式\n[feedbackObj setObject:contactTextfield.text forKey:@ contact ];\n\n//反馈内容\n    [feedbackObj setObject:ncTextView.text forKey:@ content ];  接着，你就可以直接调用BmobObject对象的saveInBackgroundWithResultBlock方法，将数据插入到云数据库中了。实现代码如下：  //保存反馈信息到Bmob云数据库中\n[feedbackObj saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) {\nif (isSuccessful) {\n        NSLog(@”保存成功”);\n    }else{\nNSLog(@”保存失败”);\n}\n}];  保存成功之后，你可以推送一条信息到BmobInstallation安装表中isDeveloper字段值为true的设备中。实现代码如下：  /**\n * 推送反馈信息给isDeveloper的设备\n * @param message 反馈信息\n */\n\n-(void)sendPush:(NSString*) message {\n    //发送推送\n    BmobPush *push = [BmobPush push];\n    BmobQuery *query = [BmobInstallation query];\n    //条件为isDeveloper是true\n    [query whereKey:@ isDeveloper  equalTo:[NSNumber numberWithBool:YES] ];\n    [push setQuery:query];\n    //推送内容为反馈的内容\n    [push setMessage: message];\n    [push sendPushInBackgroundWithBlock:^(BOOL isSuccessful, NSError *error) {\n        NSLog(@ push error ===== %@ ,[error description]);\n    }];\n}", 
            "title": "发送反馈功能的开发"
        }, 
        {
            "location": "/module/example/README/index.html#_13", 
            "text": "为了接收用户端推送过来的反馈信息，需要在AppDelegate类中注册通知功能（application类registerForRemoteNotificationTypes方法）、设置推送消息到达之后的处理方法（BmobPush类handlePush方法），当然了，还需要将接收推送信息的当前机器信息添加到云端数据库中的设备安装表中（BmobInstallation）。实现代码如下：  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    //注册通知功能\n[application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert|\nUIRemoteNotificationTypeBadge|\nUIRemoteNotificationTypeSound];\n    ……\n    return YES;\n}\n\n//接收推送信息的处理服务\n-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{\n    NSLog(@ userInfo %@ ,[userInfo description]);\n    [BmobPush handlePush:userInfo];\n}\n\n//往云端数据库中的设备表注册信息\n-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{\n    BmobInstallation    *installation = [BmobInstallation currentInstallation];\n    [installation setDeviceTokenFromData:deviceToken];\n    //设置isDeveloper为true\n    [installation setObject:[NSNumber numberWithBool:YES] forKey:@ isDeveloper ];\n    [installation saveInBackground];\n}  查看反馈列表的功能实现很简单，只需要调用BmobQuery的findObjectsInBackgroundWithBlock方法就可以了，实现代码如下：  //创建BmobQuery查询对象，对应查询云端数据库中的Feedback表\nBmobQuery *query = [BmobQuery queryWithClassName:@ Feedback ];\n//按updatedAt降序排列\n[query orderByDescending:@ updatedAt ];\n[query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) {\n        //处理查询结果\n        for (BmobObject *obj in array) {\n            NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n            [dic setObject:[obj objectForKey:@ content ] forKey:@ content ];\n            [dic setObject:[obj objectForKey:@ contact ] forKey:@ contact ];\n            [dic setObject:obj.createdAt forKey:@ time ];\n            [_feedbacksArray addObject:dic];\n            [_feedbackTableView reloadData];\n        }\n }];", 
            "title": "查看反馈功能的开发"
        }, 
        {
            "location": "/module/example/README/index.html#_14", 
            "text": "当然了，实际使用过程的反馈功能可能并没有那么简单，或许你需要实现能够直接跟用户对话的反馈功能，或许你想要实现智能化的机器回答，这些都可以使用Bmob移动云服务平台进行快速设计和开发的。欢迎各位砸砖，欢迎提出更多的意见和建议帮助Bmob更好的发展。谢谢～", 
            "title": "推送案例后记"
        }, 
        {
            "location": "/module/example/README/index.html#_15", 
            "text": "反馈案例下载", 
            "title": "推送案例下载"
        }, 
        {
            "location": "/module/example/README/index.html#_16", 
            "text": "快速入门相关源码: https://github.com/bmob/bmob-ios-demo  数据关联章节Demo下载: https://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobRelationDemo  第三方登录Demo: https://github.com/bmob/bmob-ios-demo  文件管理Demo: https://github.com/bmob/bmob-ios-demo/tree/master/BmobSDK/BmobFileDemo  数据实时更新Demo: https://github.com/bmob/bmob-ios-demo/blob/master/BmobDataDemo_iOS.zip  BmobIMSDK源代码： https://github.com/bmob/bmob-iOS-im-sdk  Swift使用BmobSDK案例源码: https://github.com/bmob/bmob-app-demo-show/blob/master/download/BmobSwift.zip  踢球吧源码 https://github.com/bmob/BmobTiQiuBa  mexiQQ开发者实现的iOS实践案例 https://github.com/bmob/VReader-iOS  iOS云端逻辑案例: https://github.com/bmob/bmob-ios-demo/blob/master/CloudFunction.zip  iOS BmobSDK API使用案例: https://github.com/bmob/bmob-ios-demo/blob/master/BmobStorageDemo.zip", 
            "title": "其他案例"
        }, 
        {
            "location": "/module/update_log/README/index.html", 
            "text": "v2.1.5 (2017-2-17)\n\n\n1.BmobObject setObject: bug 修复\n\n\nv2.1.4 (2017-2-16)\n\n\n1.bug修复\n\n\nv2.1.3 (2017-2-10)\n\n\n1.修复支付异常回调\n2.分离微信支付模块文件\n\n\nv2.1.2 (2017-2-8)\n\n\n1.修改订单查询接口\n\n\nv2.1.1 (2017-2-6)\n\n\n1.添加支付订单信息回调接口\n2.修复user类achieve失败的bug\n\n\nv2.1.0 (2017-1-20)\n\n\n1.修复模块重复问题\n\n\nv2.0.8 (2017-1-19)\n\n\n1.添加微信支付功能\n\n\nv2.0.7 (2017-1-18)\n\n\n1.Bug修复\n\n\nv2.0.6 (2017-1-17)\n\n\n1.Bug修复\n\n\nv2.0.5 (2017-1-17)\n\n\n1.Bug修复\n2.取消xib，该用纯代码实现支付界面\n3.扩展iOS6-iOS7支持\n\n\nv2.0.4 (2017-1-14)\n\n\n1.Bug修复\n\n\nv2.0.3 (2017-1-14)\n\n\n1.Bug修复\n\n\nv2.0.2 (2017-1-13)\n\n\n1.添加支付宝支付\n\n\nv2.0.1 (2016-12-05)\n\n\n1.修复更新个人资料可能会crash的问题\n\n\nv2.0.0 (2016-11-25)\n\n\n1.全面支持https服务\n\n\nv1.7.3 (2016-11-9)\n\n\n1.添加动态更新功能\n2.适配新的短信服务\n\n\nv1.7.2 (2016-07-18)\n\n\n1.替换BmobProFile 内部下载的方法，减少SDK的体积\n2.修复BmobFile上传后可能name为空的问题\n3.修复文件上传内存泄漏的问题\n\n\nv1.7.1 (2016-06-08)\n\n\n1.修改BmobQuery 取消方法错误拼写\n2.修改BmobObject objectWithoutDatatWithClassName方法拼写错误\n3.BmobObject+subclass 增加+(instancetype)covertWithObject:(BmobObject *)obj; 方便在swift调用\n4.修复更新个人资料可能会报用户名已存在的问题\n5.修复有ACL导致的更新不成功的问题\n\n\nv1.7.0 (2016-04-22)\n\n\n1.恢复BmobProFile文件下载的功能\n2.恢复云端代码同步接口（请在子线程使用），新增+(id)callFunction:(NSString \n)function withParameters:(NSDictionary \n)parameters error:(NSError **)error;返回错误信息\n3.Bmob类新增设置文件上传的授权时间和分片大小\n4.BmobInstallation类去掉currentInstallation(命名让人误会)，用installation代替(单纯创建一个BmobInstallation对象).\n\n\nv1.6.9 (2016-04-14)\n\n\n1.文件服务更换为CDN上传,废除新旧文件上传服务\n2.新增文件批量删除接口\n3.去掉调用云端代码同步的方法\n4.BmobUser 设置用户名变为setUsername:(NSString *)username\n5.更换网络请求库为NSURLSession\n6.修复设置超时时间没有反馈的bug\n7.修复某些回调不在主线程的问题\n\n\nv1.6.8 (2016-03-31)\n\n\n1.修复上一个版本用户可能无法更新资料和实时监控的问题\n\n\nv1.6.7 (2016-03-18)\n\n\n1.修复注销登录后的bug\n2.修复请求完成后，偶然会崩溃的的bug\n\n\nv1.6.6 (2015-12-23)\n\n\n1.添加封装的复合查询方法\n2.原子计数器支持浮点数\n3.修复网络环境较差时出现崩溃bug\n\n\nv1.6.5 (2015-10-08)\n\n\n1.支持bitcode操作；\n2.添加从字典初始化BmobObject方法；\n3.添加单独修改JSON对象某个key-value对的功能。\n\n\nv1.6.4 (2015-08-27)\n\n\n1.修改注册后没返回objectId的问题\n\n\nv1.6.3 (2015-08-24)\n\n\n1.添加根据旧密码修改新密码接口；\n2.添加手机验证码注册时可同时添加新密码或者是其它user列的信息接口；\n3.修改上传多个图片时偶然冲突导致上传失败的bug。\n\n\nv1.6.2 (2015-08-18)\n\n\n1.修复缩略图无法返回的问题;\n2.修复上传图片时，文件路径有误时应用出错的问题。\n\n\nv1.6.1（2015-07-27）\n\n\n1.修复使用账号密码注册时无法上传手机号的bug；\n2.开放获取表结构的接口。\n\n\nv1.6.0（2015-07-14）\n\n\n1.文件上传兼容旧文件系统\n1）修改上传文件接口\n2）添加获取已经上传文件访问url接口\n3）删除已上传文件接口\n2.修复子类化bug\n3.添加数组查询接口\n4.修复文件上传下载接口如果传空block会报错的bug\n\n\nv1.5.9（2015-07-01）\n\n\n1.提供修改超时间接口\n2.修复子类化bug\n3.修复实时监听bug\n4.提供自定义短信内容发送功能\n\n\nv1.5.8（2015-06-12）\n\n\n1.添加短信功能\n2.添加BmobObject子类化功能\n3.修复缓存查询部分bug\n4.修复云端代码无法同步bug\n5.第三方登录添加微信登录\n\n\nv1.5.7（2015-05-14）\n\n\n1.添加BQL查询功能\n2.开放模糊查询功能\n\n\nv1.5.6（2015-05-04）\n\n\n1.修改文件操作头文件部分注释；\n2.修复模拟器下有时无法上传文件的问题。\n\n\nv1.5.5（2015-04-24）\n\n\n1.增加统计查询方法\n2.修复部分bug\n\n\nv1.5.4 (2015-04-07)\n\n\n1.增加批量上传方法\nBmobFile\n+(void)filesUploadBatchWithDataArray:(NSArray *)dataArray\n                       progressBlock:(BmobFileBatchProgressBlock)progress\n                         resultBlock:(BmobFileBatchResultBlock)block;\n\n\nBmobFilePro\n+(void)uploadFilesWithDatas:(NSArray *)dataArray\n                resultBlock:(BmobBatchFileUploadResultBlock)block\n                   progress:(BmobIndexAndProgressBlock)progress;\n2.修复其他问题\n\n\nv1.5.3 (2015-03-05)\n\n\n1.修复蜂窝网络下可能会出现的使用新版文件上传文件，上传不了的问题\n2.修复在某些情况下用户可能无法更新表内容的问题\n\n\nv1.5.2 (2015-02-07)\n\n\n1.兼容1.5.1跟1.5.1之前的版本，即可以监听到通知再调用请求方法，也可以直接调用请求方法\n\n\nv1.5.1 (2015-01-23)\n\n\n1.添加初始化完成后通知kBmobInitSuccessNotification，kBmobInitFailNotification\n2.修改更新用户后本地用户可能会为空的问题\n注意：\n因为1.5.0之后的版本新增了加密功能，所以在还没初始化完成的时候请求接口会出现问题。\n故开发者可以监听此通知，获取成功通知的时候再进行其他接口的请求。\n\n\nv1.5.0 (2015-01-17)\n\n\n1.增加数据加密，建议使用新版本\n2.BmobProFile添加开启验证后得到的url方法\n\n\nv1.4.13(2015-01-05)\n\n\n1.新增文件管理类BmobProFile，提供多种上传方法等\n\n\nv1.4.12(2014-12-25)\n\n\n1.修复无网络时获取服务器时间出现的问题\n\n\nv1.4.11(2014-12-17)\n\n\n1.修改安全认证方法，注册方式可换回原来的方法,建议使用新版本\n NSString *appKey = @\"xxxx\";\n[Bmob registerWithAppKey:appKey];\n2.修复云端代码同步方法与异步方法数据格式不一样的问题\n\n\nv1.4.10(2014-12-9)\n\n\n1.增加安全认证的功能，注册应用方式修改为\n\n\n    NSString *appKey = @\nxxxx\n;\n#if DEBUG\n    [Bmob registerWithAppKey:appKey];\n#else\n    [Bmob registerWithAppKeyReleaseMode:appKey];\n#endif\n\n\n\n\n2.文件分片上传功能新增进度的方法。进度的范围为（0.0f-1.0f）\n3.新增批量上传的方法\n4.BmobQuery新增-(void)whereKeySExists:(NSArray \n)keys;\n和-(void)whereKeysDoesNotExist:(NSArray \n)keys; 方法\n\n\nv1.4.9 (2014-10-20)\n\n\n1.修复openudid冲突的问题\n\n\nv1.4.8 (2014-10-11)\n\n\n1.修复用户更新函数在iOS6下可能出现的崩溃问题\n2.修复已知的查询函数可能进入不了block的问题\n\n\nv1.4.7 (2014-10-10)\n\n\n1.修复云端代码的问题\n\n\nv1.4.6 (2014-09-22)\n\n\n修复本地缓存用户，更新后本地基本数据类型不一致的问题\n\n\nv1.4.5(2014-09-17)\n\n\n修复一些问题及优化结构\n\n\nv1.4.4(2014-09-12)\n\n\n修复v1.4.3的一些问题\n\n\nv1.4.3(2014-09-04)\n\n\n1.批量添加批量更新，也能增加特殊类型\n\n\nv1.4.2 (2014-08-20)\n\n\n1.BmobUser 添加获取邮箱是否已验证的方法\n2.修复BmobUser有可能更新不成功的问题\n\n\nv1.4.1 (2014-08-05)\n\n\nBmobUser类增加：\n1.QQ，新浪微博账号注册登录Bmob的功能\n2.关联QQ账号，微博账号功能\n3.提供取消关联的功能\n\n\nv1.4.0 (2014-07-18)\n\n\n1、增加数据实时功能，提供多种监听表变化的方法。\n2、增加BmobEvent类别，监听事件后，开发者可在代理函数里进行操作。\n3、依赖库需要添加多libicucore.dylib\n\n\nv1.3.15(2014-07-17)\n\n\n1、BmobQuery的- (void)getObjectInBackgroundWithId:(NSString \n)objectId\n                              block:(BmobObjectResultBlock)block\n也支持-(void)includeKey:(NSString \n)key跟-(void)selectKeys:(NSArray*)keys了\n\n\nv1.3.14(2014-07-14)\n\n\n1、修复2G网络下查询可能会crash的问题\n\n\nv1.3.13(2014-6-18)\n\n\n1、修正一些bug\n2、修正缓存查询可能存在的问题\n\n\nv1.3.12(2014-6-11)\n\n\n1、BmobQuery新增自定义查询条件接口：-(void)queryWithAllConstraint:(NSDictionary*)conDictionary;\n2、BmobQuery新增取消接口\n\n\nv1.3.11(2014-05-28)\n\n\n1、修复更新可能不成功的问题\n\n\nv1.3.10(2014-05-27)\n\n\n1、BmobFile类添加分片上传的方法\n2、添加BmobACL权限和BmobRole角色管理类\n3、添加BmobImage图像处理类，提供多种方法处理图像\n\n\nv1.3.9(2014-05-21)\n\n\n1、修复user表有关联关系，用户登录后更新不成功的问题\n\n\nv1.3.8 (2014-05-16)\n\n\n1、修复云端代码同步没返回的bug\n2、增加文件上传进度和取消上传函数\n3、修复添加SDK出现多个警告的问题\n\n\nv1.3.7(2014-04-30)\n\n\n1、增加BmobInstallation类别，注册需要推送设备。\n2、增加BmobPush功能模块，可进行自定义推送。\n\n\nv1.3.6(2014-04-23)\n\n\n1、BmobUser增加邮箱验证接口，只有在web端应用设置里开启邮箱验证才有效\n2、增加BmobObjectBatch类，批量修改数据\n\n\nv1.3.5(2014-04-18)\n\n\n1、添加x86_64位、arm64架构\n2、添加指针类型，和relation类型\n3、添加BmobObject对象列为Number时，可进行原子增加或减少的功能\n4、添加BmobRelation类，为BmobObject之类关联关系\n5、BmobQuery新增查询约束条件\n- (void)whereKey:(NSString \n)key matchesQuery:(BmobQuery \n)query;\n- (void)whereKey:(NSString \n)key doesNotMatchQuery:(BmobQuery \n)query;\n- (void)whereObjectKey:(NSString \n)key relatedTo:(BmobObject\n)object;\n\n\nv1.3.4（2014-04-10）\n\n\n1、Bmob.h 引入头文件\n\n\n#import \nBmobObject.h\n\n#import \nBmobFile.h\n\n#import \nBmobGeoPoint.h\n\n#import \nBmobQuery.h\n\n#import \nBmobUser.h\n\n#import \nBmobCloud.h\n\n#import \nBmobConfig.h\n\n\n\n\n\nv1.3.3（2014-04-08）\n\n\n1、增加组合查询并操作跟或操作\n\n\nv1.3.2(2014-04-06)\n\n\n1、修复[BmobUser getCurrentObject]与 之前版本不兼容的问题\n\n\nv1.3.1(2014-04-04)\n\n\n1、修复BmobFile url的相关bug\n2、增加BmobQuery约束条件：\n//  设置查询后要返回的key\n-(void)selectKeys:(NSArray\n)keys;\n//指定的key的值是存在的\n- (void)whereKeyExists:(NSString \n)key;\n// 指定的key的值是不存在的\n- (void)whereKeyDoesNotExist:(NSString *)key;\n\n\nv1.3.0\n\n\n1、修复BmobUser无法重置密码的bug\n\n\nv1.2.91\n\n\n1、修正一些bug\n\n\nv1.2.9\n\n\n1、Bmob类增加获取服务器时间接口\n\n\nv1.2.8\n\n\n1、修复登陆失败后没返回错误信息\n\n\nv1.2.7(2014-03-05)\n\n\n1、修复上传文件失败的bug\n2、修复BmobObject 函数-(void)setObject:(id)obj forKey:(NSString*)aKey;obj为nil时，crash的问题\n3、修复某些字符无法保存的问题\n4、修复BmobFile 路径没有文件时crash的问题\n5、BmobFile增加saveInBackground方法\n\n\nv1.2.6(2014-03-03)\n\n\n1、修复添加NSDate类型失败的问题\n\n\n2、BmobObject类添加-(void)saveAllWithDictionary:(NSDictionary*)dic;方法，支持批量添加数据\n\n\nv1.2.5\n\n\n(2014-02-25)\n1.修复在非主线程block没回调的问题\n\n\nv1.2.4\n\n\n(2014-02-24)\n1、使用自带访问网络的类替代部分第三方库，有base64、jsonkit、asihttprequest，减少冲突\n\n\n2、调用BmobObject 的saveInBackground和saveInBackgroundWithResultBlock函数后，回填objectId，createdAt,updatedAt等\n\n\nv1.2.3（2014-02-14）\n\n\n1.修复BmobUser 更新属性后本地没更新的bug\n\n\n2.修改地理位置查询，排序结果从近到远，而不是根据updateAt降序排序\n\n\nv1.2.2（2014-01-12）\n\n\n1.优化初始化函数\n\n\nv1.2.1（2014-01-02）\n\n\n1.新增云端代码功能\n2.优化性能，减少冗余\n\n\nv1.2.0（2013-12-02）\n\n\n1.更改静态库为framework，减少体积\n2.调整调用函数，更稳定更便捷\n3.增加完善部分错误信息回调接口\n\n\nv1.1.7(2013-11-27)\n\n\n1.解决打包出现的bug\n2.优化相关回调函数\n\n\nv1.1.6(2013-11-26)\n\n\n1、增加稳定性，优化代码结构\n\n\n2、BmobQuery增加查询用户函数+(BmobQuery*)queryForUser;\n\n\n3、新增加密码重置功能\n\n\n4、新增用户登陆功能，登陆成功返回个人信息\n5、新增接口请求数据统计\n\n\nv1.1.5(2013-11-06)\n\n\n1、修复在循环中使用BmobQuery:- (void)getObjectInBackgroundWithId:(NSString *)objectId\n                              block:(BmobObjectResultBlock)block;\n遇到的问题\n\n\nv1.1.4(2013-10-29)\n\n\n1、新增Count查询功能\n\n\n2、新增地理位置查询功能\n\n\n3、修改BmobGeo类初始化方法与web端显示不一致的问题\n\n\nv1.1.3(2013-10-17)\n\n\n1.修复BmobObject取特殊类型属性错误的bug\n2.修复上传时会更新createdAt的问题\n\n\nv1.1.2(2013-10-11)\n\n\n1、修复BmobObject类updatedAt、createdAt类型问题\n\n\nv1.1.1(2013-10-09)\n\n\n1、对网络传输的优化\n\n\nv1.1.0(2013-09-22)\n\n\n1、BmobFile类添加了初始化方法：-(id)initWithClassName:(NSString \n)className withFileData:(NSData\n)data;可以直接上传二进制数据；\n2、修复了BmobQuery类中- (void)findObjectsInBackgroundWithBlock:(BmobObjectArrayResultBlock)block;得到的数组中的对象不能更新的bug；", 
            "title": "更新日志"
        }, 
        {
            "location": "/module/update_log/README/index.html#v215-2017-2-17", 
            "text": "1.BmobObject setObject: bug 修复", 
            "title": "v2.1.5 (2017-2-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v214-2017-2-16", 
            "text": "1.bug修复", 
            "title": "v2.1.4 (2017-2-16)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v213-2017-2-10", 
            "text": "1.修复支付异常回调\n2.分离微信支付模块文件", 
            "title": "v2.1.3 (2017-2-10)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v212-2017-2-8", 
            "text": "1.修改订单查询接口", 
            "title": "v2.1.2 (2017-2-8)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v211-2017-2-6", 
            "text": "1.添加支付订单信息回调接口\n2.修复user类achieve失败的bug", 
            "title": "v2.1.1 (2017-2-6)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v210-2017-1-20", 
            "text": "1.修复模块重复问题", 
            "title": "v2.1.0 (2017-1-20)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v208-2017-1-19", 
            "text": "1.添加微信支付功能", 
            "title": "v2.0.8 (2017-1-19)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v207-2017-1-18", 
            "text": "1.Bug修复", 
            "title": "v2.0.7 (2017-1-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v206-2017-1-17", 
            "text": "1.Bug修复", 
            "title": "v2.0.6 (2017-1-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v205-2017-1-17", 
            "text": "1.Bug修复\n2.取消xib，该用纯代码实现支付界面\n3.扩展iOS6-iOS7支持", 
            "title": "v2.0.5 (2017-1-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v204-2017-1-14", 
            "text": "1.Bug修复", 
            "title": "v2.0.4 (2017-1-14)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v203-2017-1-14", 
            "text": "1.Bug修复", 
            "title": "v2.0.3 (2017-1-14)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v202-2017-1-13", 
            "text": "1.添加支付宝支付", 
            "title": "v2.0.2 (2017-1-13)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v201-2016-12-05", 
            "text": "1.修复更新个人资料可能会crash的问题", 
            "title": "v2.0.1 (2016-12-05)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v200-2016-11-25", 
            "text": "1.全面支持https服务", 
            "title": "v2.0.0 (2016-11-25)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v173-2016-11-9", 
            "text": "1.添加动态更新功能\n2.适配新的短信服务", 
            "title": "v1.7.3 (2016-11-9)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v172-2016-07-18", 
            "text": "1.替换BmobProFile 内部下载的方法，减少SDK的体积\n2.修复BmobFile上传后可能name为空的问题\n3.修复文件上传内存泄漏的问题", 
            "title": "v1.7.2 (2016-07-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v171-2016-06-08", 
            "text": "1.修改BmobQuery 取消方法错误拼写\n2.修改BmobObject objectWithoutDatatWithClassName方法拼写错误\n3.BmobObject+subclass 增加+(instancetype)covertWithObject:(BmobObject *)obj; 方便在swift调用\n4.修复更新个人资料可能会报用户名已存在的问题\n5.修复有ACL导致的更新不成功的问题", 
            "title": "v1.7.1 (2016-06-08)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v170-2016-04-22", 
            "text": "1.恢复BmobProFile文件下载的功能\n2.恢复云端代码同步接口（请在子线程使用），新增+(id)callFunction:(NSString  )function withParameters:(NSDictionary  )parameters error:(NSError **)error;返回错误信息\n3.Bmob类新增设置文件上传的授权时间和分片大小\n4.BmobInstallation类去掉currentInstallation(命名让人误会)，用installation代替(单纯创建一个BmobInstallation对象).", 
            "title": "v1.7.0 (2016-04-22)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v169-2016-04-14", 
            "text": "1.文件服务更换为CDN上传,废除新旧文件上传服务\n2.新增文件批量删除接口\n3.去掉调用云端代码同步的方法\n4.BmobUser 设置用户名变为setUsername:(NSString *)username\n5.更换网络请求库为NSURLSession\n6.修复设置超时时间没有反馈的bug\n7.修复某些回调不在主线程的问题", 
            "title": "v1.6.9 (2016-04-14)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v168-2016-03-31", 
            "text": "1.修复上一个版本用户可能无法更新资料和实时监控的问题", 
            "title": "v1.6.8 (2016-03-31)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v167-2016-03-18", 
            "text": "1.修复注销登录后的bug\n2.修复请求完成后，偶然会崩溃的的bug", 
            "title": "v1.6.7 (2016-03-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v166-2015-12-23", 
            "text": "1.添加封装的复合查询方法\n2.原子计数器支持浮点数\n3.修复网络环境较差时出现崩溃bug", 
            "title": "v1.6.6 (2015-12-23)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v165-2015-10-08", 
            "text": "1.支持bitcode操作；\n2.添加从字典初始化BmobObject方法；\n3.添加单独修改JSON对象某个key-value对的功能。", 
            "title": "v1.6.5 (2015-10-08)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v164-2015-08-27", 
            "text": "1.修改注册后没返回objectId的问题", 
            "title": "v1.6.4 (2015-08-27)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v163-2015-08-24", 
            "text": "1.添加根据旧密码修改新密码接口；\n2.添加手机验证码注册时可同时添加新密码或者是其它user列的信息接口；\n3.修改上传多个图片时偶然冲突导致上传失败的bug。", 
            "title": "v1.6.3 (2015-08-24)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v162-2015-08-18", 
            "text": "1.修复缩略图无法返回的问题;\n2.修复上传图片时，文件路径有误时应用出错的问题。", 
            "title": "v1.6.2 (2015-08-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1612015-07-27", 
            "text": "1.修复使用账号密码注册时无法上传手机号的bug；\n2.开放获取表结构的接口。", 
            "title": "v1.6.1（2015-07-27）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1602015-07-14", 
            "text": "1.文件上传兼容旧文件系统\n1）修改上传文件接口\n2）添加获取已经上传文件访问url接口\n3）删除已上传文件接口\n2.修复子类化bug\n3.添加数组查询接口\n4.修复文件上传下载接口如果传空block会报错的bug", 
            "title": "v1.6.0（2015-07-14）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1592015-07-01", 
            "text": "1.提供修改超时间接口\n2.修复子类化bug\n3.修复实时监听bug\n4.提供自定义短信内容发送功能", 
            "title": "v1.5.9（2015-07-01）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1582015-06-12", 
            "text": "1.添加短信功能\n2.添加BmobObject子类化功能\n3.修复缓存查询部分bug\n4.修复云端代码无法同步bug\n5.第三方登录添加微信登录", 
            "title": "v1.5.8（2015-06-12）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1572015-05-14", 
            "text": "1.添加BQL查询功能\n2.开放模糊查询功能", 
            "title": "v1.5.7（2015-05-14）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1562015-05-04", 
            "text": "1.修改文件操作头文件部分注释；\n2.修复模拟器下有时无法上传文件的问题。", 
            "title": "v1.5.6（2015-05-04）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1552015-04-24", 
            "text": "1.增加统计查询方法\n2.修复部分bug", 
            "title": "v1.5.5（2015-04-24）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v154-2015-04-07", 
            "text": "1.增加批量上传方法\nBmobFile\n+(void)filesUploadBatchWithDataArray:(NSArray *)dataArray\n                       progressBlock:(BmobFileBatchProgressBlock)progress\n                         resultBlock:(BmobFileBatchResultBlock)block;  BmobFilePro\n+(void)uploadFilesWithDatas:(NSArray *)dataArray\n                resultBlock:(BmobBatchFileUploadResultBlock)block\n                   progress:(BmobIndexAndProgressBlock)progress;\n2.修复其他问题", 
            "title": "v1.5.4 (2015-04-07)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v153-2015-03-05", 
            "text": "1.修复蜂窝网络下可能会出现的使用新版文件上传文件，上传不了的问题\n2.修复在某些情况下用户可能无法更新表内容的问题", 
            "title": "v1.5.3 (2015-03-05)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v152-2015-02-07", 
            "text": "1.兼容1.5.1跟1.5.1之前的版本，即可以监听到通知再调用请求方法，也可以直接调用请求方法", 
            "title": "v1.5.2 (2015-02-07)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v151-2015-01-23", 
            "text": "1.添加初始化完成后通知kBmobInitSuccessNotification，kBmobInitFailNotification\n2.修改更新用户后本地用户可能会为空的问题\n注意：\n因为1.5.0之后的版本新增了加密功能，所以在还没初始化完成的时候请求接口会出现问题。\n故开发者可以监听此通知，获取成功通知的时候再进行其他接口的请求。", 
            "title": "v1.5.1 (2015-01-23)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v150-2015-01-17", 
            "text": "1.增加数据加密，建议使用新版本\n2.BmobProFile添加开启验证后得到的url方法", 
            "title": "v1.5.0 (2015-01-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v14132015-01-05", 
            "text": "1.新增文件管理类BmobProFile，提供多种上传方法等", 
            "title": "v1.4.13(2015-01-05)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v14122014-12-25", 
            "text": "1.修复无网络时获取服务器时间出现的问题", 
            "title": "v1.4.12(2014-12-25)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v14112014-12-17", 
            "text": "1.修改安全认证方法，注册方式可换回原来的方法,建议使用新版本\n NSString *appKey = @\"xxxx\";\n[Bmob registerWithAppKey:appKey];\n2.修复云端代码同步方法与异步方法数据格式不一样的问题", 
            "title": "v1.4.11(2014-12-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v14102014-12-9", 
            "text": "1.增加安全认证的功能，注册应用方式修改为      NSString *appKey = @ xxxx ;\n#if DEBUG\n    [Bmob registerWithAppKey:appKey];\n#else\n    [Bmob registerWithAppKeyReleaseMode:appKey];\n#endif  2.文件分片上传功能新增进度的方法。进度的范围为（0.0f-1.0f）\n3.新增批量上传的方法\n4.BmobQuery新增-(void)whereKeySExists:(NSArray  )keys;\n和-(void)whereKeysDoesNotExist:(NSArray  )keys; 方法", 
            "title": "v1.4.10(2014-12-9)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v149-2014-10-20", 
            "text": "1.修复openudid冲突的问题", 
            "title": "v1.4.9 (2014-10-20)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v148-2014-10-11", 
            "text": "1.修复用户更新函数在iOS6下可能出现的崩溃问题\n2.修复已知的查询函数可能进入不了block的问题", 
            "title": "v1.4.8 (2014-10-11)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v147-2014-10-10", 
            "text": "1.修复云端代码的问题", 
            "title": "v1.4.7 (2014-10-10)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v146-2014-09-22", 
            "text": "修复本地缓存用户，更新后本地基本数据类型不一致的问题", 
            "title": "v1.4.6 (2014-09-22)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1452014-09-17", 
            "text": "修复一些问题及优化结构", 
            "title": "v1.4.5(2014-09-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1442014-09-12", 
            "text": "修复v1.4.3的一些问题", 
            "title": "v1.4.4(2014-09-12)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1432014-09-04", 
            "text": "1.批量添加批量更新，也能增加特殊类型", 
            "title": "v1.4.3(2014-09-04)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v142-2014-08-20", 
            "text": "1.BmobUser 添加获取邮箱是否已验证的方法\n2.修复BmobUser有可能更新不成功的问题", 
            "title": "v1.4.2 (2014-08-20)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v141-2014-08-05", 
            "text": "BmobUser类增加：\n1.QQ，新浪微博账号注册登录Bmob的功能\n2.关联QQ账号，微博账号功能\n3.提供取消关联的功能", 
            "title": "v1.4.1 (2014-08-05)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v140-2014-07-18", 
            "text": "1、增加数据实时功能，提供多种监听表变化的方法。\n2、增加BmobEvent类别，监听事件后，开发者可在代理函数里进行操作。\n3、依赖库需要添加多libicucore.dylib", 
            "title": "v1.4.0 (2014-07-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v13152014-07-17", 
            "text": "1、BmobQuery的- (void)getObjectInBackgroundWithId:(NSString  )objectId\n                              block:(BmobObjectResultBlock)block\n也支持-(void)includeKey:(NSString  )key跟-(void)selectKeys:(NSArray*)keys了", 
            "title": "v1.3.15(2014-07-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v13142014-07-14", 
            "text": "1、修复2G网络下查询可能会crash的问题", 
            "title": "v1.3.14(2014-07-14)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v13132014-6-18", 
            "text": "1、修正一些bug\n2、修正缓存查询可能存在的问题", 
            "title": "v1.3.13(2014-6-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v13122014-6-11", 
            "text": "1、BmobQuery新增自定义查询条件接口：-(void)queryWithAllConstraint:(NSDictionary*)conDictionary;\n2、BmobQuery新增取消接口", 
            "title": "v1.3.12(2014-6-11)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v13112014-05-28", 
            "text": "1、修复更新可能不成功的问题", 
            "title": "v1.3.11(2014-05-28)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v13102014-05-27", 
            "text": "1、BmobFile类添加分片上传的方法\n2、添加BmobACL权限和BmobRole角色管理类\n3、添加BmobImage图像处理类，提供多种方法处理图像", 
            "title": "v1.3.10(2014-05-27)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1392014-05-21", 
            "text": "1、修复user表有关联关系，用户登录后更新不成功的问题", 
            "title": "v1.3.9(2014-05-21)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v138-2014-05-16", 
            "text": "1、修复云端代码同步没返回的bug\n2、增加文件上传进度和取消上传函数\n3、修复添加SDK出现多个警告的问题", 
            "title": "v1.3.8 (2014-05-16)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1372014-04-30", 
            "text": "1、增加BmobInstallation类别，注册需要推送设备。\n2、增加BmobPush功能模块，可进行自定义推送。", 
            "title": "v1.3.7(2014-04-30)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1362014-04-23", 
            "text": "1、BmobUser增加邮箱验证接口，只有在web端应用设置里开启邮箱验证才有效\n2、增加BmobObjectBatch类，批量修改数据", 
            "title": "v1.3.6(2014-04-23)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1352014-04-18", 
            "text": "1、添加x86_64位、arm64架构\n2、添加指针类型，和relation类型\n3、添加BmobObject对象列为Number时，可进行原子增加或减少的功能\n4、添加BmobRelation类，为BmobObject之类关联关系\n5、BmobQuery新增查询约束条件\n- (void)whereKey:(NSString  )key matchesQuery:(BmobQuery  )query;\n- (void)whereKey:(NSString  )key doesNotMatchQuery:(BmobQuery  )query;\n- (void)whereObjectKey:(NSString  )key relatedTo:(BmobObject )object;", 
            "title": "v1.3.5(2014-04-18)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1342014-04-10", 
            "text": "1、Bmob.h 引入头文件  #import  BmobObject.h \n#import  BmobFile.h \n#import  BmobGeoPoint.h \n#import  BmobQuery.h \n#import  BmobUser.h \n#import  BmobCloud.h \n#import  BmobConfig.h", 
            "title": "v1.3.4（2014-04-10）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1332014-04-08", 
            "text": "1、增加组合查询并操作跟或操作", 
            "title": "v1.3.3（2014-04-08）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1322014-04-06", 
            "text": "1、修复[BmobUser getCurrentObject]与 之前版本不兼容的问题", 
            "title": "v1.3.2(2014-04-06)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1312014-04-04", 
            "text": "1、修复BmobFile url的相关bug\n2、增加BmobQuery约束条件：\n//  设置查询后要返回的key\n-(void)selectKeys:(NSArray )keys;\n//指定的key的值是存在的\n- (void)whereKeyExists:(NSString  )key;\n// 指定的key的值是不存在的\n- (void)whereKeyDoesNotExist:(NSString *)key;", 
            "title": "v1.3.1(2014-04-04)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v130", 
            "text": "1、修复BmobUser无法重置密码的bug", 
            "title": "v1.3.0"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1291", 
            "text": "1、修正一些bug", 
            "title": "v1.2.91"
        }, 
        {
            "location": "/module/update_log/README/index.html#v129", 
            "text": "1、Bmob类增加获取服务器时间接口", 
            "title": "v1.2.9"
        }, 
        {
            "location": "/module/update_log/README/index.html#v128", 
            "text": "1、修复登陆失败后没返回错误信息", 
            "title": "v1.2.8"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1272014-03-05", 
            "text": "1、修复上传文件失败的bug\n2、修复BmobObject 函数-(void)setObject:(id)obj forKey:(NSString*)aKey;obj为nil时，crash的问题\n3、修复某些字符无法保存的问题\n4、修复BmobFile 路径没有文件时crash的问题\n5、BmobFile增加saveInBackground方法", 
            "title": "v1.2.7(2014-03-05)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1262014-03-03", 
            "text": "1、修复添加NSDate类型失败的问题  2、BmobObject类添加-(void)saveAllWithDictionary:(NSDictionary*)dic;方法，支持批量添加数据", 
            "title": "v1.2.6(2014-03-03)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v125", 
            "text": "(2014-02-25)\n1.修复在非主线程block没回调的问题", 
            "title": "v1.2.5"
        }, 
        {
            "location": "/module/update_log/README/index.html#v124", 
            "text": "(2014-02-24)\n1、使用自带访问网络的类替代部分第三方库，有base64、jsonkit、asihttprequest，减少冲突  2、调用BmobObject 的saveInBackground和saveInBackgroundWithResultBlock函数后，回填objectId，createdAt,updatedAt等", 
            "title": "v1.2.4"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1232014-02-14", 
            "text": "1.修复BmobUser 更新属性后本地没更新的bug  2.修改地理位置查询，排序结果从近到远，而不是根据updateAt降序排序", 
            "title": "v1.2.3（2014-02-14）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1222014-01-12", 
            "text": "1.优化初始化函数", 
            "title": "v1.2.2（2014-01-12）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1212014-01-02", 
            "text": "1.新增云端代码功能\n2.优化性能，减少冗余", 
            "title": "v1.2.1（2014-01-02）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1202013-12-02", 
            "text": "1.更改静态库为framework，减少体积\n2.调整调用函数，更稳定更便捷\n3.增加完善部分错误信息回调接口", 
            "title": "v1.2.0（2013-12-02）"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1172013-11-27", 
            "text": "1.解决打包出现的bug\n2.优化相关回调函数", 
            "title": "v1.1.7(2013-11-27)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1162013-11-26", 
            "text": "1、增加稳定性，优化代码结构  2、BmobQuery增加查询用户函数+(BmobQuery*)queryForUser;  3、新增加密码重置功能  4、新增用户登陆功能，登陆成功返回个人信息\n5、新增接口请求数据统计", 
            "title": "v1.1.6(2013-11-26)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1152013-11-06", 
            "text": "1、修复在循环中使用BmobQuery:- (void)getObjectInBackgroundWithId:(NSString *)objectId\n                              block:(BmobObjectResultBlock)block;\n遇到的问题", 
            "title": "v1.1.5(2013-11-06)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1142013-10-29", 
            "text": "1、新增Count查询功能  2、新增地理位置查询功能  3、修改BmobGeo类初始化方法与web端显示不一致的问题", 
            "title": "v1.1.4(2013-10-29)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1132013-10-17", 
            "text": "1.修复BmobObject取特殊类型属性错误的bug\n2.修复上传时会更新createdAt的问题", 
            "title": "v1.1.3(2013-10-17)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1122013-10-11", 
            "text": "1、修复BmobObject类updatedAt、createdAt类型问题", 
            "title": "v1.1.2(2013-10-11)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1112013-10-09", 
            "text": "1、对网络传输的优化", 
            "title": "v1.1.1(2013-10-09)"
        }, 
        {
            "location": "/module/update_log/README/index.html#v1102013-09-22", 
            "text": "1、BmobFile类添加了初始化方法：-(id)initWithClassName:(NSString  )className withFileData:(NSData )data;可以直接上传二进制数据；\n2、修复了BmobQuery类中- (void)findObjectsInBackgroundWithBlock:(BmobObjectArrayResultBlock)block;得到的数组中的对象不能更新的bug；", 
            "title": "v1.1.0(2013-09-22)"
        }
    ]
}