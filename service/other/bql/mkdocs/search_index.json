{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Bmob Query Language（简称 BQL） 是 Bmob 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 Bmob 查询的 API 的成本，可以使用传统的 SQL 语法来查询 Bmob 应用内的数据。\n\n\n本文档将详细介绍 BQL 的语法和常见用法。\n\n\n介绍及基本语法\n\n\n最基本的一个查询:\n\n\n查询某个 class 下的 100 条数据：\n\n\nselect * from GameScore\n\n\n\n\n等价于（以 Android 为例）:\n\n\n//查询GameScore的100条数据\nBmobQuery\nGameScore\n query = new BmobQuery\nGameScore\n();\nquery.findObjects(context, new FindListener\nGameScore\n() {\n\n    @Override\n    public void onSuccess(List\nGameScore\n object) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onError(int code, String msg) {\n        // TODO Auto-generated method stub\n    }\n});\n\n\n\n\nselect一个完整的语法形式类似这样：\n\n\nselect [查询字段列表，多个以逗号隔开] from [class 名称]\n   [where [条件列表]\n   [limit skip,limit\n   [order by [排序字段列表] [asc |desc]]]]\n\n\n\n\n举例：\n\n\n\n//查询结果只包含 name,playScore 以及内置字段(objectId,createdAt等)\nselect name,playScore from GameScore\n\n//根据 name 查找\nselect * from GameScore where name='smile'\n\n//根据 name 和 playScore 同时查找\nselect * from GameScore where name is exists and playScore \n 80 and playScore \n= 100\n\n//分页查找，从第 10 条开始向后查找 10 条数据\nselect * from GameScore limit 10,10\n\n//根据 score 和 name 排序\nselect * from GameScore order by -playScore,+name\n\n\n\n\n\n注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线\n_\n。\n\n\n比如，你想查询的是用户\nsmile\n的信息，则：\n\n\n\n`select * from _User where username= smile`\n\n\n\n\n\n查询条件\n\n\n比较查询\n\n\n查询指定信息的对象，用 \n=\n 比较符：\n\n\nselect * from GameScore where name='smile'\n\n\n\n\n查询\n不等于\n指定信息的对象，用\n!=\n比较符：\n\n\nselect * from GameScore where name!='smile'\n\n\n\n\n也可以用\n运算符来表示不等于。\n\n\n比较日期，使用\ndate\n函数来转换，比如查询特定时间之前创建的对象：\n\n\nselect * from GameScore where createdAt \n date('2015-05-20 00:00:00')\n\n\n\n\n\ndate 函数接收的日期格式必须是 \nyyyy-MM-dd HH:mm:ss\n。更多内置函数请看最后的 \n内置函数\n。\n\n\n一些常见的查询运算符：\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n对应Bmob的查询API\n\n\n\n\n\n\n\n\n\n\n=\n\n\n等于\n\n\naddWhereEqualTo\n\n\n\n\n\n\n!= 或者 \n\n\n不等于\n\n\naddWhereNotEqualTo\n\n\n\n\n\n\n\n\n小于\n\n\naddWhereLessThan\n\n\n\n\n\n\n=\n\n\n小于等于\n\n\naddWhereLessThanOrEqualTo\n\n\n\n\n\n\n\n\n大于\n\n\naddWhereGreaterThan\n\n\n\n\n\n\n=\n\n\n大于等于\n\n\naddWhereGreaterThanOrEqualTo\n\n\n\n\n\n\n[not] like\n\n\n模糊查询\n\n\naddWhereStartsWith或addWhereEndsWith\n\n\n\n\n\n\n[not] regexp\n\n\n正则匹配\n\n\naddWhereMatches\n\n\n\n\n\n\n[not] in(子查询或者数组)\n\n\n包含或者不包含\n\n\naddWhereMatchesQuery或者addWhereDoesNotMatchQuery\n\n\n\n\n\n\nis [not] exists\n\n\n这个Key有值或者不存在值\n\n\naddWhereExists或addWhereDoesNotExists\n\n\n\n\n\n\n\n\n注：比较运算符可以用在\n日期\n、\n字符串\n、\n数字\n甚至\n对象\n上。\n\n\n模糊查询\n\n\n注:模糊查询只对付费用户开放，付费后可直接使用。\n\n\n模糊查询可以使用 \nlike\n，比如查询名字以 smile 开头的对象\n\n\nselect * from GameScore where name like 'smile%'\n\n\n\n\n% 表示模糊匹配的位置占位符。\n\n\nlike\n 本质上是转成\nregexp\n的正则匹配查询，因此上面的例子还可以写成：\n\n\nselect * from GameScore where name regexp 'smile.*'\n\n\n\n\n否定形式，以\nnot like\n 来查询名字不以 smile 开头的对象：\n\n\nselect * from GameScore where name not like 'smile%'\n\n\n\n\n等价于\nnot regexp\n:\n\n\nselect * from GameScore where name not regexp 'smile.*'\n\n\n\n\n值是否存在查询\n\n\n只返回 name 字段值存在的对象：\n\n\nselect * from GameScore where name is exists\n\n\n\n\n反之，使用 \nis not exists\n。\n\n\n数组查询\n\n\n假设\nhobby\n表示一个人的爱好，其字段类型是List\n对应服务端的\n数组Array\n类型，如我们想查询有游泳爱好的人：\n\n\nselect * from Person where hobby ='游泳'\n\n\n\n\n\n查询既爱好游泳也爱好看书的人：\n\n\nselect * from Person where hobby all ('游泳','看书')\n\n\n\n\n注：all 表示数组完全匹配。\n\n\n子查询\n\n\n1、使用 \nin\n来做子查询，后面跟的可以是一个列表，例如 查询游戏名为地铁跑酷、部落冲突两种游戏的记录：\n\n\nselect * from GameScore where game in ('地铁跑酷','部落冲突')\n\n\n\n\n当然，如果想查询的不在列表里，那可以使用\nnot in\n:\n\n\nselect * from GameScore where game not in ('地铁跑酷','部落冲突')\n\n\n\n\n2、\nin\n后面还可以是一个子查询:\n\n\n比如：要查询游戏得分大于10的玩家信息\n\n\n这里需要\nusername\n的值必须要在子查询产生的数组中，因此,我在\nGameScore\n表中新建了一个\nname\n字段来表示玩家的姓名\n\n\nselect * from _User where username in (select name from GameScore where playScore\n10)\n\n\n\n\n比如：查询年龄大于20的玩家的游戏信息\n\n\nselect * from GameScore where name in (select username from _User where age\n20)\n\n\n\n\n3、子查询另一种常见形式：使用\n= 或 !=\n后面跟一条查询语句：\n\n\n比如：查询游戏得分大于80的玩家\n\n\nselect * from _User where username =(select name from GameScore where playScore\n10)\nselect * from _User where username !=(select name from GameScore where playScore\n=10)\n\n\n\n\n注：子查询的语句也受上限 1000 条记录的限制\n\n\n地理位置查询\n\n\n我们可以通过 BQL 进行地理位置查询。\n\n\n附近的人\n\n\n使用\nnear\n来查询附近的人\n\n\n比如我想查询指定地理位置附近的玩家（从近到远排序），假设 \ngps\n 字段是 \nBmobGeoPoint\n类型：\n\n\nselect * from GameScore where gps near [112.934755,24.52065]\n\n\n\n\n注：[112.934755,24.52065] 是经纬度坐标。必须是经度在前，纬度在后\n\n\n也可以使用 \ngeopoint\n 函数来创建：\n\n\nselect * from GameScore where gps near geopoint(112.934755,24.52065)\n\n\n\n\n注：只有在地理位置信息查询里才可以使用 \n[longitude, latitude]\n这样的语法。在其他查询里将被作为数组类型。\n\n\n限定搜索范围\n\n\n为了限定搜索的最大距离，还可以使用 \nmax distance 单位\n来限定，比如,搜索附近1公里内的人：\n\n\nselect * from GameScore where gps near [112.934755,24.52065] max 1 km\n\n\n\n\n\n注：单位包括 miles（英里）、radians（弧度），默认是弧度。\n\n\n查询矩形范围\n\n\n如果想查询某个矩形框内的对象，可以使用\nwithin [西南坐标] and [东北坐标]\n的语法：\n\n\nselect * from GameScore where gps within [102.934755,24.52065] and [112.934755,24.52065]\n\n\n\n\n查询个数\n\n\n使用 \ncount\n 查询来返回符合查询条件的数目。\n\n\n比如:查询整张表的记录数：\n\n\nselect count(*) from GameScore\n\n\n\n\n注：count 不支持distinct等语法。仅限count(*)和count(objectId)\n\n\n查询总的记录数并返回得分在10-20之间的游戏分数信息\n\n\nselect count(*) from GameScore where playScore\n10 and where playScore\n20\n\n\n\n\n查询个数的同时可以返回对象,使用\n,\n隔开：\n\n\nselect count(*),* from GameScore\n\n\n\n\n也可以返回特定的字段：\n\n\n比如：查询GameScore表中的总数并返回每条记录的游戏名\n\n\nselect count(*),game from GameScore\n\n\n\n\n\n关系查询\n\n\n有如下几种方式来查询对象之间的关系数据 \n\n\n1、如果您想获取对象，而这个对象的一个字段对应了另一个对象, 您可以用一个 \nwhere\n 查询, 自己构造一个 \nPointer\n 函数, 和其他数据类型一样。\n\n\n例如： \nWeibo\n类中有一个\nUser\n（继承自BmobUser）类型的\nauthor\n字段表示这条微博的发送方，现在你想查询当前用户发布的所有微博信息，那么可以这样写：\n\n\nselect include author,* from Weibo where author = pointer('_User', '6720c14c28')\n\n\n\n\npointer\n内置函数接收 className 和 objectId。\n\n\n2、如果您想获取对象, 这个对象的一个字段指向的对象（必须是BmobPointer类型）是符合另一个查询的, 您可以使用\nin\n查询。\n\n\n例如, 假设您有一个 \nWeibo\n 类和一个 \nComment\n 类, 每个\nComment\n 都有一个指向它的 \nWeibo\n 的 weibo字段（BmobPointer类型）, 现在您想查询带有图片的 \nWeibo\n 的 Comment列表:\n\n\nselect * from Comment where weibo in (select * from Weibo where image is exists)\n\n\n\n\n注:默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。\n\n\n3、如果 \nWeibo\n 类下有一个\nBmobRelation\n类型的\ncomment\n字段，它存储了这条微博所有的评论列表。你可以查询到这些评论信息，因为他们都关联到了同一条微博：\n\n\nselect * from Comment where related comment to pointer('Weibo', '262f6ace1a')\n\n\n\n\n基本的查询形式是 \nreleated \nkey\n to \npointer\n。\n\n\n4、如果某个字段是 Pointer ，默认查询的时候，只会返回 {__type: 'Pointer', objectId: 'xxxxxx', className:'Weibo'} 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用\ninclude\n。\n\n\n1）、采用 \ninclude \nkey\n 就可以将某个 \nPointer\n字段关联查询出来：\n\n\n比如查询 \nComment\n 同时将 \nauthor\n带下来：\n\n\nselect include author, * from Comment\n\n\n\n\n2）、\n多个字段要多次 include\n:\n\n\nselect include weibo,include author from Comment\n\n\n\n\n3）、还可以支持\n嵌套的 include 查询\n：\n\n\n比如 \nWeibo\n 里还有一个 Pointer 指向 author(表示这条微博是谁发的):\n\n\nselect include weibo.author,* from Comment\n\n\n\n\n复合查询\n\n\n使用 \nand\n 和 \nor\n进行复合查询\n\n\n比如：查询游戏得分在10-15之间的数据,可以使用\nand\n查询:\n\n\nselect * from GameScore where playScore\n10 and playScore\n=15\n\n\n\n\n如果你想再加个条件：再查询分数为0的数据，可以使用\nor\n查询：\n\n\nselect * from GameScore where playScore\n10 and playScore\n=15 or playScore=5\n\n\n\n\n由于\nand\n的优先级高于\nor\n，因此,上面的查询也可以用括号来明确地表示这种优先级：\n\n\nselect * from GameScore where (playScore\n10 and playScore\n=15) or playScore=5\n\n\n\n\n占位符\n\n\n查询条件\nwhere\n和 \nlimit\n 子句支持占位符，也就是可以用问号 ? 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法。\n\n\n普通查询\n\n\n例如：\n\n\nselect * from GameScore where name=? and playScore\n? limit ?,?\n\n\n\n\n内置函数\n\n\n占位符查询中用到的内置函数，请看最后的 \n占位符查询用到的内置函数\n。\n\n\n例如：\n\n\n\nselect * from GameScore where createdAt \n date(?) and player = pointer(?,?) and gps near geopoint(?,?)\n\n\n\n\n\n注意：\n\n\n和统计查询有关的\ngroup by\n、\norder by\n、\nhaving\n等字句是不支持占位符的。\n\n\n正确\n写法：\n\n\nselect sum(playScore),count(*) from GameScore group by game having _sumPlayScore\n200\n\n\n\n\n错误\n写法：\n\n\nselect sum(playScore),count(*) from GameScore group by ? having ?\n\n\n\n\n注：我们推荐使用占位符的方式来使用 BQL，查询语句可以通过预编译得到缓存，降低 BQL 的转换开销。\n\n\n限定返回值\n\n\n通过 \nlimit\n 语句来限定返回结果大小，比如限定返回 10 个：\n\n\nselect * from GameScore limit 10\n\n\n\n\n可以设定从第\nm+1\n个元素开始，例如从第 11 个元素（包含）开始往后取 10 个：\n\n\nselect * from GameScore limit 10,10\n\n\n\n\n注：如果查询语句没有设定 limit ，默认的 limit 是 100 而且最大的 limit 是 1000。\n\n\n排序\n\n\n通过 \norder\n 语句来排序，\norder\n 语句只能出现在最后，不能在 \nwhere\n 和 \nlimit\n 之前。\n\n\n比如：按照得分降序排列（得分高的在前）：\n\n\nselect * from GameScore order by playScore desc\n\n\n\n\n也可以写成：\n\n\nselect * from GameScore order by -playScore\n\n\n\n\n注：加号表示升序，减号表示降序。\n\n\n多个字段组合排序\n\n\n比如：得分高的在前（playScore降序），当得分一样的情况下，再按照名称（字母顺序）更小的在前（name升序）：\n\n\nselect * from GameScore order by -playScore,name\n\n\n\n\n同样的语句可以写成：\n\n\nselect * from GameScore order by playScore,+name desc\n\n\n\n\n或者\n\n\nselect * from GameScore order by -playScore,name asc\n\n\n\n\n注：没有写上明确的加号或者减号的字段，将根据最后的 desc 或者 asc 来决定采用升序还是降序。\n\n\n统计查询\n\n\n统计查询只适用于 \nNumber\n 类型的列，支持 \nsum\n (计算总和), \naverage\n (计算平均值), \nmax\n (计算最大值), \nmin\n (计算最小值)\n\n\n举几个例子（以sum求和）:\n\n\n计算总和\n\n\n比如：查询\nGameScore\n表所有玩家的得分总和:\n\n\nselect sum(playScore) from GameScore\n\n\n\n\n分组计算总和\n\n\n比如：按玩家分组，获取每个玩家的总得分：\n\n\nselect sum(playScore) from GameScore group by name\n\n\n\n\n添加过滤条件\n\n\n比如 按玩家分组，获取每个玩家的总得分，并且总得分大于100的：\n\n\nselect sum(playScore) from GameScore group by name having _sumPlayScore \n 100\n\n\n\n\n统计分组记录数\n\n\n同时支持返回每个组用于计算总和的总数：\n\n\nselect sum(playScore),count(*) from GameScore group by name having _sumPlayScore \n 100\n\n\n\n\n注：\n\n\n1、查询语句中含有\nsum\n或 \ngroup by\n的时候不支持返回表中的其他列，只返回group by后面接的列名、sum的列名为 \n(_sum+(首字母大写的列名))\n 以及有count(*)会返回的 \n_count\n等数据。所以只应该用于统计的功能时候使用。\n\n\n2、其他关键字和sum的使用类似，只需要以上的\nsum\n换为\naverage\n,\nmax\n, \nmin\n，其中\naverage\n返回的平均值列名为：\n(_avg+(首字母大写的列名))\n。\n\n\n内置函数介绍\n\n\nBQL提供了一些\n内置函数\n来方便地创建 \npointer\n、\ngeopoint\n、\ndate\n、\nfile\n等类型：\n\n\n基本BQL查询用到的内置函数\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ndate('yyyy-MM-dd HH:mm:ss')\n\n\n创建日期类型\n\n\n\n\n\n\npointer(className,objectId)\n\n\n创建 Pointer\n\n\n\n\n\n\ngeopoint(经度，维度)\n\n\n创建 GeoPoint\n\n\n\n\n\n\nfile(filename,url)\n\n\n创建 file 类型\n\n\n\n\n\n\ncurrent_timestamp()\n\n\n创建当前日期\n\n\n\n\n\n\n\n\n\n\n占位符查询用到的内置函数\n\n\n如果使用占位符查询，比较特殊，其内置函数的形式如下\n\n\n\n\n\n\n\n\nKey\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\ndate(?)\n\n\n创建日期类型\n\n\n\n\n\n\npointer(?,?)\n\n\n创建 Pointer\n\n\n\n\n\n\ngeopoint(?,?)\n\n\n创建 GeoPoint\n\n\n\n\n\n\nfile(?,?)\n\n\n创建 file 类型\n\n\n\n\n\n\n\n\n\n\n举例子（以Android为例）：\n\n\n1、Date类型：\n\n\nString dateString = \n2015-05-12\n;  \nSimpleDateFormat sdf = new SimpleDateFormat(\nyyyy-MM-dd\n);\nDate date  = null;\ntry {\n    date = sdf.parse(dateString);\n} catch (ParseException e) {\n}  \nString sql = \nselect * from GameScore where createdAt \n date('\n+new BmobDate(date).getDate()+\n')\n\n\n\n\n\n等价于：（以下是REST API文档中定义的创建\nDate类型\n的JSON对象）\n\n\nselect * from GameScore where createdAt \n {'__type': 'Date','iso': '\n+new BmobDate(date).getDate()+\n'}\n\n\n\n\n2、Pointer类型：\n\n\nUser user = BmobUser.getCurrentUser(this, User.class);\nString sql = select * from GameScore where player = pointer('_User', \n+\n'\n+user.getObjectId()+\n')\n\n\n\n\n\n等价于：（以下是REST API文档中定义的创建\nPointer类型\n的JSON对象）\n\n\nselect * from GameScore where player = {'__type':'Pointer','className':'_User','objectId':'\n+user.getObjectId()+\n'}\n\n\n\n\n3、GeoPoint类型\n\n\nselect * from GameScore where gps = geopoint(112.934755,24.52065)\n\n\n\n\n等价于：（以下是REST API文档中定义的创建\nGeoPoint类型\n的JSON对象）\n\n\nselect * from GameScore where gps = {'__type':'GeoPoint','latitude':24.52065,'longitude':112.934755}\n\n\n\n\n注：\n\n\n1、如果不使用\n内置函数\n，你也使用 \nRest API文档\n定义的 JSON 对象来创建特定类型,不过这样写相对来说比较繁琐。\n\n\n2、占位符查询中如果要用到内置函数，其形式必须为上述列出的，最后的可变参数会自动替换类型中的\n?\n。\n\n\n性能和建议\n\n\nBQL 最终还是转换成 \nRest API文档\n 里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 where 查询慢一点。并且 BQL 对长度有所限制，要求在 4096 字节以内。\n\n\n此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。", 
            "title": "BQL详细指南"
        }, 
        {
            "location": "/index.html#_1", 
            "text": "最基本的一个查询:  查询某个 class 下的 100 条数据：  select * from GameScore  等价于（以 Android 为例）:  //查询GameScore的100条数据\nBmobQuery GameScore  query = new BmobQuery GameScore ();\nquery.findObjects(context, new FindListener GameScore () {\n\n    @Override\n    public void onSuccess(List GameScore  object) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onError(int code, String msg) {\n        // TODO Auto-generated method stub\n    }\n});  select一个完整的语法形式类似这样：  select [查询字段列表，多个以逗号隔开] from [class 名称]\n   [where [条件列表]\n   [limit skip,limit\n   [order by [排序字段列表] [asc |desc]]]]  举例：  \n//查询结果只包含 name,playScore 以及内置字段(objectId,createdAt等)\nselect name,playScore from GameScore\n\n//根据 name 查找\nselect * from GameScore where name='smile'\n\n//根据 name 和 playScore 同时查找\nselect * from GameScore where name is exists and playScore   80 and playScore  = 100\n\n//分页查找，从第 10 条开始向后查找 10 条数据\nselect * from GameScore limit 10,10\n\n//根据 score 和 name 排序\nselect * from GameScore order by -playScore,+name  注：当查询的表为系统表（目前系统表有User、Installation、Role）时，需要带上下划线 _ 。  比如，你想查询的是用户 smile 的信息，则：  \n`select * from _User where username= smile`", 
            "title": "介绍及基本语法"
        }, 
        {
            "location": "/index.html#_2", 
            "text": "", 
            "title": "查询条件"
        }, 
        {
            "location": "/index.html#_3", 
            "text": "查询指定信息的对象，用  =  比较符：  select * from GameScore where name='smile'  查询 不等于 指定信息的对象，用 != 比较符：  select * from GameScore where name!='smile'  也可以用 运算符来表示不等于。  比较日期，使用 date 函数来转换，比如查询特定时间之前创建的对象：  select * from GameScore where createdAt   date('2015-05-20 00:00:00')  date 函数接收的日期格式必须是  yyyy-MM-dd HH:mm:ss 。更多内置函数请看最后的  内置函数 。  一些常见的查询运算符：     Key  Operation  对应Bmob的查询API      =  等于  addWhereEqualTo    != 或者   不等于  addWhereNotEqualTo     小于  addWhereLessThan    =  小于等于  addWhereLessThanOrEqualTo     大于  addWhereGreaterThan    =  大于等于  addWhereGreaterThanOrEqualTo    [not] like  模糊查询  addWhereStartsWith或addWhereEndsWith    [not] regexp  正则匹配  addWhereMatches    [not] in(子查询或者数组)  包含或者不包含  addWhereMatchesQuery或者addWhereDoesNotMatchQuery    is [not] exists  这个Key有值或者不存在值  addWhereExists或addWhereDoesNotExists     注：比较运算符可以用在 日期 、 字符串 、 数字 甚至 对象 上。", 
            "title": "比较查询"
        }, 
        {
            "location": "/index.html#_4", 
            "text": "注:模糊查询只对付费用户开放，付费后可直接使用。  模糊查询可以使用  like ，比如查询名字以 smile 开头的对象  select * from GameScore where name like 'smile%'  % 表示模糊匹配的位置占位符。  like  本质上是转成 regexp 的正则匹配查询，因此上面的例子还可以写成：  select * from GameScore where name regexp 'smile.*'  否定形式，以 not like  来查询名字不以 smile 开头的对象：  select * from GameScore where name not like 'smile%'  等价于 not regexp :  select * from GameScore where name not regexp 'smile.*'", 
            "title": "模糊查询"
        }, 
        {
            "location": "/index.html#_5", 
            "text": "只返回 name 字段值存在的对象：  select * from GameScore where name is exists  反之，使用  is not exists 。", 
            "title": "值是否存在查询"
        }, 
        {
            "location": "/index.html#_6", 
            "text": "假设 hobby 表示一个人的爱好，其字段类型是List 对应服务端的 数组Array 类型，如我们想查询有游泳爱好的人：  select * from Person where hobby ='游泳'   查询既爱好游泳也爱好看书的人：  select * from Person where hobby all ('游泳','看书')  注：all 表示数组完全匹配。", 
            "title": "数组查询"
        }, 
        {
            "location": "/index.html#_7", 
            "text": "1、使用  in 来做子查询，后面跟的可以是一个列表，例如 查询游戏名为地铁跑酷、部落冲突两种游戏的记录：  select * from GameScore where game in ('地铁跑酷','部落冲突')  当然，如果想查询的不在列表里，那可以使用 not in :  select * from GameScore where game not in ('地铁跑酷','部落冲突')  2、 in 后面还可以是一个子查询:  比如：要查询游戏得分大于10的玩家信息  这里需要 username 的值必须要在子查询产生的数组中，因此,我在 GameScore 表中新建了一个 name 字段来表示玩家的姓名  select * from _User where username in (select name from GameScore where playScore 10)  比如：查询年龄大于20的玩家的游戏信息  select * from GameScore where name in (select username from _User where age 20)  3、子查询另一种常见形式：使用 = 或 != 后面跟一条查询语句：  比如：查询游戏得分大于80的玩家  select * from _User where username =(select name from GameScore where playScore 10)\nselect * from _User where username !=(select name from GameScore where playScore =10)  注：子查询的语句也受上限 1000 条记录的限制", 
            "title": "子查询"
        }, 
        {
            "location": "/index.html#_8", 
            "text": "我们可以通过 BQL 进行地理位置查询。", 
            "title": "地理位置查询"
        }, 
        {
            "location": "/index.html#_9", 
            "text": "使用 near 来查询附近的人  比如我想查询指定地理位置附近的玩家（从近到远排序），假设  gps  字段是  BmobGeoPoint 类型：  select * from GameScore where gps near [112.934755,24.52065]  注：[112.934755,24.52065] 是经纬度坐标。必须是经度在前，纬度在后  也可以使用  geopoint  函数来创建：  select * from GameScore where gps near geopoint(112.934755,24.52065)  注：只有在地理位置信息查询里才可以使用  [longitude, latitude] 这样的语法。在其他查询里将被作为数组类型。", 
            "title": "附近的人"
        }, 
        {
            "location": "/index.html#_10", 
            "text": "为了限定搜索的最大距离，还可以使用  max distance 单位 来限定，比如,搜索附近1公里内的人：  select * from GameScore where gps near [112.934755,24.52065] max 1 km  注：单位包括 miles（英里）、radians（弧度），默认是弧度。", 
            "title": "限定搜索范围"
        }, 
        {
            "location": "/index.html#_11", 
            "text": "如果想查询某个矩形框内的对象，可以使用 within [西南坐标] and [东北坐标] 的语法：  select * from GameScore where gps within [102.934755,24.52065] and [112.934755,24.52065]", 
            "title": "查询矩形范围"
        }, 
        {
            "location": "/index.html#_12", 
            "text": "使用  count  查询来返回符合查询条件的数目。  比如:查询整张表的记录数：  select count(*) from GameScore  注：count 不支持distinct等语法。仅限count(*)和count(objectId)  查询总的记录数并返回得分在10-20之间的游戏分数信息  select count(*) from GameScore where playScore 10 and where playScore 20  查询个数的同时可以返回对象,使用 , 隔开：  select count(*),* from GameScore  也可以返回特定的字段：  比如：查询GameScore表中的总数并返回每条记录的游戏名  select count(*),game from GameScore", 
            "title": "查询个数"
        }, 
        {
            "location": "/index.html#_13", 
            "text": "有如下几种方式来查询对象之间的关系数据   1、如果您想获取对象，而这个对象的一个字段对应了另一个对象, 您可以用一个  where  查询, 自己构造一个  Pointer  函数, 和其他数据类型一样。  例如：  Weibo 类中有一个 User （继承自BmobUser）类型的 author 字段表示这条微博的发送方，现在你想查询当前用户发布的所有微博信息，那么可以这样写：  select include author,* from Weibo where author = pointer('_User', '6720c14c28')  pointer 内置函数接收 className 和 objectId。  2、如果您想获取对象, 这个对象的一个字段指向的对象（必须是BmobPointer类型）是符合另一个查询的, 您可以使用 in 查询。  例如, 假设您有一个  Weibo  类和一个  Comment  类, 每个 Comment  都有一个指向它的  Weibo  的 weibo字段（BmobPointer类型）, 现在您想查询带有图片的  Weibo  的 Comment列表:  select * from Comment where weibo in (select * from Weibo where image is exists)  注:默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。  3、如果  Weibo  类下有一个 BmobRelation 类型的 comment 字段，它存储了这条微博所有的评论列表。你可以查询到这些评论信息，因为他们都关联到了同一条微博：  select * from Comment where related comment to pointer('Weibo', '262f6ace1a')  基本的查询形式是  releated  key  to  pointer 。  4、如果某个字段是 Pointer ，默认查询的时候，只会返回 {__type: 'Pointer', objectId: 'xxxxxx', className:'Weibo'} 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用 include 。  1）、采用  include  key  就可以将某个  Pointer 字段关联查询出来：  比如查询  Comment  同时将  author 带下来：  select include author, * from Comment  2）、 多个字段要多次 include :  select include weibo,include author from Comment  3）、还可以支持 嵌套的 include 查询 ：  比如  Weibo  里还有一个 Pointer 指向 author(表示这条微博是谁发的):  select include weibo.author,* from Comment", 
            "title": "关系查询"
        }, 
        {
            "location": "/index.html#_14", 
            "text": "使用  and  和  or 进行复合查询  比如：查询游戏得分在10-15之间的数据,可以使用 and 查询:  select * from GameScore where playScore 10 and playScore =15  如果你想再加个条件：再查询分数为0的数据，可以使用 or 查询：  select * from GameScore where playScore 10 and playScore =15 or playScore=5  由于 and 的优先级高于 or ，因此,上面的查询也可以用括号来明确地表示这种优先级：  select * from GameScore where (playScore 10 and playScore =15) or playScore=5", 
            "title": "复合查询"
        }, 
        {
            "location": "/index.html#_15", 
            "text": "查询条件 where 和  limit  子句支持占位符，也就是可以用问号 ? 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法。", 
            "title": "占位符"
        }, 
        {
            "location": "/index.html#_16", 
            "text": "例如：  select * from GameScore where name=? and playScore ? limit ?,?", 
            "title": "普通查询"
        }, 
        {
            "location": "/index.html#_17", 
            "text": "占位符查询中用到的内置函数，请看最后的  占位符查询用到的内置函数 。  例如：  \nselect * from GameScore where createdAt   date(?) and player = pointer(?,?) and gps near geopoint(?,?)  注意：  和统计查询有关的 group by 、 order by 、 having 等字句是不支持占位符的。  正确 写法：  select sum(playScore),count(*) from GameScore group by game having _sumPlayScore 200  错误 写法：  select sum(playScore),count(*) from GameScore group by ? having ?  注：我们推荐使用占位符的方式来使用 BQL，查询语句可以通过预编译得到缓存，降低 BQL 的转换开销。", 
            "title": "内置函数"
        }, 
        {
            "location": "/index.html#_18", 
            "text": "通过  limit  语句来限定返回结果大小，比如限定返回 10 个：  select * from GameScore limit 10  可以设定从第 m+1 个元素开始，例如从第 11 个元素（包含）开始往后取 10 个：  select * from GameScore limit 10,10  注：如果查询语句没有设定 limit ，默认的 limit 是 100 而且最大的 limit 是 1000。", 
            "title": "限定返回值"
        }, 
        {
            "location": "/index.html#_19", 
            "text": "通过  order  语句来排序， order  语句只能出现在最后，不能在  where  和  limit  之前。  比如：按照得分降序排列（得分高的在前）：  select * from GameScore order by playScore desc  也可以写成：  select * from GameScore order by -playScore  注：加号表示升序，减号表示降序。  多个字段组合排序  比如：得分高的在前（playScore降序），当得分一样的情况下，再按照名称（字母顺序）更小的在前（name升序）：  select * from GameScore order by -playScore,name  同样的语句可以写成：  select * from GameScore order by playScore,+name desc  或者  select * from GameScore order by -playScore,name asc  注：没有写上明确的加号或者减号的字段，将根据最后的 desc 或者 asc 来决定采用升序还是降序。", 
            "title": "排序"
        }, 
        {
            "location": "/index.html#_20", 
            "text": "统计查询只适用于  Number  类型的列，支持  sum  (计算总和),  average  (计算平均值),  max  (计算最大值),  min  (计算最小值)  举几个例子（以sum求和）:", 
            "title": "统计查询"
        }, 
        {
            "location": "/index.html#_21", 
            "text": "比如：查询 GameScore 表所有玩家的得分总和:  select sum(playScore) from GameScore", 
            "title": "计算总和"
        }, 
        {
            "location": "/index.html#_22", 
            "text": "比如：按玩家分组，获取每个玩家的总得分：  select sum(playScore) from GameScore group by name", 
            "title": "分组计算总和"
        }, 
        {
            "location": "/index.html#_23", 
            "text": "比如 按玩家分组，获取每个玩家的总得分，并且总得分大于100的：  select sum(playScore) from GameScore group by name having _sumPlayScore   100", 
            "title": "添加过滤条件"
        }, 
        {
            "location": "/index.html#_24", 
            "text": "同时支持返回每个组用于计算总和的总数：  select sum(playScore),count(*) from GameScore group by name having _sumPlayScore   100  注：  1、查询语句中含有 sum 或  group by 的时候不支持返回表中的其他列，只返回group by后面接的列名、sum的列名为  (_sum+(首字母大写的列名))  以及有count(*)会返回的  _count 等数据。所以只应该用于统计的功能时候使用。  2、其他关键字和sum的使用类似，只需要以上的 sum 换为 average , max ,  min ，其中 average 返回的平均值列名为： (_avg+(首字母大写的列名)) 。", 
            "title": "统计分组记录数"
        }, 
        {
            "location": "/index.html#_25", 
            "text": "BQL提供了一些 内置函数 来方便地创建  pointer 、 geopoint 、 date 、 file 等类型：", 
            "title": "内置函数介绍"
        }, 
        {
            "location": "/index.html#bql", 
            "text": "Key  Operation      date('yyyy-MM-dd HH:mm:ss')  创建日期类型    pointer(className,objectId)  创建 Pointer    geopoint(经度，维度)  创建 GeoPoint    file(filename,url)  创建 file 类型    current_timestamp()  创建当前日期", 
            "title": "基本BQL查询用到的内置函数"
        }, 
        {
            "location": "/index.html#_26", 
            "text": "如果使用占位符查询，比较特殊，其内置函数的形式如下     Key  Operation      date(?)  创建日期类型    pointer(?,?)  创建 Pointer    geopoint(?,?)  创建 GeoPoint    file(?,?)  创建 file 类型      举例子（以Android为例）：  1、Date类型：  String dateString =  2015-05-12 ;  \nSimpleDateFormat sdf = new SimpleDateFormat( yyyy-MM-dd );\nDate date  = null;\ntry {\n    date = sdf.parse(dateString);\n} catch (ParseException e) {\n}  \nString sql =  select * from GameScore where createdAt   date(' +new BmobDate(date).getDate()+ ')   等价于：（以下是REST API文档中定义的创建 Date类型 的JSON对象）  select * from GameScore where createdAt   {'__type': 'Date','iso': ' +new BmobDate(date).getDate()+ '}  2、Pointer类型：  User user = BmobUser.getCurrentUser(this, User.class);\nString sql = select * from GameScore where player = pointer('_User',  + ' +user.getObjectId()+ ')  等价于：（以下是REST API文档中定义的创建 Pointer类型 的JSON对象）  select * from GameScore where player = {'__type':'Pointer','className':'_User','objectId':' +user.getObjectId()+ '}  3、GeoPoint类型  select * from GameScore where gps = geopoint(112.934755,24.52065)  等价于：（以下是REST API文档中定义的创建 GeoPoint类型 的JSON对象）  select * from GameScore where gps = {'__type':'GeoPoint','latitude':24.52065,'longitude':112.934755}  注：  1、如果不使用 内置函数 ，你也使用  Rest API文档 定义的 JSON 对象来创建特定类型,不过这样写相对来说比较繁琐。  2、占位符查询中如果要用到内置函数，其形式必须为上述列出的，最后的可变参数会自动替换类型中的 ? 。", 
            "title": "占位符查询用到的内置函数"
        }, 
        {
            "location": "/index.html#_27", 
            "text": "BQL 最终还是转换成  Rest API文档  里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 where 查询慢一点。并且 BQL 对长度有所限制，要求在 4096 字节以内。  此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。", 
            "title": "性能和建议"
        }
    ]
}