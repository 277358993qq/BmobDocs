{
    "docs": [
        {
            "location": "/index.html", 
            "text": "注册Bmob帐号\n\n\n在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。\n\n\n\n\n网站后台创建应用\n\n\n登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。\n\n\n\n\n获取应用密钥和下载SDK\n\n\n选择你要开发的应用，进入该应用\n\n\n\n\n在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID\n\n\n\n\n获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。\n\n\n\n\n创建云端逻辑\n\n\n在Bmob后台中，选择你刚刚创建好的应用，然后依次点击“云端逻辑-\n添加方法”，在弹出窗口中输入云端逻辑的方法名，该方法名将会在SDK调用时使用到。如下图所示：\n\n\n\n\n\n\n接着，你就可以在云端逻辑的编辑器中撰写云端逻辑了。如果你熟悉js脚本语言的话，撰写云端逻辑非常简单，你只需要在onRequest方法中补充你的业务逻辑代码就可以了。onRequest方法包含3个参数，分别是request（请求对象，可以从中获取SDK上传的参数）, response（回应对象，可以将云端逻辑的执行结果返回到SDK中）, modules（可调用的模块，包含数据库对象、HTTP对象等）。为方便演示，这里简单实现一个功能：接收客户端上传上来的name参数，根据name的值返回不同的结果。代码如下：\n\n\nfunction onRequest(request, response, modules) {\n  //获取SDK客户端上传的name参数\n  var name = request.body.name;\n    if(name == 'bmob')\n      response.end('欢迎使用Bmob');\n    else\n      response.end('输入错误，请重新输入');\n}                         \n\n\n\n\n安装和初始化BmobSDK\n\n\n云端逻辑的调用执行可以是在云端（通过“定时任务”模块去设置执行，实现定时业务逻辑计算的功能，如排行榜，这个操作非常简单，这里不再一一介绍），但更多的开发者是通过SDK调用的方式来执行云端逻辑。这有点像存储过程，大家可以将更多的业务逻辑放在云端，可以随意改变，不需要更新应用，也不需要上传太多的数据参数。\n\n\n安装和初始化SDK的过程大家根据各自的平台（\nAndroid\n / \niOS\n等）具体参考快速入门文档即可。\n\n\n调用云端逻辑\n\n\n将如下的代码根据各自平台，插入到触发执行的方法里面。\n\n\nAndroid调用云端逻辑\n\n\n//test对应你刚刚创建的云端逻辑名称\nString cloudCodeName = \ntest\n;\nJSONObject params = new JSONObject();\n//name是上传到云端的参数名称，值是bmob，云端逻辑可以通过调用request.body.name获取这个值 \nparams.put(\nname\n, \nbmob\n);\n//创建云端逻辑对象\nAsyncCustomEndpoints cloudCode = new AsyncCustomEndpoints();\n//异步调用云端逻辑\ncloudCode.callEndpoint(MainActivity.this, cloudCodeName, params, new CloudCodeListener() {\n\n    //执行成功时调用，返回result对象\n    @Override\n    public void onSuccess(Object result) {\n        Log.i(\nbmob\n, \nresult = \n+result.toString());\n    }\n\n    //执行失败时调用\n    @Override\n    public void onFailure(String err) {\n        Log.i(\nbmob\n, \nBmobException = \n+err);\n    }\n});\n\n\n\n\niOS调用云端逻辑\n\n\n    //name是上传到云端的参数名称，值是bmob，云端逻辑可以通过调用request.body.name获取这个值 \n    NSDictionary  *dic = [NSDictionary  dictionaryWithObject:@\nbmob\n forKey:@\nname\n];\n    //test对应你刚刚创建的云端逻辑名称\n    [BmobCloud callFunctionInBackground:@\ntest\n withParameters:dic block:^(id object, NSError *error) {\n\n    if (!error) {\n        //执行成功时调用\n        NSLog(@\nerror %@\n,[object description]);\n    }else{\n       //执行失败时调用\n        NSLog(@\nerror %@\n,[error description]);\n    }\n\n    }] ;\n\n\n\n\n源码下载\n\n\niOS源码下载\n\n\nAndroid源码下载", 
            "title": "快速入门"
        }, 
        {
            "location": "/index.html#bmob", 
            "text": "在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。", 
            "title": "注册Bmob帐号"
        }, 
        {
            "location": "/index.html#_1", 
            "text": "登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。", 
            "title": "网站后台创建应用"
        }, 
        {
            "location": "/index.html#sdk", 
            "text": "选择你要开发的应用，进入该应用   在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID   获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。", 
            "title": "获取应用密钥和下载SDK"
        }, 
        {
            "location": "/index.html#_2", 
            "text": "在Bmob后台中，选择你刚刚创建好的应用，然后依次点击“云端逻辑- 添加方法”，在弹出窗口中输入云端逻辑的方法名，该方法名将会在SDK调用时使用到。如下图所示：    接着，你就可以在云端逻辑的编辑器中撰写云端逻辑了。如果你熟悉js脚本语言的话，撰写云端逻辑非常简单，你只需要在onRequest方法中补充你的业务逻辑代码就可以了。onRequest方法包含3个参数，分别是request（请求对象，可以从中获取SDK上传的参数）, response（回应对象，可以将云端逻辑的执行结果返回到SDK中）, modules（可调用的模块，包含数据库对象、HTTP对象等）。为方便演示，这里简单实现一个功能：接收客户端上传上来的name参数，根据name的值返回不同的结果。代码如下：  function onRequest(request, response, modules) {\n  //获取SDK客户端上传的name参数\n  var name = request.body.name;\n    if(name == 'bmob')\n      response.end('欢迎使用Bmob');\n    else\n      response.end('输入错误，请重新输入');\n}", 
            "title": "创建云端逻辑"
        }, 
        {
            "location": "/index.html#bmobsdk", 
            "text": "云端逻辑的调用执行可以是在云端（通过“定时任务”模块去设置执行，实现定时业务逻辑计算的功能，如排行榜，这个操作非常简单，这里不再一一介绍），但更多的开发者是通过SDK调用的方式来执行云端逻辑。这有点像存储过程，大家可以将更多的业务逻辑放在云端，可以随意改变，不需要更新应用，也不需要上传太多的数据参数。  安装和初始化SDK的过程大家根据各自的平台（ Android  /  iOS 等）具体参考快速入门文档即可。", 
            "title": "安装和初始化BmobSDK"
        }, 
        {
            "location": "/index.html#_3", 
            "text": "将如下的代码根据各自平台，插入到触发执行的方法里面。", 
            "title": "调用云端逻辑"
        }, 
        {
            "location": "/index.html#android", 
            "text": "//test对应你刚刚创建的云端逻辑名称\nString cloudCodeName =  test ;\nJSONObject params = new JSONObject();\n//name是上传到云端的参数名称，值是bmob，云端逻辑可以通过调用request.body.name获取这个值 \nparams.put( name ,  bmob );\n//创建云端逻辑对象\nAsyncCustomEndpoints cloudCode = new AsyncCustomEndpoints();\n//异步调用云端逻辑\ncloudCode.callEndpoint(MainActivity.this, cloudCodeName, params, new CloudCodeListener() {\n\n    //执行成功时调用，返回result对象\n    @Override\n    public void onSuccess(Object result) {\n        Log.i( bmob ,  result =  +result.toString());\n    }\n\n    //执行失败时调用\n    @Override\n    public void onFailure(String err) {\n        Log.i( bmob ,  BmobException =  +err);\n    }\n});", 
            "title": "Android调用云端逻辑"
        }, 
        {
            "location": "/index.html#ios", 
            "text": "//name是上传到云端的参数名称，值是bmob，云端逻辑可以通过调用request.body.name获取这个值 \n    NSDictionary  *dic = [NSDictionary  dictionaryWithObject:@ bmob  forKey:@ name ];\n    //test对应你刚刚创建的云端逻辑名称\n    [BmobCloud callFunctionInBackground:@ test  withParameters:dic block:^(id object, NSError *error) {\n\n    if (!error) {\n        //执行成功时调用\n        NSLog(@ error %@ ,[object description]);\n    }else{\n       //执行失败时调用\n        NSLog(@ error %@ ,[error description]);\n    }\n\n    }] ;", 
            "title": "iOS调用云端逻辑"
        }, 
        {
            "location": "/index.html#_4", 
            "text": "iOS源码下载  Android源码下载", 
            "title": "源码下载"
        }, 
        {
            "location": "/module/develop_doc/README/index.html", 
            "text": "简介\n\n\nBmob旨在让移动开发变得更简单。对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob云端逻辑提供了这种灵活性，可以让您的代码直接在Bmob云上运行。一旦你在云端更新了代码，所有的移动应用都会立即自动更新，新功能的发布将会变得更加简单可控。\n\n\n开源案例\n\n\n为方便大家更好的使用云端逻辑，Bmob为大家提供了一些常用模块，方便大家直接拿来使用的。\n\n\n\n\n\n\n对整个表进行排序：\nhttps://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order1.js\n 可结合定时任务使用\n\n\n\n\n\n\n获取某行数据对应排行的信息： \nhttps://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order2.js\n\n\n\n\n\n\n获取前N名数据排行信息：\nhttps://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order3.js\n\n\n\n\n\n\n在开发云端逻辑时，希望大家能够先看看我们提供的编码规范文档：\nhttp://docs.bmob.cn/cloudcode/WEB/f_codehelp/doc/index.html\n\n\n调用云端逻辑的方式\n\n\nbmob允许以http的方式直接调用云端逻辑。\n\n\n获取Secret Key\n\n\n用户需要以http的方式运行云端逻辑，需要先确定应用的Secret Key。 调用云端逻辑时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台-\n应用密钥-\nSecret Key, 如下图所示：\n\n\n\n注意：请妥善保管Secret Key，避免Secret Key的泄露！！！\n\n\n以Get的方式调用云端逻辑\n\n\n下面展示了以Get的方式调用云端逻辑：\n\n\ncurl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff\n\n\n\n\n其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云端逻辑的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。\n\n\n以Post的方式调用云端逻辑\n\n\n下面展示了以Post的方式调用云端逻辑：\n\n\ncurl -X POST \\\n    -H \nContent-Type: application/x-www-form-urlencoded\n \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test\n\n\n\n\n其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云端逻辑的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。\n\n\n转为套餐后调用云端逻辑的方式\n\n\n注意：升级云端代码套餐后就没法在微信公众号中调用云端代码\n\n\nbmob允许以http的方式直接调用云端逻辑。\n\n\n获取应用的id值\n\n\n进入应用后台-\n云逻辑，下图中的箭头所指的数字就是该应用的id值：\n\n\n\nGet的方式调用云端逻辑\n\n\n下面展示了以Get的方式调用云端逻辑：\n\n\ncurl -X GET http://cloud-xxxxx.bmobapp.com/test?name=jeff\n\n\n\n\n其中：\ncloud-xxxxx.bmobapp.com：该应用的云端代码专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云端逻辑的名称。\nname=jeff: 传入一个参数，名称是name，值是jeff。\n与restful不同，无需再传其它诸如app id等请求头。\n\n\nPost的方式调用云端逻辑\n\n\n下面展示了以Post的方式调用云端逻辑：\n\n\ncurl -X POST \\\n    -H \nContent-Type: application/x-www-form-urlencoded\n \\\n    -d 'name=jeff' \\\n    http://cloud-xxxxx.bmobapp.com/test\n\n\n\n\n其中：\ncloud-xxxxx.bmobapp.com：该应用的云端代码专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云端逻辑的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。\n\n\n云端逻辑模块解释\n\n\n从云端逻辑的入口方法function onRequest(request, response, modules)可知，云端逻辑包含三个模块，分别是request模块、response模块和modules模块。\n\n\nrequest模块\n\n\nrequest模块用于获取传入的参数。由于现在调用云端逻辑有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。\n\n\n注意，当通过android，ios等客户端sdk调用云端逻辑，或者通过restful api的方式调用云端逻辑，都是采用post的方式。\n\n\nget方式\n\n\n用get方式调用云端逻辑，例如：\n\n\ncurl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff\n\n\n\n\n可用下面的方法获取name的值：\n\n\nrequest.query.name\n\n\n\n\npost方式\n\n\n用post方式调用云端逻辑，例如：\n\n\ncurl -X POST \\\n    -H \nContent-Type: application/x-www-form-urlencoded\n \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test\n\n\n\n\n可用下面的方法获取name的值：\n\n\nrequest.body.name\n\n\n\n\n获取调用云端逻辑的http方式\n\n\n当云端逻辑是用于某些平台的回调时，同一段云端逻辑可能有时是采用get的方式调用，有时是采用post的方式调用, 可用下面的方法获取当前云端逻辑是采用get还是post方式调用。\n\n\n例子如下：\n\n\n    var httptype = request.method;　//获取调用云端逻辑的是post或者get方式\n    if (\nGET\n == httptype) {\n        //采用get方式调用云端逻辑\n    }else{\n        //采用post方式调用云端逻辑\n    }\n\n\n\n\n\nresponse模块\n\n\nresponse为云端逻辑的信息回传模块，该模块包含了一个send方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：\n\n\nresponse.send(string result)\n\n\n\n\nmodules模块\n\n\nmodules是Bmob云端逻辑提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云端逻辑对象（oFunctions）、邮件发送对象（oMail）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云端逻辑想要调用这些对象时，只需要用如下的方法即可获取：\n\n\n  //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作\n\n\n\n\n 这里需要说明一点的是：云端逻辑对数据格式的封装遵循RestApi的规则，如果在查看过程中有什么疑问，请移步到\nRestApi开发文档\n。 \n\n\n数据库对象\n\n\n数据库操作的简单实例如下：\n\n\nfunction onRequest(request, response, modules) {\n  //获取数据库对象\n  var db = modules.oData;\n  //获取Posts表中的所有值\n  db.find({\n    \ntable\n:\nPosts\n,\n  },function(err,data){\n    response.send(data);\n  });\n}\n\n\n\n\n其中，Posts是查找的数据表名称，table是关键词。\n\n\n需要注意的是，Bmob云端逻辑底层采用Nodejs进行开发，继承了Nodejs的异步非阻塞事件驱动模式，因此也不可避免的需要大量使用回调方法，这些方法往往以非显式声明的闭包形式存在。\n\n\n此外，通过oData数据库对象获取返回的回调接口中，所有的data数据都是string类型，如果需要在云端中作为对象类型调用的话，需要将string类型转换为object类型，即：\n\n\n    var dataObject= JSON.parse(data);\n\n\n\n\noData对象的其他操作方法如下：\n\n\n查询多条数据\n\n\nfind({\n  \ntable\n:\nXXX\n,          //表名\n  \nkeys\n:\na,b,c\n,         //返回字段列表，多个字段用,分隔\n  \nwhere\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n},       //查询条件是一个JSON object\n  \norder\n:\n-a,b\n,         //排序列表，[-]字段名称,-表示降序，默认为升序\n  \nlimit\n:10,            //limit大小，一页返回多少条记录，默认为0\n  \nskip\n:2,             //skip,分页offset，(page-1)*limit\n  \ncount\n:1            //count,只返回符合条件的记录总数\n },function(err,data){    //回调函数\n });\n\n\n\n\n以下是读取Games表（包含name字段）的数据，并对这些数据进行遍历，将name字段连接起来的一段代码样例：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.find({\n    \ntable\n:\nGames\n\n  },function(err,data){ \n  //将返回结果转换为Json对象\n  var resultObject= JSON.parse(data);\n  //遍历这个Json对象\n  for(var results in resultObject)\n  {\n    var resultArr = resultObject[results];\n    var str =\n \n;\n    //遍历得到的每行结果\n    for(var oneline in resultArr){\n      str =str +\n \n + resultArr[oneline].name;\n    }\n    response.send(str);\n  }\n});\n}\n\n\n\n\n查询单条数据\n\n\nfindOne({\n  \ntable\n:\nXXX\n,             //表名\n  \nobjectId\n:\nXXXX\n         //记录的objectId\n},function(err,data){         //回调函数\n});\n\n\n\n\n需要注意的是：\n\n1. 为确保User表的安全性，findOne方法不能直接操作User表。\n2. find方法返回的data是字符串类型，如果需要直接对象化调用的话，需要将string类型转换为object类型，即如下，从_User表中查找objectId=YIuNDDDO的数据，并把username信息显示出来：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n    \ntable\n:\n_User\n,\n    \nobjectId\n:\nYIuNDDDO\n\n  },function(err,data){ \n    var dataObject= JSON.parse(data);\n    response.send(\n获取用户名信息为： \n + dataObject.username);\n  });\n}\n\n\n\n\n获取表的记录数\n\n\nfunction onRequest(request, response, modules) {\n    var db = modules.oData;\n    //获取表\nGameScore\n的总记录数\n    db.find({\n      \ntable\n:\nGameScore\n,\n      \nlimit\n:0,\n      \ncount\n:1 \n    },function(err,data){     \n\n        resultObject= JSON.parse(data);\n        count=resultObject.count;\n        response.send(\n表记录数:\n+count);\n\n    });     \n}                                                    \n\n\n\n\n其中，\ncount\n为标识位，具体原因大家可以参考Restapi说明文档：\nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询结果计数\n。\n\n\n修改数据\n\n\nupdate({\n  \ntable\n:\nXXX\n,             //表名\n  \nobjectId\n:\nXXXX\n,        //记录的objectId\n  \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}           //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});\n\n\n\n\n以下是一个更新数据的示例代码，实现的效果是从Games表中找到objectId=hmw9888C的数据，将其name数据改为pingpang games。\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.update({\n    \ntable\n:\nGames\n,\n    \nobjectId\n:\nhmw9888C\n,\n    \ndata\n:{\nname\n:\npingpang games\n}\n  },function(err,data){ \n    response.send(\nsuccess\n);\n  });\n}\n\n\n\n\n添加数据\n\n\ninsert({\n  \ntable\n:\nXXX\n,             //表名\n  \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}            //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});\n\n\n\n\n删除数据\n\n\nremove({\n  \ntable\n:\nXXX\n,             //表名\n  \nobjectId\n:\nXXXX\n        //记录的objectId\n},function(err,data){         //回调函数\n});\n\n\n\n\n用户注册\n\n\nuserSignUp({\n  \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}             //用户注册的信息，格式为JSON\n},function(err,data){         //回调函数\n});\n\n\n\n\n用户登录\n\n\nuserLogin({\n  \nusername\n:\naa\n,            //登录用户名\n  \npassword\n:\n              //用户密码\n},function(err,data){         //回调函数\n});\n\n\n\n\n用户密码重置\n\n\nuserRestPassword({\n  \ndata\n:{\nemail\n:\nXX@XX.com\n}      //需要重置密码的用户邮件账号\n},function(err,data){         //回调函数\n});\n\n\n\n\n获取某一用户记录\n\n\ngetUserByObjectId({\n  \nobjectId\n:\nXXXX\n          //记录的objectId\n},function(err,data){         //回调函数\n});\n\n\n\n\n更新某一用户记录\n\n\n说明：必须先登录才能更新，切记！！！否则会报sessionToken error\n\n\nupdateUserByObjectId({\n      \nobjectId\n:\nXXXX\n,        //记录的objectId\n      \ndata\n:{\na\n:\nXXXX\n,\nb\n:\nXXXX\n}           //需要更新的数据，格式为JSON\n    },function(err,data){         //回调函数\n});\n\n\n\n\n以下是更新用户信息的示例代码：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.userLogin({\n    \nusername\n:\n123567\n,\n    \npassword\n:\n123\n\n  },function(err, data){\n    if(data){\n      var dataObject = JSON.parse(data);\n      if(dataObject.error == null){\n        //需要设置登录之后获取的sessionToken头信息\n        db.setHeader({\nX-Bmob-Session-Token\n:dataObject.sessionToken});\n        db.updateUserByObjectId({\nobjectId\n:dataObject.objectId ,data:{\nusername\n:\n123\n}},function(err,data){\n          response.send(\n更新成功\n);\n      })\n    }else{\n      response.send(\n找不到该用户！\n);\n    }\n  }\n}); \n} \n\n\n\n\n获得所有用户信息\n\n\ngetAllUser(function(err,data){         //回调函数\n});\n\n\n\n\n删除某一个指定用户\n\n\n说明：必须登录才行，切记！！！否则会报sessionToken error\n\n\nremoveUserByObjectId({\n      \nobjectId\n:\nXXXX\n        //记录的objectId\n    },function(err,data){         //回调函数\n});\n\n\n\n\n邮箱验证\n\n\n发送给用户的邮箱验证的邮件会在一周内失效，可以通过下面的方法来强制重新发送\n\n\nrequestEmailVerify({\n      \ndata\n:{\nemail\n:\ncoolguy@iloveapps.com\n}\n  },function(err,data){ \n    //回调函数\n  });\n\n\n\n\n这里有一个小技巧分享给大家，有时候你会希望能够用Master Key（Bmob给大家提供的超级权限，可以对数据进行任何操作）对数据进行操作，包括不需要用户登录就可以修改用户信息等。那么你只需要在对数据进行操作前，通过db.setHeader方法设置下Master Key头信息即可，如下：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.setHeader({\nX-Bmob-Master-Key\n:\n这里填写Master Key信息\n});\n  db.updateUserByObjectId({\nobjectId\n:\n这里是需要更新的用户ObjectId信息\n ,data:{\nusername\n:\n123\n}},function(err,data){\n    response.send(\n更新成功\n);\n  }); \n} \n\n\n\n\n文件对象\n\n\n云端逻辑只支持文件的删除操作。删除文件，必须要知道文件的组名和url，示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n\n  var file = modules.oFile;\n\n  file.del({\n    \ngroup\n:\ngroup1\n,\n    \nurl\n:\nM00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html\n\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n在上面的例子中，group1是组名，M00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html是url。\n\n\n返回结果是个json对象：\n\n\n{\n  \nmsg\n: \ndelete file success\n\n}\n\n\n\n\n云端逻辑对象\n\n\n在云端逻辑中可以调用本app的其它云端逻辑，示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n       \nname\n: \ntest\n,\n       \ndata\n:{\ncontent\n:\n你好\n,\naddress\n:\nguangzhou\n}\n    },function(err,data){\n       //回调函数\n    });\n}\n\n\n\n\n在上面的例子中，\nname\n是云端逻辑的函数名，\ndata\n中是传递的参数\n\n\n如果不需要传递任何参数，可以用下面的实例代码：\n\n\nfunction onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n       \nname\n: \ntest\n\n    },function(err,data){\n       //回调函数\n    });\n}\n\n\n\n\n地理位置对象\n\n\nBmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。您可以实现轻松查找出离当前用户最接近的信息或地点的功能。\n\n\n创建地理位置\n\n\n创建地理位置的示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n\n  var location = modules.oLocation;\n\n  location.create({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nlocation\n:{            \n            \n__type\n: \nGeoPoint\n,\n            \nlatitude\n:  12.934755,\n            \nlongitude\n: 24.52065\n        }}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n查询地理位置\n\n\n现在您有一系列的对象对应的地理坐标，如果能发现那些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。获取离用户最近的10个地点的实现代码如下：\n\n\n  location.query({\n    \ntable\n:\nGameScore\n,\n    \nlimit\n:10,\n    \nwhere\n:{\n        \nlocation\n: {\n            \n$nearSphere\n: {\n                \n__type\n: \nGeoPoint\n,\n                \nlatitude\n: 30.0,\n                \nlongitude\n: 20.0\n            }\n          }\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n这会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数给了的话，它会覆盖按距离排序)，例如，下面是两个上面的查询返回的结果：\n\n\n{\n    \nresults\n: [\n    {\n        \nlocation\n: {\n             \n__type\n: \nGeoPoint\n,\n            \nlatitude\n: 40.0,\n            \nlongitude\n: -30.0\n        },\n        \nupdatedAt\n: \n2011-12-06 22:36:04\n,\n        \ncreatedAt\n: \n2011-12-06 22:36:04\n,\n        \nobjectId\n: \ne1kXT22L\n\n        },\n        {\n        \nlocation\n: {\n             \n__type\n: \nGeoPoint\n,\n             \nlatitude\n: 30.0,\n             \nlongitude\n: 20.0\n        },\n        \nupdatedAt\n: \n2011-12-06 22:36:26\n,\n        \ncreatedAt\n: \n2011-12-06 22:36:26\n,\n        \nobjectId\n: \n51e3a2a8e4b015ead4d95dd9\n\n        }\n    ]\n}\n\n\n\n\n为了限定搜素的最大举例，需要加入$maxDistanceInMiles和$maxDistanceInKilometers或者$maxDistanceInRadians参数来限定。如果不加，则默认是100KM的半径。如，要找半径在10公里内的数据的实现代码如下：\n\n\n  location.query({\n    \ntable\n:\nGameScore\n,\n    \nlimit\n:10,\n    \nwhere\n:{\n        \nlocation\n: {\n            \n$nearSphere\n: {\n                \n__type\n: \nGeoPoint\n,\n                \nlatitude\n: 30.0,\n                \nlongitude\n: 20.0\n            },\n        \n$maxDistanceInKilometers\n: 10.0\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n同样做查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形的区域里的对象，按下面的格式加入一个约束 {\"$within\": {\"$box\": {[southwestGeoPoint, northeastGeoPoint]}}}，下面是一段示例代码：\n\n\n  location.query({\n    \ntable\n:\nGameScore\n,\n    \nlimit\n:10,\n    \nwhere\n:{\n        \nlocation\n: {\n            \n$within\n: {\n                \n$box\n: [\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 37.71,\n                        \nlongitude\n: 22.53\n                    },\n                    {\n                        \n__type\n: \nGeoPoint\n,\n                        \nlatitude\n: 30.82,\n                        \nlongitude\n: 22.37\n                    }\n                ]\n            }\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n关联关系对象\n\n\n一个对象可以与其他对象相联系。就像数据库中的主外键关系一样，数据表 A 的某一个字段是数据表 B 的外键，只有表 B 中存在的数据才可插入进表 A 中的字段。 \n\n\n添加关联关系\n\n\n为了更新 \nPointer\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一行记录时并添加一个指针：\n\n\nfunction onRequest(request, response, modules) {\n\n  var rel = modules.oRelation;\n  rel.add({\n    \ntable\n:\nGameScore\n,\n    \ndata\n:{\ngame\n:{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n}}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n为了更新 \nRelation\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加一行记录时并添加多个关系:\n\n\n  rel.add({\n    \ntable\n:\nGameScore\n,\n    \ndata\n:{\ngamerel\n:{\n__op\n:\nAddRelation\n,\nobjects\n:[{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n},{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\n80SLHHHj\n}]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n修改关联对象\n\n\n为了更新 \nPointer\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一个指针:\n\n\n  rel.update({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\n8106dc7c9e\n,\n    \ndata\n:{\ngame\n:{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\n80SLHHHj\n}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n为了更新 \nRelation\n 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加多个关系:\n\n\n  rel.update({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\n8106dc7c9e\n,\n    \ndata\n:{\ngamerel\n:{\n__op\n:\nAddRelation\n,\nobjects\n:[{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n}]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n查询关联对象\n\n\n有几种方式来对关系 \nRelation\n 或 指针 \nPointer\n 类型数据进行查询, 如果您将要获取对象中有个Key类型是关系 \nRelation\n 或 指针 \nPointer\n，这都说明你要获取的对象是匹配到另一个特殊（关联或指向）的对象的, 您可以用一个 \nwhere\n 参数查询, 自己使用 \n__type\n 构造一个 \nPointer\n, 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论:\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\npost\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\nl4fQ999O\n}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n如果您想要获取对象, 这些对象的一个字段指向的对象是符合另一个查询的, 您可以使用 $inQuery 操作符，注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。举例说, 假设您有一个 帖子(Post)类和一个评论(Comment)类, 每个评论(Comment)都有一个指向它的帖子(Post)的关系Key名为post，并且类型为Pointer, 您可以找到所有有图片的帖子(Post)的评论(Comment):\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\npost\n:{\n$inQuery\n:{\nwhere\n:{\nimage\n:{\n$exists\n:true}},\nclassName\n:\nPost\n}}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n同理，使用下面的请求，您可以找到所有没有图片的帖子(Post)的评论(Comment):\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\npost\n:{\n$notInQuery\n:{\nwhere\n:{\nimage\n:{\n$exists\n:true}},\nclassName\n:\nPost\n}}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n如果您想获取的对象，是其父对象的关系 \nRelation\n 类型的Key的所有成员的话, 您可以使用 $relatedTo 操作符, 假设您有一个帖子(Post)类和一个系统默认的用户(_User)类, 而每一个帖子(Post)都可以被不同的用户(_User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是 \nRelation\n 类型, 存储了喜欢这个帖子(Post)的用户(_User)。那么您可以找到喜欢过同一个指定的帖子(Post)的所有用户：\n\n\nrel.query({\n  \ntable\n:\nusers\n,   \n  \nwhere\n:{\n$relatedTo\n:{\nobject\n:{\n__type\n:\nPointer\n,\nclassName\n:\nPost\n,\nobjectId\n:\nl4fQ999O\n},\nkey\n:\nlikes\n}},\n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n还可以使用组合查询，比如下面这样，判断用户是否喜欢(likes)过这个帖子：\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \nwhere\n:{\nlikes\n:{\n$inQuery\n:{\nwhere\n:{\nobjectId\n:\nl3xRGGGa\n},\nclassName\n:\n_User\n}}, \nobjectId\n:\nl4fQ999O\n},\n  \nlimit\n:10,  \n  \ncount\n:true   \n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n返回结果集如下：\n\n\n{\n    count: 1\n    results: [ ]\n}\n\n\n\n\n你可以做如下判断，如果count=1，表明用户喜欢的这个帖子objectId存在，即用户喜欢过这个帖子；若count=0, 表明用户没有喜欢过这个帖子。\n\n\n在某些情况之下，您可能需要在一个查询之中返回关联对象的多种类型，您可以通过传入字段名称到include参数中，多个字段名称用,间隔， 比如，我们想获得最近的10篇评论，而您想同时得到它们相关的post：\n\ninclude的Key必须是Pointer类型\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \norder\n:\n-createdAt\n,\n  \nlimit\n:10,  \n  \ninclude\n:\npost\n   \n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n不是作为一个 \nPointer\n 类型表示，post字段现在已经被展开为一个完整的帖子(Post)对象， __type 被设置为 \nObject\n 而 \nclassName\n 同样也被提供了。 举例说， 一个指向帖子(Post)的Pointer原本展示为：\n\n\n{\n  \n__type\n: \nPointer\n,\n  \nclassName\n: \nPost\n,\n  \nobjectId\n: \n51e3a359e4b015ead4d95ddc\n\n}\n\n\n\n\n当一个查询使用include参数来包含进去来取代 \nPointer\n 之后，可以看到 \nPointer\n 被展开为：\n\n\n{\n  \n__type\n: \nObject\n,\n  \nclassName\n: \nPost\n,\n  \nobjectId\n: \n51e3a359e4b015ead4d95ddc\n,\n  \ncreatedAt\n: \n2011-12-06T20:59:34.428Z\n,\n  \nupdatedAt\n: \n2011-12-06T20:59:34.428Z\n,\n  \notherFields\n: \nwillAlsoBeIncluded\n\n}\n\n\n\n\n您可以同样做多层的include, 这时要使用 \".\" 号. 如果您要include一条评论(Comment)对应的帖子(Post)的作者(author)：\n\ninclude的Key必须是Pointer类型\n\n\nrel.query({\n  \ntable\n:\nComment\n,   \n  \norder\n:\n-createdAt\n,\n  \nlimit\n:10,  \n  \ninclude\n:\npost.author\n   \n },function(err,data){    \n    //回调函数\n });\n\n\n\n\n删除关联关系\n\n\n可以在一个对象中删除一个关系:\n\n\n  rel.delete({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\n8106dc7c9e\n,\n    \ndata\n:{\ngamerel\n:{\n__op\n:\nRemoveRelation\n,\nobjects\n:[{\n__type\n:\nPointer\n,\nclassName\n:\nGame\n,\nobjectId\n:\nekZq111a\n}]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n原子操作对象\n\n\n很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值，示例代码如下：\n\n\nfunction onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score增加一个固定值操作\n  atom.exec({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nscore\n:{\n__op\n:\nIncrement\n,\namount\n:1}}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\nfunction onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score减少一个固定值操作\n  atom.exec({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nscore\n:{\n__op\n:\nIncrement\n,\namount\n:-1}}\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n批量操作对象\n\n\n为了减少因为网络通讯次数太多而带来的时间浪费, 您使用使用下面的批量(batch)操作，在一个请求中对多个普通对象(不支持系统内置的用户对象)进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。\n\n\nfunction onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n    \ndata\n:{\n        \nrequests\n: [\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/GameScore\n,\n            \nbody\n: {\n              \nscore\n: 1337,\n              \nplayerName\n: \nSean Plott\n\n            }\n          },\n          {\n            \nmethod\n: \nPOST\n,\n            \npath\n: \n/1/classes/GameScore\n,\n            \nbody\n: {\n              \nscore\n: 1338,\n              \nplayerName\n: \nZeroCool\n\n            }\n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n批量操作的响应会是一个列表, 列表的返回值个数同给定的requests请求个数是相等的。列表中每个返回项都有一个字段是 \n\"success\"\n 或者 \n\"error\"\n， \n\"success\"\n 的值是通常是和你进行其他REST操作成功时返回的值是一样的:\n\n\n{\n  \nsuccess\n: {\n    \ncreatedAt\n: \n2012-06-15T16:59:11.276Z\n,\n    \nobjectId\n: \n51c3ba67e4b0f0e851c16221\n\n  }\n}\n\n\n\n\n\"error\"\n 的值是有返回码和错误信息字符串的一个对象:\n\n\n{\n  \nerror\n: {\n    \ncode\n: 101,\n    \nerror\n: \nobject not found for delete\n\n  }\n}\n\n\n\n\n在 batch 操作中更新(update)和删除(delete)同样是有效的:\n\n\nfunction onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n    \ndata\n:{\n        \nrequests\n: [\n          {\n            \nmethod\n: \nPUT\n,\n            \npath\n: \n/1/classes/GameScore/51e3a334e4b0b3eb44adbe1a\n,\n            \nbody\n: {\n              \nscore\n: 999999\n            }\n          },\n          {\n            \nmethod\n: \nDELETE\n,\n            \npath\n: \n/1/classes/GameScore/51a8a4d9e4b0d034f6159a35\n\n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}\n\n\n\n\n数组操作对象\n\n\n用下面的方法来获取数组对象：\n\n\n  var arr = modules.oArray;\n\n\n\n\n\n添加数组对象\n\n\n添加数组对象,不管元素是否存在都添加的实现代码如下：\n\n\n  arr.add({\n    \ntable\n:\nGameScore\n,\n    \ndata\n:{\nskills\n:{\n__op\n:\nAdd\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n      //回调函数\n  });\n\n\n\n\n\n添加数组对象,只有在元素不存在情况下才添加的实现代码如下：\n\n\n  //往GameScore表中字段skills添加的数组\n  arr.addUnique({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nskills\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n删除数组对象\n\n\n  //往GameScore表中字段skills删除数组\n  arr.remove({\n    \ntable\n:\nGameScore\n,\n    \nobjectId\n:\nj4w2DDDT\n,\n    \ndata\n:{\nskills\n:{\n__op\n:\nRemove\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n查询数组对象\n\n\n查询数组对象,可以查找skills的数组值中包含有\"flying\"的对象的实现方法如下:\n\n\n  //往GameScore表中字段skills添加的数组\n  arr.query({\n    \ntable\n:\nGameScore\n,\n    \nwhere\n:{\nskills\n:\nflying\n}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n查询数组对象,可以查找skills的数组值中包含有\"flying\",\"kungfu\"的对象的实现方法如下：\n\n\n  //往GameScore表中字段skills添加的数组\n  arr.query({\n    \ntable\n:\nGameScore\n,\n    \nwhere\n:{\nskills\n:{\n$all\n:[\nflying\n,\nkungfu\n]}}\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n消息推送对象\n\n\n推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教会你使用Bmob来推送消息。用下面的方法来获取消息推送对象：\n\n\n  var push = modules.oPush;\n\n\n\n\n\n安装消息推送服务\n\n\n每一个Bmob的App安装在用户设备后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。\n\n\nInstallation对象有几个系统默认的特殊字段来帮助你的管理和定位到设备：\n- \nbadge\n : iOS应用中右上角的图标标识\n- \nchannels\n : 当前这个设备订阅的渠道名称数组\n- \ntimeZone\n : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n- \ndeviceType\n : 设备的的类型, 值为：\"ios\" 或 \"android\" (只读)\n- \ninstallationId\n : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n- \ndeviceToken\n : iOS设备由Apple APNS生成的唯一性token标识 (只读)\n\n\n保存installation\n\n\n保存iOS设备的deviceToken\n\n\niOS设备通常使用deviceToken来惟一标识一台设备。\n\n\n  push.add({\n    \ndata\n:{\n        \ndeviceType\n: \nios\n,\n        \ndeviceToken\n: \nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n,\n        \nchannels\n: [\n          \nGiants\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n保存Android设备的installationId\n\n\n对于Android设备，SDK会自动生成uuid作为installationId保存到Bmob。 您可以使用以下云端逻辑保存Android设备的installation ID：\n\n\n  push.add({\n    \ndata\n:{\n        \ndeviceType\n: \nandroid\n,\n        \ninstallationId\n: \n12345678-4312-1234-1234-1234567890ab\n,\n        \nchannels\n: [\n          \nGiants\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n你还可以更新Installation对象的更多属性，用来查询installationId，定制更通用的推送：\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nscores\n: true,\n        \ngameResults\n: true,\n        \ninjuryReports\n: true\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n保存Windows Phone设备的 notificationUri\n\n\n对于Windows Phone设备，BmobSDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下REST API保存Windows Phone设备的notificationUri：\n\n\n  push.add({\n    \ndata\n:{\n        \ndeviceType\n: \nwindows phone\n,\n        \nnotificationUri\n: \nhttps://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ\n,\n        \nchannels\n: [\n          \nGiants\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n订阅频道和退订\n\n\n订阅频道\n\n\n覆盖已订阅的频道：\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nchannels\n: [\n          \nGiants\n,\n          \nMets\n\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n订阅一个新频道，不覆盖已订阅的频道：\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nchannels\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nGiants111\n]}\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n退订频道\n\n\n  push.update({\n    \nobjectId\n:\n400a12ed3a\n,\n    \ndata\n:{\n        \nchannels\n:{\n__op\n:\nRemove\n,\nobjects\n:[\nGiants\n,\nMets\n]}\n    }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n广播推送消息\n\n\n  push.send({\n    \ndata\n:{\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n组播推送消息\n\n\n发送给订阅了Giants频道的用户\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n          \nchannels\n:[\nGiants\n]\n        },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){删除数据\n     //回调函数\n  });\n\n\n\n\n\n或者更简便的方式\n\n\n  push.send({\n    \ndata\n:{\n        \nchannels\n:[\nGiants\n],\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n多播推送消息\n\n\n推送给不活跃的用户\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n            \nupdatedAt\n:{\n                \n$lt\n:{\n__type\n:\nDate\n,\niso\n:\n2014-01-29 11:33:53\n}\n              }\n        },\n        \ndata\n: {\n            \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n根据查询条件做推送\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \nscores\n: true\n        },\n        \ndata\n: {\n          \nalert\n: \nWillie Hayes injured by own pop fly.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询\n\n\n根据平台做推送\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \ndeviceType\n: \nandroid\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny robots!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \ndeviceType\n: \nios\n\n        },\n        \ndata\n: {\n          \nalert\n: \nYour suitcase has been filled with tiny robots!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n根据地理信息位置做推送\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n: {\n          \nuser\n: {\n            \n$inQuery\n: {\n              \nlocation\n: {\n                \n$nearSphere\n: {\n                  \n__type\n: \nGeoPoint\n,\n                  \nlatitude\n: 30.0,\n                  \nlongitude\n: -20.0\n                },\n                \n$maxDistanceInMiles\n: 1.0\n              }\n            }\n          }\n        },\n        \ndata\n: {\n          \nalert\n: \nFree hotdogs at the bmob concession stand!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。\n\n\n点播推送消息\n\n\n发送给Android单个客户端\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n            \ninstallationId\n:\n12345678-4312-1234-1234-1234567890ab\n\n            },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n发送给iOS单个客户端\n\n\n  push.send({\n    \ndata\n:{\n        \nwhere\n:{\n            \ndeviceToken\n:\nabcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789\n\n            },\n        \ndata\n: {\n          \nalert\n: \nHello From Bmob.\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n\n发送选项设置\n\n\n推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时间性有要求的消息您还可以设置一个消息过期时间。\n\n\n定制您的通知\n\n\n如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n- \nalert\n : 通知的消息内容\n- \nbadge\n : (仅iOS)一个数字值将会高亮显示在应用图标的右上角\n- \nsound\n : (仅iOS)应用绑定包中的声音文件 \n- \ncontent-available\n : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将为触发离线下载功能。\n- \naction\n : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n- \ntitle\n : (仅Android)这个值将显示在系统通知栏\n\n\n例如，推送一条通知，将当前的badge值自增1,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，则请求如下：\n\n\n  push.send({\n    \ndata\n:{\n        \nchannels\n: [\n          \nGiants\n\n        ],\n        \ndata\n: {\n          \nalert\n: \nThe Mets scored! The game is now tied 1-1.\n,\n          \nbadge\n: 1,\n          \nsound\n: \ncheering.caf\n,\n          \ntitle\n: \nMets Score!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n当然，你也可以在data字典对象中定制自己的字段，推送消息，但不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后,\n\n\n  push.send({\n    \ndata\n:{\n        \nchannels\n: [\n          \nGiants\n\n        ],\n        \ndata\n: {\n          \nalert\n: \nThe Mets scored! The game is now tied 1-1.\n,\n          \nbadge\n: \nIncrement\n,\n          \nsound\n: \ncheering.caf\n,\n          \ntitle\n: \nMets Score!\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n设置消息过期时间\n\n\n过期时间，可以是绝对时间：\n\n\n  push.send({\n    \ndata\n:{\n        \nexpiration_time\n: \n2015-12-04 00:51:13\n,\n        \ndata\n: {\n          \nalert\n: \nSeason tickets on sale until December  4, 2013\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:\n\n\n  push.send({\n    \ndata\n:{\n        \npush_time\n: \n2012-01-28 00:51:13\n,\n        \nexpiration_interval\n: 518400,\n        \ndata\n: {\n          \nalert\n: \nSeason tickets on sale until December  4, 2013\n\n        }\n      }\n  },function(err,data){\n     //回调函数\n  });\n\n\n\n\n邮件发送对象\n\n\nBmob的邮件发送对象采用Nodejs提供的nodemailer模块，这里提供简单的一个发送邮件的操作实例。更多的功能详细参考：\nhttps://npmjs.org/package/nodemailer\n\n\nfunction onRequest(request, response, modules) {\n//获得发送邮件的对象 \nvar mailer = modules.oMail; \n//设置发送服务器信息 \nvar  transport = mailer.createTransport( \nSMTP\n , {\n    host: \nsmtp.126.com\n ,\n    secureConnection: true , // use SSL\n    port: 465, // port for secure SMTP\n    auth: {\nuser: \nbmobtest111@126.com\n, //设置发送邮箱帐号 \npass: \nxxx\n //设置发送邮箱密码 \n    }\n});\n\ntransport.sendMail({\n    from : \nbmobtest111@126.com\n ,\n    to : \ntest@126.com\n ,\n    subject: \n主题\n ,\n    generateTextFromHTML : true ,\n    html : \n啊哈哈哈\n\n}, function (error, responseback){\n\n    transport.close();\n     if(error){\n        //发送失败\n    }else{\n        //发送成功\n        response.send(\n发送成功\n);\n    }\n});\n\n\n\n}                                                                                                                                                                                                                                   \n\n\n\n\nHTTP请求对象\n\n\noHttp对象可以模拟实现get、post、put、delete等各种HTTP请求信息，让你在云端实现诸如数据采集、OAuth授权登录等功能。Bmob的HTTP请求模块采用Nodejs提供的request模块，这里提供简单的Get和Post的操作实例。更多的功能详细参考：\nhttps://npmjs.org/package/request\n\n\n/**\n*发起Get请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//发起Get请求\nhttp('http://www.bmob.cn', function (error, res, body) {\n    if (!error \n res.statusCode == 200) {\n      response.send(body);\n    }\n})\n\n-\n\n/**\n*发起Post请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//往http://bmob.cn/save发起POST请求\nhttp.post('http://bmob.cn/save', {form:{key:'value'}})\n\n\n\n\n事件对象\n\n\noEvent，也就是eventproxy模块，解决异步回调的问题。\n\n\n更多的功能详细参考：\nhttps://github.com/JacksonTian/eventproxy\n\n\nfunction onRequest(request, response, modules) {\n\n    var ep = modules.oEvent;  //eventproxy模块，解决异步回调的问题\n\n    ep.after('got_file', 3, function (list) {\n        response.send(\nlen:\n+list.length);\n\n    });\n\n    //发送3次事件后触发事件，输出list的长度\n    ep.emit(\ngot_file\n, \n1\n);  \n    ep.emit(\ngot_file\n, \n1\n);  \n    ep.emit(\ngot_file\n, \n1\n);  \n\n\n}                        \n\n\n\n\nEncode编码转换对象\n\n\nEncode对象可以实现字符编码的转换。更多的功能详细参考：\nhttps://www.npmjs.org/package/encoding\n\n\nEncode对象就一个方法convert()，使用方法为：encoding.convert(text, toCharset, fromCharset)。\n\n\ntext: 需要转换的对象，可以为Buffer或者String对象。\n\n\ntoCharset: 转换后的编码。\n\n\nfromCharset: 转换前的编码，缺省为uft8。\n\n\n转换后的输入结果为Buffer对象。\n\n\nvar encoding = modules.oEncodeing;\nvar result = encoding.convert(\n禅\n,\ngbk\n,\nutf8\n);\nresponse.send(result.toString()); \n\n\n\n\n\nhtml元素解析对象（oHtmlparser）\n\n\nhtml元素解析对象可以实现html的解释。更多的功能详细参考：\nhttps://www.npmjs.org/package/htmlparser\n\n\n代码例子\n\n\nfunction onRequest(request, response, modules) {\n    var htmlparser = modules.oHtmlparser;\n    var rawHtml = \na href='test.html'\nxxx\n/a\n;\n    var handler = new htmlparser.DefaultHandler(function (error, dom) {});\n    var parser = new htmlparser.Parser(handler);\n    parser.parseComplete(rawHtml);\n    response.send(JSON.stringify(handler.dom, null, 2));\n\n}                                                                                                                         \n\n\n\n\n\n代码的输出：\n\n\n[\n  {\n    \nraw\n: \na href='test.html'\n,\n    \ndata\n: \na href='test.html'\n,\n    \ntype\n: \ntag\n,\n    \nname\n: \na\n,\n    \nattribs\n: {\n      \nhref\n: \ntest.html\n\n    },\n    \nchildren\n: [\n      {\n        \nraw\n: \nxxx\n,\n        \ndata\n: \nxxx\n,\n        \ntype\n: \ntext\n\n      }\n    ]\n  }\n]                                                                                                                        \n\n\n\n\n\nbql对象（oBql）\n\n\n我们提供类 SQL 语法的 BQL 查询语言来查询数据\n\n\n下面的代码例子就是查询GameScore表的所有数据\n\n\nfunction onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n      \nbql\n:\nselect * from GameScore\n\n    },function(err,data){\n      response.send(data);\n    });\n\n\n}                                                                                                                        \n\n\n\n\n\nBQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过 values 数组传入：\n\n\nfunction onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n      \nbql\n:\nselect * from GameScore where name=? limit ?,? \n,\n      \nvalues\n:\n[\\\ntom\\\n,0,100]\n\n    },function(err,data){\n      response.send(data);\n     //回调函数\n    });\n\n\n}                                                                         \n\n\n\n\n更多请参考 \nBQL 详细指南\n 。\n\n\n加密对象（oCrypto）\n\n\n提供md5和sha1两种加密算法。更多的功能详细参考：\nhttps://www.npmjs.org/package/crypto\n\n\n代码例子\n\n\n  function onRequest(request, response, modules) {\n    var crypto = modules.oCrypto;\n    var md5 = crypto.createHash('md5');\n    md5.update(\nhello\n); //输入要md5的内容\n    response.send(md5.digest('hex'));//以16进制编码\n}                                                                                                                         \n\n\n\n\n\n云端逻辑调试工具\n\n\n为方便开发者调试云端逻辑，Bmob为开发者提供了便捷的云端调试工具，你可以直接在云端逻辑的编辑页面下对编写的代码进行调试，如实现从Bar表中查找指定objectId号（SDK中上传参数）的数据，你可以在云端逻辑中实现如下：\n\n\nfunction onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n    \ntable\n:\nBar\n,\n    \nobjectId\n:request.body.objectId\n  },function(err,data){ //回调函数\n     response.send(\n成功 \n + data);\n  });\n}\n\n\n\n\n调试时，你在云端调试工具中输入参数名为objectId，参数值为你想要查询的信息，如下图，即可查看到调试结果。\n\n\n\n\n错误对象\n\n\nBmob提供的官方模块（非第三方）的错误回调中都会有一个\nerr\n对象，这个\nerr\n对象包含两个属性：\nerror\n和\ncode\n，分别代表错误异常信息和错误代码。调用时可以简单如下使用：\n\n\nfunction onRequest(request, response, modules) {\n    var db = modules.oData;\n    db.findOne({\n        \ntable\n:\nYourTableName\n,\n        \nobjectId\n:request.body.oid\n    },function(err,data){ \n        //对返回结果进行处理\n        if(err)  response.send(\nerror is  \n + err.code  + \nerror message is \n + err.error );\n        else response.send(data);\n    });\n}", 
            "title": "开发文档"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_1", 
            "text": "Bmob旨在让移动开发变得更简单。对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob云端逻辑提供了这种灵活性，可以让您的代码直接在Bmob云上运行。一旦你在云端更新了代码，所有的移动应用都会立即自动更新，新功能的发布将会变得更加简单可控。", 
            "title": "简介"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_2", 
            "text": "为方便大家更好的使用云端逻辑，Bmob为大家提供了一些常用模块，方便大家直接拿来使用的。    对整个表进行排序： https://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order1.js  可结合定时任务使用    获取某行数据对应排行的信息：  https://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order2.js    获取前N名数据排行信息： https://github.com/bmob/bmob-cloudcode-demo-ranking/blob/master/order3.js    在开发云端逻辑时，希望大家能够先看看我们提供的编码规范文档： http://docs.bmob.cn/cloudcode/WEB/f_codehelp/doc/index.html", 
            "title": "开源案例"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_3", 
            "text": "bmob允许以http的方式直接调用云端逻辑。", 
            "title": "调用云端逻辑的方式"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#secret-key", 
            "text": "用户需要以http的方式运行云端逻辑，需要先确定应用的Secret Key。 调用云端逻辑时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台- 应用密钥- Secret Key, 如下图所示：  注意：请妥善保管Secret Key，避免Secret Key的泄露！！！", 
            "title": "获取Secret Key"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#get", 
            "text": "下面展示了以Get的方式调用云端逻辑：  curl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff  其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云端逻辑的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "以Get的方式调用云端逻辑"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#post", 
            "text": "下面展示了以Post的方式调用云端逻辑：  curl -X POST \\\n    -H  Content-Type: application/x-www-form-urlencoded  \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test  其中：\n0348d0c262bc91d9：应用的Secret Key。\ntest：云端逻辑的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "以Post的方式调用云端逻辑"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_4", 
            "text": "注意：升级云端代码套餐后就没法在微信公众号中调用云端代码  bmob允许以http的方式直接调用云端逻辑。", 
            "title": "转为套餐后调用云端逻辑的方式"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#id", 
            "text": "进入应用后台- 云逻辑，下图中的箭头所指的数字就是该应用的id值：", 
            "title": "获取应用的id值"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#get_1", 
            "text": "下面展示了以Get的方式调用云端逻辑：  curl -X GET http://cloud-xxxxx.bmobapp.com/test?name=jeff  其中：\ncloud-xxxxx.bmobapp.com：该应用的云端代码专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云端逻辑的名称。\nname=jeff: 传入一个参数，名称是name，值是jeff。\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "Get的方式调用云端逻辑"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#post_1", 
            "text": "下面展示了以Post的方式调用云端逻辑：  curl -X POST \\\n    -H  Content-Type: application/x-www-form-urlencoded  \\\n    -d 'name=jeff' \\\n    http://cloud-xxxxx.bmobapp.com/test  其中：\ncloud-xxxxx.bmobapp.com：该应用的云端代码专属域名，其中xxxxx为上节“获取应用的id值”所获取的id值。\ntest：云端逻辑的名称\nname=jeff: 传入一个参数，名称是name，值是jeff\n与restful不同，无需再传其它诸如app id等请求头。", 
            "title": "Post的方式调用云端逻辑"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_5", 
            "text": "从云端逻辑的入口方法function onRequest(request, response, modules)可知，云端逻辑包含三个模块，分别是request模块、response模块和modules模块。", 
            "title": "云端逻辑模块解释"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#request", 
            "text": "request模块用于获取传入的参数。由于现在调用云端逻辑有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。  注意，当通过android，ios等客户端sdk调用云端逻辑，或者通过restful api的方式调用云端逻辑，都是采用post的方式。", 
            "title": "request模块"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#get_2", 
            "text": "用get方式调用云端逻辑，例如：  curl -X GET http://cloud.bmob.cn/0348d0c262bc91d9/test?name=jeff  可用下面的方法获取name的值：  request.query.name", 
            "title": "get方式"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#post_2", 
            "text": "用post方式调用云端逻辑，例如：  curl -X POST \\\n    -H  Content-Type: application/x-www-form-urlencoded  \\\n    -d 'name=jeff' \\\n    http://cloud.bmob.cn/0348d0c262bc91d9/test  可用下面的方法获取name的值：  request.body.name", 
            "title": "post方式"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#http", 
            "text": "当云端逻辑是用于某些平台的回调时，同一段云端逻辑可能有时是采用get的方式调用，有时是采用post的方式调用, 可用下面的方法获取当前云端逻辑是采用get还是post方式调用。  例子如下：      var httptype = request.method;　//获取调用云端逻辑的是post或者get方式\n    if ( GET  == httptype) {\n        //采用get方式调用云端逻辑\n    }else{\n        //采用post方式调用云端逻辑\n    }", 
            "title": "获取调用云端逻辑的http方式"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#response", 
            "text": "response为云端逻辑的信息回传模块，该模块包含了一个send方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：  response.send(string result)", 
            "title": "response模块"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#modules", 
            "text": "modules是Bmob云端逻辑提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云端逻辑对象（oFunctions）、邮件发送对象（oMail）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云端逻辑想要调用这些对象时，只需要用如下的方法即可获取：    //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作   这里需要说明一点的是：云端逻辑对数据格式的封装遵循RestApi的规则，如果在查看过程中有什么疑问，请移步到 RestApi开发文档 。", 
            "title": "modules模块"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_6", 
            "text": "数据库操作的简单实例如下：  function onRequest(request, response, modules) {\n  //获取数据库对象\n  var db = modules.oData;\n  //获取Posts表中的所有值\n  db.find({\n     table : Posts ,\n  },function(err,data){\n    response.send(data);\n  });\n}  其中，Posts是查找的数据表名称，table是关键词。  需要注意的是，Bmob云端逻辑底层采用Nodejs进行开发，继承了Nodejs的异步非阻塞事件驱动模式，因此也不可避免的需要大量使用回调方法，这些方法往往以非显式声明的闭包形式存在。  此外，通过oData数据库对象获取返回的回调接口中，所有的data数据都是string类型，如果需要在云端中作为对象类型调用的话，需要将string类型转换为object类型，即：      var dataObject= JSON.parse(data);  oData对象的其他操作方法如下：", 
            "title": "数据库对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_7", 
            "text": "find({\n   table : XXX ,          //表名\n   keys : a,b,c ,         //返回字段列表，多个字段用,分隔\n   where :{ a : XXXX , b : XXXX },       //查询条件是一个JSON object\n   order : -a,b ,         //排序列表，[-]字段名称,-表示降序，默认为升序\n   limit :10,            //limit大小，一页返回多少条记录，默认为0\n   skip :2,             //skip,分页offset，(page-1)*limit\n   count :1            //count,只返回符合条件的记录总数\n },function(err,data){    //回调函数\n });  以下是读取Games表（包含name字段）的数据，并对这些数据进行遍历，将name字段连接起来的一段代码样例：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.find({\n     table : Games \n  },function(err,data){ \n  //将返回结果转换为Json对象\n  var resultObject= JSON.parse(data);\n  //遍历这个Json对象\n  for(var results in resultObject)\n  {\n    var resultArr = resultObject[results];\n    var str =   ;\n    //遍历得到的每行结果\n    for(var oneline in resultArr){\n      str =str +    + resultArr[oneline].name;\n    }\n    response.send(str);\n  }\n});\n}", 
            "title": "查询多条数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_8", 
            "text": "findOne({\n   table : XXX ,             //表名\n   objectId : XXXX          //记录的objectId\n},function(err,data){         //回调函数\n});  需要注意的是： \n1. 为确保User表的安全性，findOne方法不能直接操作User表。\n2. find方法返回的data是字符串类型，如果需要直接对象化调用的话，需要将string类型转换为object类型，即如下，从_User表中查找objectId=YIuNDDDO的数据，并把username信息显示出来：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n     table : _User ,\n     objectId : YIuNDDDO \n  },function(err,data){ \n    var dataObject= JSON.parse(data);\n    response.send( 获取用户名信息为：   + dataObject.username);\n  });\n}", 
            "title": "查询单条数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_9", 
            "text": "function onRequest(request, response, modules) {\n    var db = modules.oData;\n    //获取表 GameScore 的总记录数\n    db.find({\n       table : GameScore ,\n       limit :0,\n       count :1 \n    },function(err,data){     \n\n        resultObject= JSON.parse(data);\n        count=resultObject.count;\n        response.send( 表记录数: +count);\n\n    });     \n}                                                      其中， count 为标识位，具体原因大家可以参考Restapi说明文档： http://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询结果计数 。", 
            "title": "获取表的记录数"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_10", 
            "text": "update({\n   table : XXX ,             //表名\n   objectId : XXXX ,        //记录的objectId\n   data :{ a : XXXX , b : XXXX }           //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});  以下是一个更新数据的示例代码，实现的效果是从Games表中找到objectId=hmw9888C的数据，将其name数据改为pingpang games。  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.update({\n     table : Games ,\n     objectId : hmw9888C ,\n     data :{ name : pingpang games }\n  },function(err,data){ \n    response.send( success );\n  });\n}", 
            "title": "修改数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_11", 
            "text": "insert({\n   table : XXX ,             //表名\n   data :{ a : XXXX , b : XXXX }            //需要更新的数据，格式为JSON\n},function(err,data){         //回调函数\n});", 
            "title": "添加数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_12", 
            "text": "remove({\n   table : XXX ,             //表名\n   objectId : XXXX         //记录的objectId\n},function(err,data){         //回调函数\n});", 
            "title": "删除数据"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_13", 
            "text": "userSignUp({\n   data :{ a : XXXX , b : XXXX }             //用户注册的信息，格式为JSON\n},function(err,data){         //回调函数\n});", 
            "title": "用户注册"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_14", 
            "text": "userLogin({\n   username : aa ,            //登录用户名\n   password :               //用户密码\n},function(err,data){         //回调函数\n});", 
            "title": "用户登录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_15", 
            "text": "userRestPassword({\n   data :{ email : XX@XX.com }      //需要重置密码的用户邮件账号\n},function(err,data){         //回调函数\n});", 
            "title": "用户密码重置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_16", 
            "text": "getUserByObjectId({\n   objectId : XXXX           //记录的objectId\n},function(err,data){         //回调函数\n});", 
            "title": "获取某一用户记录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_17", 
            "text": "说明：必须先登录才能更新，切记！！！否则会报sessionToken error  updateUserByObjectId({\n       objectId : XXXX ,        //记录的objectId\n       data :{ a : XXXX , b : XXXX }           //需要更新的数据，格式为JSON\n    },function(err,data){         //回调函数\n});  以下是更新用户信息的示例代码：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.userLogin({\n     username : 123567 ,\n     password : 123 \n  },function(err, data){\n    if(data){\n      var dataObject = JSON.parse(data);\n      if(dataObject.error == null){\n        //需要设置登录之后获取的sessionToken头信息\n        db.setHeader({ X-Bmob-Session-Token :dataObject.sessionToken});\n        db.updateUserByObjectId({ objectId :dataObject.objectId ,data:{ username : 123 }},function(err,data){\n          response.send( 更新成功 );\n      })\n    }else{\n      response.send( 找不到该用户！ );\n    }\n  }\n}); \n}", 
            "title": "更新某一用户记录"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_18", 
            "text": "getAllUser(function(err,data){         //回调函数\n});", 
            "title": "获得所有用户信息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_19", 
            "text": "说明：必须登录才行，切记！！！否则会报sessionToken error  removeUserByObjectId({\n       objectId : XXXX         //记录的objectId\n    },function(err,data){         //回调函数\n});", 
            "title": "删除某一个指定用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_20", 
            "text": "发送给用户的邮箱验证的邮件会在一周内失效，可以通过下面的方法来强制重新发送  requestEmailVerify({\n       data :{ email : coolguy@iloveapps.com }\n  },function(err,data){ \n    //回调函数\n  });  这里有一个小技巧分享给大家，有时候你会希望能够用Master Key（Bmob给大家提供的超级权限，可以对数据进行任何操作）对数据进行操作，包括不需要用户登录就可以修改用户信息等。那么你只需要在对数据进行操作前，通过db.setHeader方法设置下Master Key头信息即可，如下：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.setHeader({ X-Bmob-Master-Key : 这里填写Master Key信息 });\n  db.updateUserByObjectId({ objectId : 这里是需要更新的用户ObjectId信息  ,data:{ username : 123 }},function(err,data){\n    response.send( 更新成功 );\n  }); \n}", 
            "title": "邮箱验证"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_21", 
            "text": "云端逻辑只支持文件的删除操作。删除文件，必须要知道文件的组名和url，示例代码如下：  function onRequest(request, response, modules) {\n\n  var file = modules.oFile;\n\n  file.del({\n     group : group1 ,\n     url : M00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html \n  },function(err,data){\n     //回调函数\n  });\n}  在上面的例子中，group1是组名，M00/00/01/wKgBP1N3FAWRJXsSAAAB_rYZATs52.html是url。  返回结果是个json对象：  {\n   msg :  delete file success \n}", 
            "title": "文件对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_22", 
            "text": "在云端逻辑中可以调用本app的其它云端逻辑，示例代码如下：  function onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n        name :  test ,\n        data :{ content : 你好 , address : guangzhou }\n    },function(err,data){\n       //回调函数\n    });\n}  在上面的例子中， name 是云端逻辑的函数名， data 中是传递的参数  如果不需要传递任何参数，可以用下面的实例代码：  function onRequest(request, response, modules) {\n\n    var functions = modules.oFunctions;\n\n    functions.run({\n        name :  test \n    },function(err,data){\n       //回调函数\n    });\n}", 
            "title": "云端逻辑对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_23", 
            "text": "Bmob允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。你可以在查询中添加一个GeoPoint的对象查询。您可以实现轻松查找出离当前用户最接近的信息或地点的功能。", 
            "title": "地理位置对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_24", 
            "text": "创建地理位置的示例代码如下：  function onRequest(request, response, modules) {\n\n  var location = modules.oLocation;\n\n  location.create({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ location :{            \n             __type :  GeoPoint ,\n             latitude :  12.934755,\n             longitude : 24.52065\n        }}\n  },function(err,data){\n     //回调函数\n  });\n}", 
            "title": "创建地理位置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_25", 
            "text": "现在您有一系列的对象对应的地理坐标，如果能发现那些对象离指定的点近就好了，这可以通过GeoPoint数据类型加上在查询中使用$nearSphere做到。获取离用户最近的10个地点的实现代码如下：    location.query({\n     table : GameScore ,\n     limit :10,\n     where :{\n         location : {\n             $nearSphere : {\n                 __type :  GeoPoint ,\n                 latitude : 30.0,\n                 longitude : 20.0\n            }\n          }\n    }\n  },function(err,data){\n     //回调函数\n  });  这会按离纬度30.0，经度-20.0的距离排序返回一系列的结果，第一个就是最近的对象。(注意如果一个特定的order参数给了的话，它会覆盖按距离排序)，例如，下面是两个上面的查询返回的结果：  {\n     results : [\n    {\n         location : {\n              __type :  GeoPoint ,\n             latitude : 40.0,\n             longitude : -30.0\n        },\n         updatedAt :  2011-12-06 22:36:04 ,\n         createdAt :  2011-12-06 22:36:04 ,\n         objectId :  e1kXT22L \n        },\n        {\n         location : {\n              __type :  GeoPoint ,\n              latitude : 30.0,\n              longitude : 20.0\n        },\n         updatedAt :  2011-12-06 22:36:26 ,\n         createdAt :  2011-12-06 22:36:26 ,\n         objectId :  51e3a2a8e4b015ead4d95dd9 \n        }\n    ]\n}  为了限定搜素的最大举例，需要加入$maxDistanceInMiles和$maxDistanceInKilometers或者$maxDistanceInRadians参数来限定。如果不加，则默认是100KM的半径。如，要找半径在10公里内的数据的实现代码如下：    location.query({\n     table : GameScore ,\n     limit :10,\n     where :{\n         location : {\n             $nearSphere : {\n                 __type :  GeoPoint ,\n                 latitude : 30.0,\n                 longitude : 20.0\n            },\n         $maxDistanceInKilometers : 10.0\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });  同样做查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形的区域里的对象，按下面的格式加入一个约束 {\"$within\": {\"$box\": {[southwestGeoPoint, northeastGeoPoint]}}}，下面是一段示例代码：    location.query({\n     table : GameScore ,\n     limit :10,\n     where :{\n         location : {\n             $within : {\n                 $box : [\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 37.71,\n                         longitude : 22.53\n                    },\n                    {\n                         __type :  GeoPoint ,\n                         latitude : 30.82,\n                         longitude : 22.37\n                    }\n                ]\n            }\n        }\n    }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "查询地理位置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_26", 
            "text": "一个对象可以与其他对象相联系。就像数据库中的主外键关系一样，数据表 A 的某一个字段是数据表 B 的外键，只有表 B 中存在的数据才可插入进表 A 中的字段。", 
            "title": "关联关系对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_27", 
            "text": "为了更新  Pointer  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一行记录时并添加一个指针：  function onRequest(request, response, modules) {\n\n  var rel = modules.oRelation;\n  rel.add({\n     table : GameScore ,\n     data :{ game :{ __type : Pointer , className : Game , objectId : ekZq111a }}\n  },function(err,data){\n     //回调函数\n  });\n}  为了更新  Relation  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加一行记录时并添加多个关系:    rel.add({\n     table : GameScore ,\n     data :{ gamerel :{ __op : AddRelation , objects :[{ __type : Pointer , className : Game , objectId : ekZq111a },{ __type : Pointer , className : Game , objectId : 80SLHHHj }]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "添加关联关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_28", 
            "text": "为了更新  Pointer  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一个指针:    rel.update({\n     table : GameScore ,\n     objectId : 8106dc7c9e ,\n     data :{ game :{ __type : Pointer , className : Game , objectId : 80SLHHHj }}\n  },function(err,data){\n     //回调函数\n  });  为了更新  Relation  的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加多个关系:    rel.update({\n     table : GameScore ,\n     objectId : 8106dc7c9e ,\n     data :{ gamerel :{ __op : AddRelation , objects :[{ __type : Pointer , className : Game , objectId : ekZq111a }]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "修改关联对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_29", 
            "text": "有几种方式来对关系  Relation  或 指针  Pointer  类型数据进行查询, 如果您将要获取对象中有个Key类型是关系  Relation  或 指针  Pointer ，这都说明你要获取的对象是匹配到另一个特殊（关联或指向）的对象的, 您可以用一个  where  参数查询, 自己使用  __type  构造一个  Pointer , 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论:  rel.query({\n   table : Comment ,   \n   where :{ post :{ __type : Pointer , className : Post , objectId : l4fQ999O }},\n },function(err,data){    \n    //回调函数\n });  如果您想要获取对象, 这些对象的一个字段指向的对象是符合另一个查询的, 您可以使用 $inQuery 操作符，注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。举例说, 假设您有一个 帖子(Post)类和一个评论(Comment)类, 每个评论(Comment)都有一个指向它的帖子(Post)的关系Key名为post，并且类型为Pointer, 您可以找到所有有图片的帖子(Post)的评论(Comment):  rel.query({\n   table : Comment ,   \n   where :{ post :{ $inQuery :{ where :{ image :{ $exists :true}}, className : Post }}},\n },function(err,data){    \n    //回调函数\n });  同理，使用下面的请求，您可以找到所有没有图片的帖子(Post)的评论(Comment):  rel.query({\n   table : Comment ,   \n   where :{ post :{ $notInQuery :{ where :{ image :{ $exists :true}}, className : Post }}},\n },function(err,data){    \n    //回调函数\n });  如果您想获取的对象，是其父对象的关系  Relation  类型的Key的所有成员的话, 您可以使用 $relatedTo 操作符, 假设您有一个帖子(Post)类和一个系统默认的用户(_User)类, 而每一个帖子(Post)都可以被不同的用户(_User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是  Relation  类型, 存储了喜欢这个帖子(Post)的用户(_User)。那么您可以找到喜欢过同一个指定的帖子(Post)的所有用户：  rel.query({\n   table : users ,   \n   where :{ $relatedTo :{ object :{ __type : Pointer , className : Post , objectId : l4fQ999O }, key : likes }},\n },function(err,data){    \n    //回调函数\n });  还可以使用组合查询，比如下面这样，判断用户是否喜欢(likes)过这个帖子：  rel.query({\n   table : Comment ,   \n   where :{ likes :{ $inQuery :{ where :{ objectId : l3xRGGGa }, className : _User }},  objectId : l4fQ999O },\n   limit :10,  \n   count :true   \n },function(err,data){    \n    //回调函数\n });  返回结果集如下：  {\n    count: 1\n    results: [ ]\n}  你可以做如下判断，如果count=1，表明用户喜欢的这个帖子objectId存在，即用户喜欢过这个帖子；若count=0, 表明用户没有喜欢过这个帖子。  在某些情况之下，您可能需要在一个查询之中返回关联对象的多种类型，您可以通过传入字段名称到include参数中，多个字段名称用,间隔， 比如，我们想获得最近的10篇评论，而您想同时得到它们相关的post： include的Key必须是Pointer类型  rel.query({\n   table : Comment ,   \n   order : -createdAt ,\n   limit :10,  \n   include : post    \n },function(err,data){    \n    //回调函数\n });  不是作为一个  Pointer  类型表示，post字段现在已经被展开为一个完整的帖子(Post)对象， __type 被设置为  Object  而  className  同样也被提供了。 举例说， 一个指向帖子(Post)的Pointer原本展示为：  {\n   __type :  Pointer ,\n   className :  Post ,\n   objectId :  51e3a359e4b015ead4d95ddc \n}  当一个查询使用include参数来包含进去来取代  Pointer  之后，可以看到  Pointer  被展开为：  {\n   __type :  Object ,\n   className :  Post ,\n   objectId :  51e3a359e4b015ead4d95ddc ,\n   createdAt :  2011-12-06T20:59:34.428Z ,\n   updatedAt :  2011-12-06T20:59:34.428Z ,\n   otherFields :  willAlsoBeIncluded \n}  您可以同样做多层的include, 这时要使用 \".\" 号. 如果您要include一条评论(Comment)对应的帖子(Post)的作者(author)： include的Key必须是Pointer类型  rel.query({\n   table : Comment ,   \n   order : -createdAt ,\n   limit :10,  \n   include : post.author    \n },function(err,data){    \n    //回调函数\n });", 
            "title": "查询关联对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_30", 
            "text": "可以在一个对象中删除一个关系:    rel.delete({\n     table : GameScore ,\n     objectId : 8106dc7c9e ,\n     data :{ gamerel :{ __op : RemoveRelation , objects :[{ __type : Pointer , className : Game , objectId : ekZq111a }]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "删除关联关系"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_31", 
            "text": "很多应用可能会有需要计数器的功能，比如某条信息被点赞多少次等。Bmob提供了非常便捷的方式来保证原子性的修改某一数值字段的值，示例代码如下：  function onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score增加一个固定值操作\n  atom.exec({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ score :{ __op : Increment , amount :1}}\n  },function(err,data){\n     //回调函数\n  });\n}  function onRequest(request, response, modules) {\n  //获取原子操作对象\n  var atom = modules.oAtom;\n\n  //score减少一个固定值操作\n  atom.exec({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ score :{ __op : Increment , amount :-1}}\n  },function(err,data){\n     //回调函数\n  });\n}", 
            "title": "原子操作对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_32", 
            "text": "为了减少因为网络通讯次数太多而带来的时间浪费, 您使用使用下面的批量(batch)操作，在一个请求中对多个普通对象(不支持系统内置的用户对象)进行添加(create)、更新(update)、删除(delete) 操作，上限为50个。  function onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n     data :{\n         requests : [\n          {\n             method :  POST ,\n             path :  /1/classes/GameScore ,\n             body : {\n               score : 1337,\n               playerName :  Sean Plott \n            }\n          },\n          {\n             method :  POST ,\n             path :  /1/classes/GameScore ,\n             body : {\n               score : 1338,\n               playerName :  ZeroCool \n            }\n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}  批量操作的响应会是一个列表, 列表的返回值个数同给定的requests请求个数是相等的。列表中每个返回项都有一个字段是  \"success\"  或者  \"error\" ，  \"success\"  的值是通常是和你进行其他REST操作成功时返回的值是一样的:  {\n   success : {\n     createdAt :  2012-06-15T16:59:11.276Z ,\n     objectId :  51c3ba67e4b0f0e851c16221 \n  }\n}  \"error\"  的值是有返回码和错误信息字符串的一个对象:  {\n   error : {\n     code : 101,\n     error :  object not found for delete \n  }\n}  在 batch 操作中更新(update)和删除(delete)同样是有效的:  function onRequest(request, response, modules) {\n  //获取数组对象\n  var bat = modules.oBatch;\n\n  //批量操作\n  bat.exec({\n     data :{\n         requests : [\n          {\n             method :  PUT ,\n             path :  /1/classes/GameScore/51e3a334e4b0b3eb44adbe1a ,\n             body : {\n               score : 999999\n            }\n          },\n          {\n             method :  DELETE ,\n             path :  /1/classes/GameScore/51a8a4d9e4b0d034f6159a35 \n          }\n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });\n}", 
            "title": "批量操作对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_33", 
            "text": "用下面的方法来获取数组对象：    var arr = modules.oArray;", 
            "title": "数组操作对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_34", 
            "text": "添加数组对象,不管元素是否存在都添加的实现代码如下：    arr.add({\n     table : GameScore ,\n     data :{ skills :{ __op : Add , objects :[ flying , kungfu ]}}\n  },function(err,data){\n      //回调函数\n  });  添加数组对象,只有在元素不存在情况下才添加的实现代码如下：    //往GameScore表中字段skills添加的数组\n  arr.addUnique({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ skills :{ __op : AddUnique , objects :[ flying , kungfu ]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "添加数组对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_35", 
            "text": "//往GameScore表中字段skills删除数组\n  arr.remove({\n     table : GameScore ,\n     objectId : j4w2DDDT ,\n     data :{ skills :{ __op : Remove , objects :[ flying , kungfu ]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "删除数组对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_36", 
            "text": "查询数组对象,可以查找skills的数组值中包含有\"flying\"的对象的实现方法如下:    //往GameScore表中字段skills添加的数组\n  arr.query({\n     table : GameScore ,\n     where :{ skills : flying }\n  },function(err,data){\n     //回调函数\n  });  查询数组对象,可以查找skills的数组值中包含有\"flying\",\"kungfu\"的对象的实现方法如下：    //往GameScore表中字段skills添加的数组\n  arr.query({\n     table : GameScore ,\n     where :{ skills :{ $all :[ flying , kungfu ]}}\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "查询数组对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_37", 
            "text": "推送通知是让用户及时被通知、和你的应用保持联系的一种非常棒的方式，你可以快速而有效地通知到所有的用户，下面这个教程将会教会你使用Bmob来推送消息。用下面的方法来获取消息推送对象：    var push = modules.oPush;", 
            "title": "消息推送对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_38", 
            "text": "每一个Bmob的App安装在用户设备后，如果要使用消息推送功能，Bmob SDK会自动生成一个Installation对象。Installation对象包含了推送所需要的所有信息。举例：一个棒球的App，你可以让用户订阅感兴趣的棒球队，然后及时将这个球队的消息推送给用户 。  Installation对象有几个系统默认的特殊字段来帮助你的管理和定位到设备：\n-  badge  : iOS应用中右上角的图标标识\n-  channels  : 当前这个设备订阅的渠道名称数组\n-  timeZone  : 设备所在位置的时区， 如Asia/Shanghai，这个会在每个Installation对象更新时同步（只读）\n-  deviceType  : 设备的的类型, 值为：\"ios\" 或 \"android\" (只读)\n-  installationId  : Bmob使用的设备唯一号，Android设备是必须的，iOS可选 (只读)\n-  deviceToken  : iOS设备由Apple APNS生成的唯一性token标识 (只读)", 
            "title": "安装消息推送服务"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#installation", 
            "text": "", 
            "title": "保存installation"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#iosdevicetoken", 
            "text": "iOS设备通常使用deviceToken来惟一标识一台设备。    push.add({\n     data :{\n         deviceType :  ios ,\n         deviceToken :  abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 ,\n         channels : [\n           Giants \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "保存iOS设备的deviceToken"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#androidinstallationid", 
            "text": "对于Android设备，SDK会自动生成uuid作为installationId保存到Bmob。 您可以使用以下云端逻辑保存Android设备的installation ID：    push.add({\n     data :{\n         deviceType :  android ,\n         installationId :  12345678-4312-1234-1234-1234567890ab ,\n         channels : [\n           Giants \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });  你还可以更新Installation对象的更多属性，用来查询installationId，定制更通用的推送：    push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         scores : true,\n         gameResults : true,\n         injuryReports : true\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "保存Android设备的installationId"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#windows-phone-notificationuri", 
            "text": "对于Windows Phone设备，BmobSDK会自动从Windows Push Center获取到notificationUri并保存到 Bmob。 你可以使用以下REST API保存Windows Phone设备的notificationUri：    push.add({\n     data :{\n         deviceType :  windows phone ,\n         notificationUri :  https://hk1.notify.live.net/unthrottledthirdparty/01.00/AQHgHh6EuwNtTa1TbwvaAjnmAgAAAAADEAAAAAQUZm52OkZDM0U5RDkxQzIzREJBNDYFBkFTRUEwMQ ,\n         channels : [\n           Giants \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "保存Windows Phone设备的 notificationUri"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_39", 
            "text": "", 
            "title": "订阅频道和退订"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_40", 
            "text": "覆盖已订阅的频道：    push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         channels : [\n           Giants ,\n           Mets \n        ]\n      }\n  },function(err,data){\n     //回调函数\n  });  订阅一个新频道，不覆盖已订阅的频道：    push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         channels :{ __op : AddUnique , objects :[ Giants111 ]}\n    }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "订阅频道"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_41", 
            "text": "push.update({\n     objectId : 400a12ed3a ,\n     data :{\n         channels :{ __op : Remove , objects :[ Giants , Mets ]}\n    }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "退订频道"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_42", 
            "text": "push.send({\n     data :{\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "广播推送消息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_43", 
            "text": "发送给订阅了Giants频道的用户    push.send({\n     data :{\n         where :{\n           channels :[ Giants ]\n        },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){删除数据\n     //回调函数\n  });  或者更简便的方式    push.send({\n     data :{\n         channels :[ Giants ],\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "组播推送消息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_44", 
            "text": "", 
            "title": "多播推送消息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_45", 
            "text": "push.send({\n     data :{\n         where :{\n             updatedAt :{\n                 $lt :{ __type : Date , iso : 2014-01-29 11:33:53 }\n              }\n        },\n         data : {\n             alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "推送给不活跃的用户"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_46", 
            "text": "push.send({\n     data :{\n         where : {\n           scores : true\n        },\n         data : {\n           alert :  Willie Hayes injured by own pop fly. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  请注意，where 条件查询的都是 installations 表。这里是假设 installations 表存储了 scores 的布尔属性，你可以像查询普通对象一样构造where查询", 
            "title": "根据查询条件做推送"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_47", 
            "text": "push.send({\n     data :{\n         where : {\n           deviceType :  android \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny robots! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });    push.send({\n     data :{\n         where : {\n           deviceType :  ios \n        },\n         data : {\n           alert :  Your suitcase has been filled with tiny robots! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "根据平台做推送"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_48", 
            "text": "push.send({\n     data :{\n         where : {\n           user : {\n             $inQuery : {\n               location : {\n                 $nearSphere : {\n                   __type :  GeoPoint ,\n                   latitude : 30.0,\n                   longitude : -20.0\n                },\n                 $maxDistanceInMiles : 1.0\n              }\n            }\n          }\n        },\n         data : {\n           alert :  Free hotdogs at the bmob concession stand! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  上面的例子假设 installation 有个 user 属性指向_User 表的记录，并且用户有个 location 属性是 GeoPoint 类型，我们就可以根据地理信息位置做推送。", 
            "title": "根据地理信息位置做推送"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_49", 
            "text": "发送给Android单个客户端    push.send({\n     data :{\n         where :{\n             installationId : 12345678-4312-1234-1234-1234567890ab \n            },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  发送给iOS单个客户端    push.send({\n     data :{\n         where :{\n             deviceToken : abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 \n            },\n         data : {\n           alert :  Hello From Bmob. \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "点播推送消息"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_50", 
            "text": "推送通知不仅仅可以用来发送消息，iOS中，推送内容还可以包含要播放的声音和要显示的badge数字值,还可以定制任何你想发送的内容，对于Android，你甚至可以指定Intent应用于接收消息，对于时间性有要求的消息您还可以设置一个消息过期时间。", 
            "title": "发送选项设置"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_51", 
            "text": "如果你想发送更多的消息，你可以在data的字典对象中设置其他字段，下面这些保留的字段有其特殊的意义：\n-  alert  : 通知的消息内容\n-  badge  : (仅iOS)一个数字值将会高亮显示在应用图标的右上角\n-  sound  : (仅iOS)应用绑定包中的声音文件 \n-  content-available  : (仅iOS)如果你的应用是新闻类的，或者你的应用正在使用iOS7的Remote Notification Background Mode，设定这个值为1将为触发离线下载功能。\n-  action  : (仅Android)接收到推送消息时应用Intent，如果没有指定title或alert，Intent将被应用，但是没有通知呈现给用户。\n-  title  : (仅Android)这个值将显示在系统通知栏  例如，推送一条通知，将当前的badge值自增1,并且播放iOS设备上定制的音乐，对于Android用户，将在系统通知栏中显示特殊的标题，则请求如下：    push.send({\n     data :{\n         channels : [\n           Giants \n        ],\n         data : {\n           alert :  The Mets scored! The game is now tied 1-1. ,\n           badge : 1,\n           sound :  cheering.caf ,\n           title :  Mets Score! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  当然，你也可以在data字典对象中定制自己的字段，推送消息，但不显示在 Andoid 系统的通知栏中，而是执行应用程序预定义的逻辑，Android或iOS接收消息文档中对此有说明，iOS只有当用户从通知中打开应用，才能访问data的数据，Android将提供这个数据在action Intent应用之后,    push.send({\n     data :{\n         channels : [\n           Giants \n        ],\n         data : {\n           alert :  The Mets scored! The game is now tied 1-1. ,\n           badge :  Increment ,\n           sound :  cheering.caf ,\n           title :  Mets Score! \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "定制您的通知"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_52", 
            "text": "过期时间，可以是绝对时间：    push.send({\n     data :{\n         expiration_time :  2015-12-04 00:51:13 ,\n         data : {\n           alert :  Season tickets on sale until December  4, 2013 \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });  也可以是相对时间（根据push_time做定期推送，从push_time时间开始算起，直到expiration_interval时间后过期），下面请求表示消息将在2012-01-28 00:51:13这个时间点开始推送，直到7天后过期:    push.send({\n     data :{\n         push_time :  2012-01-28 00:51:13 ,\n         expiration_interval : 518400,\n         data : {\n           alert :  Season tickets on sale until December  4, 2013 \n        }\n      }\n  },function(err,data){\n     //回调函数\n  });", 
            "title": "设置消息过期时间"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_53", 
            "text": "Bmob的邮件发送对象采用Nodejs提供的nodemailer模块，这里提供简单的一个发送邮件的操作实例。更多的功能详细参考： https://npmjs.org/package/nodemailer  function onRequest(request, response, modules) {\n//获得发送邮件的对象 \nvar mailer = modules.oMail; \n//设置发送服务器信息 \nvar  transport = mailer.createTransport(  SMTP  , {\n    host:  smtp.126.com  ,\n    secureConnection: true , // use SSL\n    port: 465, // port for secure SMTP\n    auth: {\nuser:  bmobtest111@126.com , //设置发送邮箱帐号 \npass:  xxx  //设置发送邮箱密码 \n    }\n});\n\ntransport.sendMail({\n    from :  bmobtest111@126.com  ,\n    to :  test@126.com  ,\n    subject:  主题  ,\n    generateTextFromHTML : true ,\n    html :  啊哈哈哈 \n}, function (error, responseback){\n\n    transport.close();\n     if(error){\n        //发送失败\n    }else{\n        //发送成功\n        response.send( 发送成功 );\n    }\n});\n\n\n\n}", 
            "title": "邮件发送对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#http_1", 
            "text": "oHttp对象可以模拟实现get、post、put、delete等各种HTTP请求信息，让你在云端实现诸如数据采集、OAuth授权登录等功能。Bmob的HTTP请求模块采用Nodejs提供的request模块，这里提供简单的Get和Post的操作实例。更多的功能详细参考： https://npmjs.org/package/request  /**\n*发起Get请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//发起Get请求\nhttp('http://www.bmob.cn', function (error, res, body) {\n    if (!error   res.statusCode == 200) {\n      response.send(body);\n    }\n})\n\n-\n\n/**\n*发起Post请求\n*/\n//获取Http模块\nvar http = modules.oHttp;\n//往http://bmob.cn/save发起POST请求\nhttp.post('http://bmob.cn/save', {form:{key:'value'}})", 
            "title": "HTTP请求对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_54", 
            "text": "oEvent，也就是eventproxy模块，解决异步回调的问题。  更多的功能详细参考： https://github.com/JacksonTian/eventproxy  function onRequest(request, response, modules) {\n\n    var ep = modules.oEvent;  //eventproxy模块，解决异步回调的问题\n\n    ep.after('got_file', 3, function (list) {\n        response.send( len: +list.length);\n\n    });\n\n    //发送3次事件后触发事件，输出list的长度\n    ep.emit( got_file ,  1 );  \n    ep.emit( got_file ,  1 );  \n    ep.emit( got_file ,  1 );  \n\n\n}", 
            "title": "事件对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#encode", 
            "text": "Encode对象可以实现字符编码的转换。更多的功能详细参考： https://www.npmjs.org/package/encoding  Encode对象就一个方法convert()，使用方法为：encoding.convert(text, toCharset, fromCharset)。  text: 需要转换的对象，可以为Buffer或者String对象。  toCharset: 转换后的编码。  fromCharset: 转换前的编码，缺省为uft8。  转换后的输入结果为Buffer对象。  var encoding = modules.oEncodeing;\nvar result = encoding.convert( 禅 , gbk , utf8 );\nresponse.send(result.toString());", 
            "title": "Encode编码转换对象"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#htmlohtmlparser", 
            "text": "html元素解析对象可以实现html的解释。更多的功能详细参考： https://www.npmjs.org/package/htmlparser  代码例子  function onRequest(request, response, modules) {\n    var htmlparser = modules.oHtmlparser;\n    var rawHtml =  a href='test.html' xxx /a ;\n    var handler = new htmlparser.DefaultHandler(function (error, dom) {});\n    var parser = new htmlparser.Parser(handler);\n    parser.parseComplete(rawHtml);\n    response.send(JSON.stringify(handler.dom, null, 2));\n\n}                                                                                                                           代码的输出：  [\n  {\n     raw :  a href='test.html' ,\n     data :  a href='test.html' ,\n     type :  tag ,\n     name :  a ,\n     attribs : {\n       href :  test.html \n    },\n     children : [\n      {\n         raw :  xxx ,\n         data :  xxx ,\n         type :  text \n      }\n    ]\n  }\n]", 
            "title": "html元素解析对象（oHtmlparser）"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#bqlobql", 
            "text": "我们提供类 SQL 语法的 BQL 查询语言来查询数据  下面的代码例子就是查询GameScore表的所有数据  function onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n       bql : select * from GameScore \n    },function(err,data){\n      response.send(data);\n    });\n\n\n}                                                                                                                          BQL 还支持占位符查询，where 和 limit 子句的条件参数可以使用问号替换，然后通过 values 数组传入：  function onRequest(request, response, modules) {\n    //获得bql的对象 \n    var Bql = modules.oBql; \n\n    Bql.exec({\n       bql : select * from GameScore where name=? limit ?,?  ,\n       values : [\\ tom\\ ,0,100] \n    },function(err,data){\n      response.send(data);\n     //回调函数\n    });\n\n\n}                                                                           更多请参考  BQL 详细指南  。", 
            "title": "bql对象（oBql）"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#ocrypto", 
            "text": "提供md5和sha1两种加密算法。更多的功能详细参考： https://www.npmjs.org/package/crypto  代码例子    function onRequest(request, response, modules) {\n    var crypto = modules.oCrypto;\n    var md5 = crypto.createHash('md5');\n    md5.update( hello ); //输入要md5的内容\n    response.send(md5.digest('hex'));//以16进制编码\n}", 
            "title": "加密对象（oCrypto）"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_55", 
            "text": "为方便开发者调试云端逻辑，Bmob为开发者提供了便捷的云端调试工具，你可以直接在云端逻辑的编辑页面下对编写的代码进行调试，如实现从Bar表中查找指定objectId号（SDK中上传参数）的数据，你可以在云端逻辑中实现如下：  function onRequest(request, response, modules) {\n  var db = modules.oData;\n  db.findOne({\n     table : Bar ,\n     objectId :request.body.objectId\n  },function(err,data){ //回调函数\n     response.send( 成功   + data);\n  });\n}  调试时，你在云端调试工具中输入参数名为objectId，参数值为你想要查询的信息，如下图，即可查看到调试结果。", 
            "title": "云端逻辑调试工具"
        }, 
        {
            "location": "/module/develop_doc/README/index.html#_56", 
            "text": "Bmob提供的官方模块（非第三方）的错误回调中都会有一个 err 对象，这个 err 对象包含两个属性： error 和 code ，分别代表错误异常信息和错误代码。调用时可以简单如下使用：  function onRequest(request, response, modules) {\n    var db = modules.oData;\n    db.findOne({\n         table : YourTableName ,\n         objectId :request.body.oid\n    },function(err,data){ \n        //对返回结果进行处理\n        if(err)  response.send( error is    + err.code  +  error message is   + err.error );\n        else response.send(data);\n    });\n}", 
            "title": "错误对象"
        }, 
        {
            "location": "/module/timing_task/README/index.html", 
            "text": "定时任务\n\n\n定时任务是专门为云端代码提供定时服务，用来定时触发云端代码的特定操作，满足比如定时计算排行榜等需求。规则如下：\n\n\n注意：免费版用户最短间隔时间须大于1小时，否则规则无法保存，付费版用户不受该限制。\n\n\n具体规则写法如下：\n\n\n\n\n\n\n\n\n字段名\n\n\n取值范围\n\n\n\n\n\n\n\n\n\n\n秒\n\n\n0到59\n\n\n\n\n\n\n分\n\n\n0到59\n\n\n\n\n\n\n小时\n\n\n0到23\n\n\n\n\n\n\n天\n\n\n1到31\n\n\n\n\n\n\n月\n\n\n1到12\n\n\n\n\n\n\n星期\n\n\n0到6, 分别对应：星期天、星期一、星期二、星期三、星期四、星期五、星期六\n\n\n\n\n\n\n\n\n“* * * * * *”分别对应：秒 分 时 日 月 星期。当星期的字段填了数字时，天和月的字段就应为“*”。具体例子如下：\n\n\n1.“* * * * * *”，表示每一秒，触发定时器一次。\n\n\n2.“1 * * * * *”，表示每分钟的秒数是1时，触发定时器一次。\n\n\n3.“0 0 * * * *”，表示每小时，触发定时器一次。\n\n\n4.“0 0 16 * * *”，表示每天的16时0分0秒，触发定时器一次。\n\n\n5.“0 0 0 1 * *”，表示每个月的1号0时0分0秒，触发定时器一次。\n\n\n6.“0 0 0 * * 0”，表示每个星期天的0时0分0秒，触发定时器一次。\n\n\n7.“0 0 0 1 5 *”，表示每年的5月的1号0时0分0秒，触发定时器一次。\n\n\n8.“* 0 * * * *”，表示每小时的0分里面的每一秒，触发定时器一次，即定时器触发了60次，一秒一次。\n\n\n9.“*/3 * * * * *”，表示每分钟的秒数是3的倍数时，触发定时器一次。\n\n\n10.“0 */10 * * * *”，表示每小时的0分、10分、20分、30分、40分、50分，触发定时器一次。\n\n\n11.“* * */5 * * *”，表示每天的0时、5时、10时、15时、20时里面的每一秒钟都触发定时器一次。\n\n\n12.“0 0 0 */10 * *”，表示每个月的10号、20号、30号的凌晨，触发定时器一次。\n\n\n13.“0 0 0 * * */3”，表示每个星期三和星期六的凌晨，触发定时器一次。", 
            "title": "定时任务"
        }, 
        {
            "location": "/module/timing_task/README/index.html#_1", 
            "text": "定时任务是专门为云端代码提供定时服务，用来定时触发云端代码的特定操作，满足比如定时计算排行榜等需求。规则如下：  注意：免费版用户最短间隔时间须大于1小时，否则规则无法保存，付费版用户不受该限制。  具体规则写法如下：     字段名  取值范围      秒  0到59    分  0到59    小时  0到23    天  1到31    月  1到12    星期  0到6, 分别对应：星期天、星期一、星期二、星期三、星期四、星期五、星期六     “* * * * * *”分别对应：秒 分 时 日 月 星期。当星期的字段填了数字时，天和月的字段就应为“*”。具体例子如下：  1.“* * * * * *”，表示每一秒，触发定时器一次。  2.“1 * * * * *”，表示每分钟的秒数是1时，触发定时器一次。  3.“0 0 * * * *”，表示每小时，触发定时器一次。  4.“0 0 16 * * *”，表示每天的16时0分0秒，触发定时器一次。  5.“0 0 0 1 * *”，表示每个月的1号0时0分0秒，触发定时器一次。  6.“0 0 0 * * 0”，表示每个星期天的0时0分0秒，触发定时器一次。  7.“0 0 0 1 5 *”，表示每年的5月的1号0时0分0秒，触发定时器一次。  8.“* 0 * * * *”，表示每小时的0分里面的每一秒，触发定时器一次，即定时器触发了60次，一秒一次。  9.“*/3 * * * * *”，表示每分钟的秒数是3的倍数时，触发定时器一次。  10.“0 */10 * * * *”，表示每小时的0分、10分、20分、30分、40分、50分，触发定时器一次。  11.“* * */5 * * *”，表示每天的0时、5时、10时、15时、20时里面的每一秒钟都触发定时器一次。  12.“0 0 0 */10 * *”，表示每个月的10号、20号、30号的凌晨，触发定时器一次。  13.“0 0 0 * * */3”，表示每个星期三和星期六的凌晨，触发定时器一次。", 
            "title": "定时任务"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html", 
            "text": "简介\n\n\n在这篇微信公众平台开发教程中，将会带领你一步步领略使用云后端服务bmob的方便性，同时使用bmob进行微信公众号平台开发。\n\n\n注意：升级云端代码套餐后就没法在微信公众号中调用云端代码\n\n\n使用bmob有什么好处，下面一一为你道来：\n\n\n\n\n不需要购买服务器，不需要懂linux，不需要懂运维知识，零成本地拥有属于自己的后台系统。\n\n\n不在需要mysql，轻松存储和获取数据，同时提供了一个方便的数据管理后台。\n\n\n提供灵活的“云端逻辑”，其融合了bmob的数据服务和大量的第三方服务，让你轻松应对复杂的业务逻辑。同时云端逻辑能被第三方平台调用，再也不需要php，java等复杂的web服务。\n\n\n\n\n本教程将引导你完成如下任务：\n\n\n\n\n创建bmob应用\n\n\n使用bmob云端逻辑实现微信公众平台的开发\n\n\n\n\n创建bmob应用\n\n\n在这节中，将会从基本的创建bmob账号开始，到创建应用，数据的基本操作，到云端逻辑的运行，使读者对bmob的功能有初步的了解。\n\n\n在这个教程中，用到了bmob的两个功能：\n\n\n\n\n\n\n数据存储：把订阅者发到微信公众号的信息存储起来。\n\n\n\n\n\n\n云端逻辑：微信后台回调云端逻辑后，完成公众号所需的业务逻辑：信息存储，把信息加工后返回给订阅者的微信。\n\n\n\n\n\n\n注册bmob账号\n\n\n在网址栏输入\nwww.bmob.cn\n或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，如下图1所示：\n\n\n\n\n注册成功，到注册所填入的邮箱查看bmob发送的邮件，点击其中激活链接后，就能使用邮箱和密码登录bmob。\n\n\n创建应用\n\n\n登录后，点击“我的控制台”，进入到了管理后台，如下图2所示：\n\n\n\n在bmob中，一个用户可以创建多个应用，每个应用拥有其所属的专用数据库，多个应用之间相互独立。\n\n\n用户需要创建一个应用，先点击管理后台中的“创建应用”按钮，如下图3所示：\n\n\n\n\n在创建应用的输入框中输入app的名称，点击“创建应用”，就能成功创建应用，如下图4所示：\n\n\n\n\n数据的基本操作\n\n\n创建应用成功后，开发者在管理后台点击刚才创建的应用，进入到应用的后台界面，其中最常用的是“数据浏览界面”，在该界面提供了便利的图形化操作，让开发者轻松地对该应用所属的数据库进行表的增删，数据的增删改查等操作，如下图5所示：\n\n\n\n\n每个应用的数据库都有一个默认的表\"_User\",其提供了一些常用的字段来记录该应用的用户信息。\n\n\n开发者需要增加新的表来存储信息时，点击“添加表”按钮，输入表名，就能创建一张新表，如下图6所示：\n\n\n\n\n在\"添加新的表\"界面中,选项“自定义”选项即可创建一张新的普通表，另外两个选项是较高级的功能，在本教程中暂时不需要用到。\n\n\n在这里，创建了一张名为\"message\"的表，用于存储订阅者发送到公众号后台的信息。\n\n\n在表\"message\"的操作界面中可看到，表\"message\"有4个默认的字段，其中3个最常用字段的含义如下：\n\n\n\n\nobjectId：该行的id，objectId的作用和mysql中的经常使用的id类似，用于唯一标示一行。\n\n\ncreatedAt：改行数据的创建时间。\n\n\nupdatedAt：改行数据的最后修改时间。\n\n\n\n\n当操作一行数据的时候，以上的3个字段的值由bmob后台自动管理。另外这些字段的名字是保留的，你不能自行设置它们。\n\n\n由于表\"message\"是需要把订阅者发到微信公众号的信息存储起来，存储信息的两个属性：谁发送这条信息，信息的内容，所以添加下面所需的字段：\n\n\nuserId：订阅者的id，String类型。\ncontent：发送的内容，String。\n\n\n通过图8的“添加一列”功能，依次把userId和content这两个字段添加到表\"message\"中。\n\n\n\n\n注意：在用云端逻辑添加数据时，如果发现其所操作的表和所操作的列不存，bmob后台会自动创建。这里为了演示bmob的数据浏览操作，所以才手动创建一次。\n\n\n云端逻辑\n\n\n阅读了上面的“数据的基本操作”的内容后，读者可能有个疑问，怎么对表的数据进行增删改查等操作呢？除了可以在\"数据浏览\"界面可以进行操作外，也可以通过云端逻辑进行数据的增删改查，开发者也可以通过云端逻辑完成更加复杂的业务逻辑。\n\n\n云端逻辑的基本知识\n\n\n对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob 云端逻辑提供了这种灵活性，可以让您的代码直接在 Bmob云上运行, 通过SDK（Android，iOS），restful api或者任何http的方式调用，即可获取结果数据。\n\n\n云端逻辑的编码采用nodejs语法，简单易用。在云端逻辑的编辑器中，系统默认生成了云端逻辑的入口函数function onRequest(request, response, modules)，你可以根据自己的需求实现业务逻辑代码。 \n\n\n在云端逻辑界面，创建一个名为\"helloworld\"的云端逻辑，如下图9所示：\n\n\n\n\n生成云端逻辑后，可看到云端逻辑生成的入口方法，如下图10所示：\n\n\n\n\n开发者按照云端逻辑的相关语法和提供的模块编写云端逻辑，就能实现各种业务逻辑。\n\n\n从云端逻辑的入口方法function onRequest(request, response, modules)可知，云端逻辑包含三个模块，分别是request模块、response模块和modules模块。\n\n\nrequest模块\n\n\nrequest模块用于获取传入的参数。由于现在调用云端逻辑有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。\n\n\n当用get请求的方式传入参数，可用如下的方法获取参数的值：\n\n\nrequest.query.name  //获取传入参数name的值\n\n\n\n\n当用post请求的方式传入参数，可用如下的方法获取参数的值：\n\n\nrequest.body.name  //获取传入参数name的值\n\n\n\n\nresponse模块\n\n\nresponse为云端逻辑的信息回传模块，该模块包含了一个end方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：\n\n\nresponse.end(string result)\n\n\n\n\nmodules模块\n\n\nmodules是Bmob云端逻辑提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云端逻辑对象（oFunctions）、邮件发送对象（oMail）、同步对象（oAsync）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云端逻辑想要调用这些对象时，只需要用如下的方法即可获取：\n\n\n  //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作\n\n\n\n\n用云端逻辑实现\"helleworld\"\n\n\n下面用云端逻辑输出一个经典的\"helleworld\"程序，让开发者对编写云端逻辑有个初步的了解。\n\n\n输出\"helleworld\"的云端逻辑如下：\n\n\nfunction onRequest(request, response, modules) {\n    response.end(\nthis is hello world\n);  //返回字符串\nthis is hello world\n\n}                         \n\n\n\n\n在\"helloworld\"的云端逻辑编辑界面上输入上面的代码，按下“保存”按钮就能把编辑完毕的代码保存在云端，如下图11所示：\n\n\n\n\n怎么运行上面编辑完毕云端逻辑呢？bmob在每个云端逻辑的编辑界面下方提供了一个方便的调试工具，如下图12所示：\n\n\n\n\n这个工具有下面的功能：\n\n\n\n\n可选择以http \"post\"或者\"get\"的方法运行云端逻辑。\n\n\n选择request的参数和对应值：可添加传入云端逻辑的request的参数和对应值，参数的数目可以通过“再添加一个”按钮调整。\n\n\n\n\n需要运行名称为\"helloworld\"的云端逻辑，在\"helloworld\"的云端逻辑编辑界面下点击“发送请求”按钮，就能在调试工具上看到云端逻辑返回的字符串“this is hello world”，如下图13所示：\n\n\n\n\n整个云端逻辑的执行流程如图13.1所示：\n\n\n\n\n调用云端逻辑的方式\n\n\n除了使用bmob提供的云端逻辑调式工具外，bmob允许开发者以http的方式直接调用云端逻辑。\n\n\n获取Secret Key\n\n\n用户需要以http的方式运行云端逻辑，需要先确定应用的Secret Key。 调用云端逻辑时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台-\n应用密钥-\nSecret Key, 如下图14所示：\n\n\n\n\n注意：请妥善保管Secret Key，避免Secret Key的泄露！！！\n\n\n以Get的方式调用云端逻辑\n\n\n下面展示了以Get的方式调用云端逻辑，在浏览器中输入下面的url：\n\n\nhttp://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld\n\n\n\n\n其中：\n\n\n\n\na12af19a1b8bf434：应用的Secret Key。\n\n\nhelloworld：云端逻辑的名称\n\n\n\n\n看到云端逻辑的返回结果如下图15所示：\n\n\n\n\n以Post的方式调用云端逻辑\n\n\n下面通过curl工具展示了以Post的方式调用云端逻辑：\n\n\ncurl -X POST \\\n    http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld\n\n\n\n\n其中：\n\n\n\n\na12af19a1b8bf434：应用的Secret Key。\n\n\nhelloworld：云端逻辑的名称\n\n\n\n\n云端逻辑操作数据库初步入门\n\n\nbmob提供了数据库对象（oData）用于操作数据。\n\n\n用云端逻辑往数据表“message”插入一条数据，可用如下的代码\n\n\nfunction onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.insert({\n      \ntable\n:\nmessage\n,             //表名\n      \ndata\n:{\nuserId\n:\ndsfd2324\n,\ncontent\n:\n插入的第一条信息\n}            //需要插入的数据，格式为JSON\n    },function(err,data){         //回调函数\n        response.end(\nsuccess\n);  //运行完毕后返回“success”\n    });\n}                         \n\n\n\n\n点击保存后在云端逻辑调试区按“发送请求”，返回“success”的值，如下图16所示：\n\n\n\n\n在管理后台-\n数据浏览-\n应用表“message”下查看通过云端逻辑新增的数据，如下图17所示：\n\n\n\n\n用云端逻辑查询表“message”的所有数据，可用如下的代码：\n\n\nfunction onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.find({\n      \ntable\n:\nmessage\n             //表名\n    },function(err,data){         //回调函数\n        response.end(data);       //data为返回的数据，格式为json\n    });\n}                                                 \n\n\n\n\n点击保存后在云端逻辑调试区按“发送请求”，返回表“message”的数据，如下图18所示：\n\n\n\n\n需要了解更多云端逻辑的操作，可阅读\nhttp://docs.bmob.cn/cloudcode/WEB/a_faststart/doc/index.html\n\n\n在编写云端逻辑时有个注意事项：云端逻辑是使用异步编程。也就是说，当遇到文件读写请求，网络请求等IO操作时，代码不等待IO操作返回结果就执行后面的语句,当接收到IO操作的返回结果后才调用回调函数。\n\n\n当使用php，java等非异步编程语言时，如果需要插入数据后再查找数据，可用类似下面的代码：\n\n\n    db-\ninsert(xxxxx);\n    db-\nfind(xxxxx);                                                 \n\n\n\n\n在同步型的编程语言中，find和insert都是数据库的操作，有文件读写的IO操作，在db-\nfind执行前，能确保db-\ninsert已经执行完毕了。\n\n\n在异步编程中，用类似下面的代码才能保证执行完db.insert后才执行：\n\n\n    db.insert({xxx},function(xxx){\n        db.find({xxx},function(xxx){xxxx});\n    });\n\n\n\n\n\n只有通过在db.insert的回调函数中执行db.find，才能保证执行db.find前db.insert的数据库操作已经完成。\n\n\n举个生活中的例子说明异步编程。在饭馆里，服务员接待客人一般是这样的：\n\n\n\n\n服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员在旁边一直等待，当客户点菜后，服务员把订单交给厨房后继续干别的事情。\n\n\n\n\n采用异步模式的服务员可以这样接待客人：\n\n\n\n\n服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员就去干别的事情。当客户决定点菜后，客人把服务员招来，服务员把客人下的订单交给厨房后继续干别的事情。\n\n\n\n\n在服务员接待客人的行为中，通过比较普通的做法和异步的做法，能发现采用异步的方法后服务员的效率大大提高，云端逻辑使用异步也是基于同样的理由，当云端逻辑在等待IO操作（文件读写请求，网络请求）的结果时是一直空闲，如果不等待IO的结果继续执行下面的语句，能大大提高系统的效率。\n\n\n在云端逻辑异步编程中“function(xxx){xxxx}”部分称为回调函数，云端逻辑会把IO操作的返回结果封装后传入到function函数执行里面的逻辑。\n\n\n    db.insert({xxx},function(xxx){xxxx});                            \n\n\n\n\n微信公众平台的开发\n\n\n在本节中，通过bmob云端逻辑开发微信公众平台，实现一个反馈意见收集的功能：\n1.把订阅者发送到公众号后台的反馈意见存储在上一节在bmob中创建的表“message”中。\n2.订阅者提交反馈意见后，公众号自动给订阅者发送消息，表示消息已收到。\n\n\n创建云端逻辑\n\n\n创建一个名为\"feedback\"的云端逻辑用于实现上面的功能，代码如下：\n\n\n\nfunction onRequest(request, response, modules) {\n    var token = \nweixin\n;         //这里的值必须与在微信公众号后台填入的token值一致\n    var crypto = modules.oCrypto; //使用加解密模块\n    var httptype = modules.oHttptype;　//获取调用云端逻辑的是post或者get方式\n    var xml2js = modules.oXml2js;　//实现xml和js格式之间的相互转换\n    var db = modules.oData;         //数据库对象\n    if (\nget\n == httptype) {\n        　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end(\nUnauthorized\n);\n          }\n    } else {\n           //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n              \ntable\n:\nmessage\n,             //表名\n              \ndata\n:{\nuserId\n:request.body.xml.FromUserName,\ncontent\n:request.body.xml.Content}           \n            },function(err,data){                        \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });\n\n\n\n    }\n}                                                                         \n\n\n\n\n\n这个云端逻辑的内容暂时看不懂没关系，下面会逐渐解释其中的含义。\n\n\n启用微信公众号的开发模式\n\n\n只有启用微信公众号的开发模式后，才能把订阅者发送到微信公众号后台的消息发送到bmob云端逻辑中进行处理。\n\n\n微信公众平台地址：\nhttps://mp.weixin.qq.com \n\n\n登录微信公众平台后台，在左侧列表中最下方，找到“开发者中心”，点击进入，如图19所示：\n\n\n\n\n进入服云端逻辑务器配置填写框，如图20所示：\n\n\n\n\n点击“修改配置”按钮，如图21所示：\n\n\n\n\n此处的URL（http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/feedback）为上节中生成的云端逻辑“feedback”的调用，按照云端逻辑的调用规格，a12af19a1b8bf434为该应用的Secret Key，标明调用的是哪个应用，feedback为云端逻辑的名称。Token定义为weixin。EncodingAESKey则不用填，点击“随机生成”让自动生成一个，消息加解密方式选择“明文模式”，然后点击“提交”按钮，如图22所示：\n\n\n\n\n在弹出框中点击确定，如图24所示：\n\n\n\n\n成功启用后如图25所示：\n\n\n\n\n恭喜，你成功启用开发模式。\n\n\n用户往该公众号发送消息后，用户收到的反馈内容如图27所示：\n\n\n\n\n查看应用的后台，可看到接收的消息已存储在表message中，如图28所示：\n\n\n\n\n数据收发原理及消息数据格式\n\n\n云端逻辑开发微信公众号有两个重要原理一定要弄明白：\n\n\n\n\n变为开发模式时，微信公众号后台往配置的url发送校验请求，这个过程云端逻辑校验信息的原理。\n\n\n云端逻辑收发微信公众号后台传递过来的消息的原理。\n\n\n\n\n变为开发模式时的消息校验原理\n\n\n在开发者首次提交验证申请时，微信公众号后台将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（signature）的效验来判断此条消息的真实性。\n\n\n这4个参数的含义如下：\n\n\n\n\nsignature：微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。\n\n\ntimestamp：时间戳。\n\n\nnonce：随机数\n\n\nechostr：随机字符串\n\n\n\n\n此后，每次开发者接收用户消息的时候，微信公众号后台也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。\n\n\n开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信公众号后台，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。\n\n\n消息校验流程如下：\n\n\n\n\n将token、timestamp、nonce三个参数进行字典序排序。\n\n\n将三个参数字符串拼接成一个字符串进行sha1加密。\n\n\n开发者获得加密后的字符串可与signature对比，标识该请求来源于微信。\n\n\n\n\n整个流程如图26所示：\n\n\n\n\n使用的云端逻辑如下：\n\n\n        　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end(\nUnauthorized\n);\n          }\n\n\n\n\n其中token的值是在微信公众号后台填入的token值：“weixin”。\n\n\n在这个校验流程的云端逻辑中，使用oCrypto这个云端逻辑的加密对象模块，提供md5和sha1两种加密算法。通过这个模块，按照微信校验的流程完成校验。oCrypto更多的功能详细参考：https://www.npmjs.org/package/crypto\n\n\n另外，云端逻辑使用了oHttptype模块获取当前的http调用方式。因为微信公众平台调用云端逻辑有两种方式：\n\n\n\n\nget方式，用于检验。\n\n\npost方式，用于转发订阅者往公众平台发送的消息。\n\n\n\n\n通过oHttptype模块得知是用采用get方式调用云端逻辑，运行校验的代码并返回echostr参数。\n\n\n云端逻辑收发微信公众号后台传递过来的消息的原理\n\n\n在上一节的演示中，订阅者往该公众号发送消息后，返回已收到反馈内容的消息。\n\n\n这一原理的消息流程如图29所示：\n\n\n\n\n云端逻辑内部通过下面的代码处理用户发送的消息：\n\n\n           //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n              \ntable\n:\nmessage\n,             //表名\n              \ndata\n:{\nuserId\n:request.body.xml.FromUserName,\ncontent\n:request.body.xml.Content}           \n            },function(err,data){         \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });\n\n\n\n\n从上图可以看出，用户在发送一个文本后，微信公众号后台将组装一个xml消息发送给云端逻辑服务器。当云端逻辑接收到http头部Content-Type为text/xml的请求后，云端逻辑自动把xml消息转换为一个对象放在request.body.xml中，通过获取request.body.xml对应的属性就能获取xml节点的值。\n\n\n云端逻辑解析xml对象，根据节点信息，把发送者(request.body.xml.FromUserName)和消息内容（request.body.xml.Content）存储在表“message”后，然后通过一定的规则组装成一个xml文本回复给微信公众号后台，微信公众号后台再回复给用户。在这个收发过程中，发送方和接收方进行了调换(ToUserName和FromUserName值互换)，收发都是以xml格式在后台进行传输的。所以掌握各种消息类型的接收回复是进行微信公众平台开发的基础！\n\n\n最常见的消息类型为文本的xml格式如下：\n\n\nxml\n\n\nToUserName\n![CDATA[gh_b36303ca8941]]\n/ToUserName\n\n\nFromUserName\n![CDATA[oqwUds6-SG7L8t6ZBDexZvaRWnXM]]\n/FromUserName\n\n\nCreateTime\n1444464955\n/CreateTime\n\n\nMsgType\n![CDATA[text]]\n/MsgType\n\n\nContent\n![CDATA[这个公众号不错]]\n/Content\n\n\nMsgId\n6203929742163889773\n/MsgId\n\n\n/xml\n                                           \n\n\n\n\nXML格式讲解：\n\n\n\n\nToUserName 消息接收方微信号，一般为公众平台账号微信号\n\n\nFromUserName 消息发送方微信号\n\n\nCreateTime 消息创建时间\n\n\nMsgType 消息类型；文本消息为text\n\n\nContent 消息内容\n\n\nMsgId 消息ID号\n\n\n\n\n各种类型的消息详解，请查看微信开发文档：\nhttp://mp.weixin.qq.com/wiki/14/89b871b5466b19b3efa4ada8e577d45e.html\n\n\n总结\n\n\n通过本教程，你得到了以下收获：\n\n\n\n\n了解bmob应用和云端逻辑的功能。\n\n\n在不需要搭建服务器，不需要懂得基本的运维知识下，使用bmob云端逻辑在30分钟内实现微信公众平台的开发，完了消息存储和消息自动回复这两个功能。\n\n\n\n\n阅读本教程后，想了解云后端服务bmob可以实现哪些更酷的功能吗？点击\nhttp://www.bmob.cn\n，立刻进入bmob了解更多。", 
            "title": "微信云代码"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_1", 
            "text": "在这篇微信公众平台开发教程中，将会带领你一步步领略使用云后端服务bmob的方便性，同时使用bmob进行微信公众号平台开发。  注意：升级云端代码套餐后就没法在微信公众号中调用云端代码  使用bmob有什么好处，下面一一为你道来：   不需要购买服务器，不需要懂linux，不需要懂运维知识，零成本地拥有属于自己的后台系统。  不在需要mysql，轻松存储和获取数据，同时提供了一个方便的数据管理后台。  提供灵活的“云端逻辑”，其融合了bmob的数据服务和大量的第三方服务，让你轻松应对复杂的业务逻辑。同时云端逻辑能被第三方平台调用，再也不需要php，java等复杂的web服务。   本教程将引导你完成如下任务：   创建bmob应用  使用bmob云端逻辑实现微信公众平台的开发", 
            "title": "简介"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#bmob", 
            "text": "在这节中，将会从基本的创建bmob账号开始，到创建应用，数据的基本操作，到云端逻辑的运行，使读者对bmob的功能有初步的了解。  在这个教程中，用到了bmob的两个功能：    数据存储：把订阅者发到微信公众号的信息存储起来。    云端逻辑：微信后台回调云端逻辑后，完成公众号所需的业务逻辑：信息存储，把信息加工后返回给订阅者的微信。", 
            "title": "创建bmob应用"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#bmob_1", 
            "text": "在网址栏输入 www.bmob.cn 或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，如下图1所示：   注册成功，到注册所填入的邮箱查看bmob发送的邮件，点击其中激活链接后，就能使用邮箱和密码登录bmob。", 
            "title": "注册bmob账号"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_2", 
            "text": "登录后，点击“我的控制台”，进入到了管理后台，如下图2所示：  在bmob中，一个用户可以创建多个应用，每个应用拥有其所属的专用数据库，多个应用之间相互独立。  用户需要创建一个应用，先点击管理后台中的“创建应用”按钮，如下图3所示：   在创建应用的输入框中输入app的名称，点击“创建应用”，就能成功创建应用，如下图4所示：", 
            "title": "创建应用"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_3", 
            "text": "创建应用成功后，开发者在管理后台点击刚才创建的应用，进入到应用的后台界面，其中最常用的是“数据浏览界面”，在该界面提供了便利的图形化操作，让开发者轻松地对该应用所属的数据库进行表的增删，数据的增删改查等操作，如下图5所示：   每个应用的数据库都有一个默认的表\"_User\",其提供了一些常用的字段来记录该应用的用户信息。  开发者需要增加新的表来存储信息时，点击“添加表”按钮，输入表名，就能创建一张新表，如下图6所示：   在\"添加新的表\"界面中,选项“自定义”选项即可创建一张新的普通表，另外两个选项是较高级的功能，在本教程中暂时不需要用到。  在这里，创建了一张名为\"message\"的表，用于存储订阅者发送到公众号后台的信息。  在表\"message\"的操作界面中可看到，表\"message\"有4个默认的字段，其中3个最常用字段的含义如下：   objectId：该行的id，objectId的作用和mysql中的经常使用的id类似，用于唯一标示一行。  createdAt：改行数据的创建时间。  updatedAt：改行数据的最后修改时间。   当操作一行数据的时候，以上的3个字段的值由bmob后台自动管理。另外这些字段的名字是保留的，你不能自行设置它们。  由于表\"message\"是需要把订阅者发到微信公众号的信息存储起来，存储信息的两个属性：谁发送这条信息，信息的内容，所以添加下面所需的字段：  userId：订阅者的id，String类型。\ncontent：发送的内容，String。  通过图8的“添加一列”功能，依次把userId和content这两个字段添加到表\"message\"中。   注意：在用云端逻辑添加数据时，如果发现其所操作的表和所操作的列不存，bmob后台会自动创建。这里为了演示bmob的数据浏览操作，所以才手动创建一次。", 
            "title": "数据的基本操作"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_4", 
            "text": "阅读了上面的“数据的基本操作”的内容后，读者可能有个疑问，怎么对表的数据进行增删改查等操作呢？除了可以在\"数据浏览\"界面可以进行操作外，也可以通过云端逻辑进行数据的增删改查，开发者也可以通过云端逻辑完成更加复杂的业务逻辑。", 
            "title": "云端逻辑"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_5", 
            "text": "对于一些复杂的应用，您可能希望增加一些特有的业务逻辑，并能灵活掌控，Bmob 云端逻辑提供了这种灵活性，可以让您的代码直接在 Bmob云上运行, 通过SDK（Android，iOS），restful api或者任何http的方式调用，即可获取结果数据。  云端逻辑的编码采用nodejs语法，简单易用。在云端逻辑的编辑器中，系统默认生成了云端逻辑的入口函数function onRequest(request, response, modules)，你可以根据自己的需求实现业务逻辑代码。   在云端逻辑界面，创建一个名为\"helloworld\"的云端逻辑，如下图9所示：   生成云端逻辑后，可看到云端逻辑生成的入口方法，如下图10所示：   开发者按照云端逻辑的相关语法和提供的模块编写云端逻辑，就能实现各种业务逻辑。  从云端逻辑的入口方法function onRequest(request, response, modules)可知，云端逻辑包含三个模块，分别是request模块、response模块和modules模块。", 
            "title": "云端逻辑的基本知识"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#request", 
            "text": "request模块用于获取传入的参数。由于现在调用云端逻辑有两种方式（get和post），所以获取传入的参数的方式需要使用不同的方法。  当用get请求的方式传入参数，可用如下的方法获取参数的值：  request.query.name  //获取传入参数name的值  当用post请求的方式传入参数，可用如下的方法获取参数的值：  request.body.name  //获取传入参数name的值", 
            "title": "request模块"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#response", 
            "text": "response为云端逻辑的信息回传模块，该模块包含了一个end方法，实现将云端的执行结果（如查询的数据）返回给SDK或者RestApi等调用端：  response.end(string result)", 
            "title": "response模块"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#modules", 
            "text": "modules是Bmob云端逻辑提供给大家的各种对象处理的模块，包括数据库对象（oData）、文件对象（oFile）、地理位置对象（oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、云端逻辑对象（oFunctions）、邮件发送对象（oMail）、同步对象（oAsync）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、加密对象（oCrypto）。云端逻辑想要调用这些对象时，只需要用如下的方法即可获取：    //获取数据库对象\n  var db = modules.oData;\n  //下面进行其他操作", 
            "title": "modules模块"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#helleworld", 
            "text": "下面用云端逻辑输出一个经典的\"helleworld\"程序，让开发者对编写云端逻辑有个初步的了解。  输出\"helleworld\"的云端逻辑如下：  function onRequest(request, response, modules) {\n    response.end( this is hello world );  //返回字符串 this is hello world \n}                           在\"helloworld\"的云端逻辑编辑界面上输入上面的代码，按下“保存”按钮就能把编辑完毕的代码保存在云端，如下图11所示：   怎么运行上面编辑完毕云端逻辑呢？bmob在每个云端逻辑的编辑界面下方提供了一个方便的调试工具，如下图12所示：   这个工具有下面的功能：   可选择以http \"post\"或者\"get\"的方法运行云端逻辑。  选择request的参数和对应值：可添加传入云端逻辑的request的参数和对应值，参数的数目可以通过“再添加一个”按钮调整。   需要运行名称为\"helloworld\"的云端逻辑，在\"helloworld\"的云端逻辑编辑界面下点击“发送请求”按钮，就能在调试工具上看到云端逻辑返回的字符串“this is hello world”，如下图13所示：   整个云端逻辑的执行流程如图13.1所示：", 
            "title": "用云端逻辑实现\"helleworld\""
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_6", 
            "text": "除了使用bmob提供的云端逻辑调式工具外，bmob允许开发者以http的方式直接调用云端逻辑。", 
            "title": "调用云端逻辑的方式"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#secret-key", 
            "text": "用户需要以http的方式运行云端逻辑，需要先确定应用的Secret Key。 调用云端逻辑时，通过Secret Key标识一个应用，获取Secret Key的路径：\n管理后台- 应用密钥- Secret Key, 如下图14所示：   注意：请妥善保管Secret Key，避免Secret Key的泄露！！！", 
            "title": "获取Secret Key"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#get", 
            "text": "下面展示了以Get的方式调用云端逻辑，在浏览器中输入下面的url：  http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld  其中：   a12af19a1b8bf434：应用的Secret Key。  helloworld：云端逻辑的名称   看到云端逻辑的返回结果如下图15所示：", 
            "title": "以Get的方式调用云端逻辑"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#post", 
            "text": "下面通过curl工具展示了以Post的方式调用云端逻辑：  curl -X POST \\\n    http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/helloworld  其中：   a12af19a1b8bf434：应用的Secret Key。  helloworld：云端逻辑的名称", 
            "title": "以Post的方式调用云端逻辑"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_7", 
            "text": "bmob提供了数据库对象（oData）用于操作数据。  用云端逻辑往数据表“message”插入一条数据，可用如下的代码  function onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.insert({\n       table : message ,             //表名\n       data :{ userId : dsfd2324 , content : 插入的第一条信息 }            //需要插入的数据，格式为JSON\n    },function(err,data){         //回调函数\n        response.end( success );  //运行完毕后返回“success”\n    });\n}                           点击保存后在云端逻辑调试区按“发送请求”，返回“success”的值，如下图16所示：   在管理后台- 数据浏览- 应用表“message”下查看通过云端逻辑新增的数据，如下图17所示：   用云端逻辑查询表“message”的所有数据，可用如下的代码：  function onRequest(request, response, modules) {\n    //获取数据库对象\n    var db = modules.oData;\n    db.find({\n       table : message              //表名\n    },function(err,data){         //回调函数\n        response.end(data);       //data为返回的数据，格式为json\n    });\n}                                                   点击保存后在云端逻辑调试区按“发送请求”，返回表“message”的数据，如下图18所示：   需要了解更多云端逻辑的操作，可阅读 http://docs.bmob.cn/cloudcode/WEB/a_faststart/doc/index.html  在编写云端逻辑时有个注意事项：云端逻辑是使用异步编程。也就是说，当遇到文件读写请求，网络请求等IO操作时，代码不等待IO操作返回结果就执行后面的语句,当接收到IO操作的返回结果后才调用回调函数。  当使用php，java等非异步编程语言时，如果需要插入数据后再查找数据，可用类似下面的代码：      db- insert(xxxxx);\n    db- find(xxxxx);                                                   在同步型的编程语言中，find和insert都是数据库的操作，有文件读写的IO操作，在db- find执行前，能确保db- insert已经执行完毕了。  在异步编程中，用类似下面的代码才能保证执行完db.insert后才执行：      db.insert({xxx},function(xxx){\n        db.find({xxx},function(xxx){xxxx});\n    });  只有通过在db.insert的回调函数中执行db.find，才能保证执行db.find前db.insert的数据库操作已经完成。  举个生活中的例子说明异步编程。在饭馆里，服务员接待客人一般是这样的：   服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员在旁边一直等待，当客户点菜后，服务员把订单交给厨房后继续干别的事情。   采用异步模式的服务员可以这样接待客人：   服务员指引客人就座，把菜单递给客人，在客人浏览菜单时服务员就去干别的事情。当客户决定点菜后，客人把服务员招来，服务员把客人下的订单交给厨房后继续干别的事情。   在服务员接待客人的行为中，通过比较普通的做法和异步的做法，能发现采用异步的方法后服务员的效率大大提高，云端逻辑使用异步也是基于同样的理由，当云端逻辑在等待IO操作（文件读写请求，网络请求）的结果时是一直空闲，如果不等待IO的结果继续执行下面的语句，能大大提高系统的效率。  在云端逻辑异步编程中“function(xxx){xxxx}”部分称为回调函数，云端逻辑会把IO操作的返回结果封装后传入到function函数执行里面的逻辑。      db.insert({xxx},function(xxx){xxxx});", 
            "title": "云端逻辑操作数据库初步入门"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_8", 
            "text": "在本节中，通过bmob云端逻辑开发微信公众平台，实现一个反馈意见收集的功能：\n1.把订阅者发送到公众号后台的反馈意见存储在上一节在bmob中创建的表“message”中。\n2.订阅者提交反馈意见后，公众号自动给订阅者发送消息，表示消息已收到。", 
            "title": "微信公众平台的开发"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_9", 
            "text": "创建一个名为\"feedback\"的云端逻辑用于实现上面的功能，代码如下：  \nfunction onRequest(request, response, modules) {\n    var token =  weixin ;         //这里的值必须与在微信公众号后台填入的token值一致\n    var crypto = modules.oCrypto; //使用加解密模块\n    var httptype = modules.oHttptype;　//获取调用云端逻辑的是post或者get方式\n    var xml2js = modules.oXml2js;　//实现xml和js格式之间的相互转换\n    var db = modules.oData;         //数据库对象\n    if ( get  == httptype) {\n        　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end( Unauthorized );\n          }\n    } else {\n           //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n               table : message ,             //表名\n               data :{ userId :request.body.xml.FromUserName, content :request.body.xml.Content}           \n            },function(err,data){                        \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });\n\n\n\n    }\n}                                                                           这个云端逻辑的内容暂时看不懂没关系，下面会逐渐解释其中的含义。", 
            "title": "创建云端逻辑"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_10", 
            "text": "只有启用微信公众号的开发模式后，才能把订阅者发送到微信公众号后台的消息发送到bmob云端逻辑中进行处理。  微信公众平台地址： https://mp.weixin.qq.com   登录微信公众平台后台，在左侧列表中最下方，找到“开发者中心”，点击进入，如图19所示：   进入服云端逻辑务器配置填写框，如图20所示：   点击“修改配置”按钮，如图21所示：   此处的URL（http://cloudweixinopen.bmob.cn/a12af19a1b8bf434/feedback）为上节中生成的云端逻辑“feedback”的调用，按照云端逻辑的调用规格，a12af19a1b8bf434为该应用的Secret Key，标明调用的是哪个应用，feedback为云端逻辑的名称。Token定义为weixin。EncodingAESKey则不用填，点击“随机生成”让自动生成一个，消息加解密方式选择“明文模式”，然后点击“提交”按钮，如图22所示：   在弹出框中点击确定，如图24所示：   成功启用后如图25所示：   恭喜，你成功启用开发模式。  用户往该公众号发送消息后，用户收到的反馈内容如图27所示：   查看应用的后台，可看到接收的消息已存储在表message中，如图28所示：", 
            "title": "启用微信公众号的开发模式"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_11", 
            "text": "云端逻辑开发微信公众号有两个重要原理一定要弄明白：   变为开发模式时，微信公众号后台往配置的url发送校验请求，这个过程云端逻辑校验信息的原理。  云端逻辑收发微信公众号后台传递过来的消息的原理。", 
            "title": "数据收发原理及消息数据格式"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_12", 
            "text": "在开发者首次提交验证申请时，微信公众号后台将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（signature）的效验来判断此条消息的真实性。  这4个参数的含义如下：   signature：微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。  timestamp：时间戳。  nonce：随机数  echostr：随机字符串   此后，每次开发者接收用户消息的时候，微信公众号后台也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。  开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信公众号后台，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。  消息校验流程如下：   将token、timestamp、nonce三个参数进行字典序排序。  将三个参数字符串拼接成一个字符串进行sha1加密。  开发者获得加密后的字符串可与signature对比，标识该请求来源于微信。   整个流程如图26所示：   使用的云端逻辑如下：          　//是get方法,则是微信验证回调的url是否有效\n          var oriStr = [token, request.query.timestamp, request.query.nonce].sort().join('')\n          var code = crypto.createHash('sha1').update(oriStr).digest('hex');\n          if (code == request.query.signature) {　//验证通过，输出\n              response.end(request.query.echostr);\n          } else {\n              response.end( Unauthorized );\n          }  其中token的值是在微信公众号后台填入的token值：“weixin”。  在这个校验流程的云端逻辑中，使用oCrypto这个云端逻辑的加密对象模块，提供md5和sha1两种加密算法。通过这个模块，按照微信校验的流程完成校验。oCrypto更多的功能详细参考：https://www.npmjs.org/package/crypto  另外，云端逻辑使用了oHttptype模块获取当前的http调用方式。因为微信公众平台调用云端逻辑有两种方式：   get方式，用于检验。  post方式，用于转发订阅者往公众平台发送的消息。   通过oHttptype模块得知是用采用get方式调用云端逻辑，运行校验的代码并返回echostr参数。", 
            "title": "变为开发模式时的消息校验原理"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_13", 
            "text": "在上一节的演示中，订阅者往该公众号发送消息后，返回已收到反馈内容的消息。  这一原理的消息流程如图29所示：   云端逻辑内部通过下面的代码处理用户发送的消息：             //是post,接收定阅者发送过来的消息后返回，把反馈意见存储表“message”中。\n            db.insert({\n               table : message ,             //表名\n               data :{ userId :request.body.xml.FromUserName, content :request.body.xml.Content}           \n            },function(err,data){         \n              //构造公众号后台所需要的xml格式，并返回给公众号后台  \n               var result = {\n                    xml: {\n                      ToUserName: request.body.xml.FromUserName,\n                      FromUserName: request.body.xml.ToUserName ,\n                      CreateTime: new Date().getTime(),\n                      MsgType: 'text',\n                      Content: '你好，你发送的反馈内容「' + request.body.xml.Content + '」已收到。'\n                    }\n                }\n                var builder = new xml2js.Builder();\n                var xml = builder.buildObject(result); //利用模块xml2js，把json对象转换为一个xml文本\n                response.set('Content-Type', 'text/xml'); //设置返回的http header\n                response.end(xml);\n            });  从上图可以看出，用户在发送一个文本后，微信公众号后台将组装一个xml消息发送给云端逻辑服务器。当云端逻辑接收到http头部Content-Type为text/xml的请求后，云端逻辑自动把xml消息转换为一个对象放在request.body.xml中，通过获取request.body.xml对应的属性就能获取xml节点的值。  云端逻辑解析xml对象，根据节点信息，把发送者(request.body.xml.FromUserName)和消息内容（request.body.xml.Content）存储在表“message”后，然后通过一定的规则组装成一个xml文本回复给微信公众号后台，微信公众号后台再回复给用户。在这个收发过程中，发送方和接收方进行了调换(ToUserName和FromUserName值互换)，收发都是以xml格式在后台进行传输的。所以掌握各种消息类型的接收回复是进行微信公众平台开发的基础！  最常见的消息类型为文本的xml格式如下：  xml  ToUserName ![CDATA[gh_b36303ca8941]] /ToUserName  FromUserName ![CDATA[oqwUds6-SG7L8t6ZBDexZvaRWnXM]] /FromUserName  CreateTime 1444464955 /CreateTime  MsgType ![CDATA[text]] /MsgType  Content ![CDATA[这个公众号不错]] /Content  MsgId 6203929742163889773 /MsgId  /xml                                              XML格式讲解：   ToUserName 消息接收方微信号，一般为公众平台账号微信号  FromUserName 消息发送方微信号  CreateTime 消息创建时间  MsgType 消息类型；文本消息为text  Content 消息内容  MsgId 消息ID号   各种类型的消息详解，请查看微信开发文档： http://mp.weixin.qq.com/wiki/14/89b871b5466b19b3efa4ada8e577d45e.html", 
            "title": "云端逻辑收发微信公众号后台传递过来的消息的原理"
        }, 
        {
            "location": "/module/cloud_code_weixin/README/index.html#_14", 
            "text": "通过本教程，你得到了以下收获：   了解bmob应用和云端逻辑的功能。  在不需要搭建服务器，不需要懂得基本的运维知识下，使用bmob云端逻辑在30分钟内实现微信公众平台的开发，完了消息存储和消息自动回复这两个功能。   阅读本教程后，想了解云后端服务bmob可以实现哪些更酷的功能吗？点击 http://www.bmob.cn ，立刻进入bmob了解更多。", 
            "title": "总结"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html", 
            "text": "好的编码规范是攻城师们要遵循的法则，Bmob云端逻辑希望大家能够养成良好的编码规范。Nodejs的编码规范与其他语言稍微有所不同，这里列举有所区别的地方。\n\n\n关于缩进\n\n\n缩进，2个space，tab要转为2 space。这是Nodejs源码和module采用的标准，希望大家入乡随俗。\n\n\n关于空格\n\n\nfunction关键词和函数名之间有一个空格；调用函数时，函数名和左括号之间没有空格。\n\n\n// 正确\nfunction foo(bar) {...}\nfoo(bar);\nfoo(function callback(err, data) {...});\nfoo(function (err, data) {...});\n\n// 错误\nfunction foo (bar) {...}\nfoo (bar);\nfoo(function callback (err, data) {...});\nfoo(function(err, data) {...});\n\n\n\n\n所有其他语法元素与左括号之间，都有一个空格。\n\n\n// 正确\nreturn (a + b);\nif (a === 0) {...}\nfor (var k in map) {...}\nwhile (i \n 0) {...}\n\n// 错误\nreturn(a + b);\nif(a === 0) {...}\nfor(var k in map) {...}\nwhile(i \n 0) {...}\n\n\n\n\n操作符号与参数之间有一个空格；能提高阅读性的空格不能省略。\n\n\n// 正确\nvar a = 1 + 2;\nfor (var i = 0, l = items.length; i \n l; i++) {...}\n\n//错误\nvar a=1+2;\nfor(var i=0,l=items.length;i\nl;i++){...}\n\n\n\n\n关于命名\n\n\n好的变量与函数命名，可以避免大量的注释。Nodejs推荐使用驼峰式命名：\n\n\n函数和变量：functionNamesLikeThis, variableNamesLikeThis\n类名和枚举类型：ClassNamesLikeThis, EnumNamesLikeThis\n类方法：methodNamesLikeThis\n常量：SYMBOLIC_CONSTANTS_LIKE_THIS\n\n\n\n关于双等号\n\n\n开发的时候大家请慎重使用==号，有时候结果未必会是您想的那样，请看下面的调试计算结果：\n\n\n 0 == ''\ntrue\n\n 1 == true\ntrue\n\n 2 == true\nfalse\n\n 0 == '0'\ntrue\n\n false == 'false'\nfalse\n\n false == '0'\ntrue\n\n \" \\t\\r\\n \" == 0\ntrue\n\n\n\n关于双引号\n\n\n使用string时，用单引号替代双引号（写JSON时除外）。\n\n\n//正确\nvar foo = 'bar';\n\n//错误\nvar foo = \nbar\n;\n\n\n\n\n关于大括号位置\n\n\n//正确\nif (true) {\n  response.end('winning');\n}\n//错误\nif (true)\n{\n  response.end ('losing');\n}\n\n\n\n\n关于字面表达式的问题\n\n\n使用字面表达式，用 '{}' ,'[]' 代替 new Array ，new Object，不要使用 string，bool，number 的对象类型，即不要调用 new String ，new Boolean ，new Number。 \n\n\nObject和Array创建时的逗号问题\n\n\nObject ，Array 创建，当有多个元素时，注意分行排列时逗号的位置。\n\n\n//正确\nvar a = ['hello', 'world'];\nvar b = {\n  good: 'code',\n  'is generally': 'pretty',\n};\n\n//错误\nvar a = [\n  'hello', 'world'\n];\nvar b = {\ngood\n: 'code'\n  , is generally: 'pretty'\n};\n\n\n\n\n避免使用with与eval\n\n\n关于for-in循环\n\n\nfor-in 循环，仅在 object/hash/map 时使用，绝不要对Array 使用。\n\n\n关于Array数组的问题\n\n\n不要把Array 当做关联数组或Object 使用,即你不应该用非数字作为Array 的索引（有PHP开发经验的朋友尤其注意这点）。\n\n\n//正确\nvar a = {};\na.hello = 'shit';\na.foo = 'bar';\n\n//错误\nvar a = []; // use '{}' instead\na['hello'] = 'shit';\na['foo'] = 'bar';\n\n\n\n\n关于变量声明\n\n\n变量声明时，应该每行声明一个，不应该都写在一行。\n\n\n//正确\nvar name = 'bmob';\nvar website = 'www.bmob.cn';\n\n//错误\nvar name = 'bmob'\n  ,website = 'www.bmob.cn'; \n\n\n\n\n注释规范\n\n\n注释的规范如下所示：\n\n\n/**\n * 获取文章列表\n * @param {number} num 文章数量.\n * @param {string|date|null} dateTime 发布时间.\n */\nvar getPosts = function (num, dateTime) {\n  // ...\n};", 
            "title": "云逻辑编写规范"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_1", 
            "text": "缩进，2个space，tab要转为2 space。这是Nodejs源码和module采用的标准，希望大家入乡随俗。", 
            "title": "关于缩进"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_2", 
            "text": "function关键词和函数名之间有一个空格；调用函数时，函数名和左括号之间没有空格。  // 正确\nfunction foo(bar) {...}\nfoo(bar);\nfoo(function callback(err, data) {...});\nfoo(function (err, data) {...});\n\n// 错误\nfunction foo (bar) {...}\nfoo (bar);\nfoo(function callback (err, data) {...});\nfoo(function(err, data) {...});  所有其他语法元素与左括号之间，都有一个空格。  // 正确\nreturn (a + b);\nif (a === 0) {...}\nfor (var k in map) {...}\nwhile (i   0) {...}\n\n// 错误\nreturn(a + b);\nif(a === 0) {...}\nfor(var k in map) {...}\nwhile(i   0) {...}  操作符号与参数之间有一个空格；能提高阅读性的空格不能省略。  // 正确\nvar a = 1 + 2;\nfor (var i = 0, l = items.length; i   l; i++) {...}\n\n//错误\nvar a=1+2;\nfor(var i=0,l=items.length;i l;i++){...}", 
            "title": "关于空格"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_3", 
            "text": "好的变量与函数命名，可以避免大量的注释。Nodejs推荐使用驼峰式命名：  函数和变量：functionNamesLikeThis, variableNamesLikeThis\n类名和枚举类型：ClassNamesLikeThis, EnumNamesLikeThis\n类方法：methodNamesLikeThis\n常量：SYMBOLIC_CONSTANTS_LIKE_THIS", 
            "title": "关于命名"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_4", 
            "text": "开发的时候大家请慎重使用==号，有时候结果未必会是您想的那样，请看下面的调试计算结果：   0 == ''\ntrue  1 == true\ntrue  2 == true\nfalse  0 == '0'\ntrue  false == 'false'\nfalse  false == '0'\ntrue  \" \\t\\r\\n \" == 0\ntrue", 
            "title": "关于双等号"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_5", 
            "text": "使用string时，用单引号替代双引号（写JSON时除外）。  //正确\nvar foo = 'bar';\n\n//错误\nvar foo =  bar ;", 
            "title": "关于双引号"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_6", 
            "text": "//正确\nif (true) {\n  response.end('winning');\n}\n//错误\nif (true)\n{\n  response.end ('losing');\n}", 
            "title": "关于大括号位置"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_7", 
            "text": "使用字面表达式，用 '{}' ,'[]' 代替 new Array ，new Object，不要使用 string，bool，number 的对象类型，即不要调用 new String ，new Boolean ，new Number。", 
            "title": "关于字面表达式的问题"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#objectarray", 
            "text": "Object ，Array 创建，当有多个元素时，注意分行排列时逗号的位置。  //正确\nvar a = ['hello', 'world'];\nvar b = {\n  good: 'code',\n  'is generally': 'pretty',\n};\n\n//错误\nvar a = [\n  'hello', 'world'\n];\nvar b = { good : 'code'\n  , is generally: 'pretty'\n};", 
            "title": "Object和Array创建时的逗号问题"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#witheval", 
            "text": "", 
            "title": "避免使用with与eval"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#for-in", 
            "text": "for-in 循环，仅在 object/hash/map 时使用，绝不要对Array 使用。", 
            "title": "关于for-in循环"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#array", 
            "text": "不要把Array 当做关联数组或Object 使用,即你不应该用非数字作为Array 的索引（有PHP开发经验的朋友尤其注意这点）。  //正确\nvar a = {};\na.hello = 'shit';\na.foo = 'bar';\n\n//错误\nvar a = []; // use '{}' instead\na['hello'] = 'shit';\na['foo'] = 'bar';", 
            "title": "关于Array数组的问题"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_8", 
            "text": "变量声明时，应该每行声明一个，不应该都写在一行。  //正确\nvar name = 'bmob';\nvar website = 'www.bmob.cn';\n\n//错误\nvar name = 'bmob'\n  ,website = 'www.bmob.cn';", 
            "title": "关于变量声明"
        }, 
        {
            "location": "/module/cloud_code_norm/README/index.html#_9", 
            "text": "注释的规范如下所示：  /**\n * 获取文章列表\n * @param {number} num 文章数量.\n * @param {string|date|null} dateTime 发布时间.\n */\nvar getPosts = function (num, dateTime) {\n  // ...\n};", 
            "title": "注释规范"
        }, 
        {
            "location": "/module/common_problem/README/index.html", 
            "text": "常见问题\n\n\nQ:使用云端逻辑需要掌握什么语言\nA:\nJavascript\n，因为云端逻辑是用\nNodejs\n部署架构的。\n\n\n\n\nQ:云端逻辑能做什么事情\nA:云端逻辑的推出是为了给大家解决更多后端业务逻辑的问题，让大家尽可能把更多的业务逻辑挪到云端，实现更快的更新迭代。目前，云端逻辑除可以自由操作云端数据库外，还提供了\n邮件模块\n、\nHTTP模块\n和\n事件模块\n等，方便大家自由发挥。\n\n\n\n\nQ:云端逻辑能上传文件吗\nA:暂不支持。\n\n\n\n\nQ:如何调试云端逻辑\nA:\n- Bmob在Web端（当前云端逻辑的下边）为大家提供最简单的云端逻辑的调试工具。\n- 云端逻辑本地化调试工具：\nhttps://github.com/bmob/bmob-cloud-tool\n 。\n\n\n\n\nQ:云端逻辑或者android上update能否不用objectid用组合条件\nA:只能根据objectid来，在查询返回的结果集中有objectid\n\n\n\n\nQ:云端逻辑，可以把消息发给IMSDK吗\nA:目前不可以。\n\n\n\n\nQ:url转码怎么转\nA: encodeURI(url)\n\n\n\n\nQ:如何使用同步的ohttp.post请求\nA:用eventproxy\n\n\n\n\nQ:相同的代码，在Local中可以返回正确的结果，在Server中返回错误。请问如何解决？\nA:把本地的nodejs版本改成和云端一样，然后调试通过就可以了\n\n\n\n\nQ:bmob的短信服务端验证接口云端代码怎么做？要发送一个post请求\nA:使用云端代码发送http请求即可\n\n\n\n\nQ:生成新应用时云端代码没有复制到新应用\nA:可使用云端代码的本地调试工具可以运行后可以直接导入\n\n\n\n\nQ:云端代码能否实现 WebSocket ？\nA:云端代码无法使用第三方库\n\n\n\n\nQ:往表中添加基本类型的数据是调用数据库对象的insert方法，而添加关联关系对象是用add方法？？那我的表里有这两种数据类型，该怎么添加数据\nA:分别存储\n\n\n\n\nQ:保存一个Object类型字段的值为null的时候会报错\nA:保存为这样{}\n\n\n\n\nQ:如何实现一个签到的逻辑\nA:在用户表添加一个字段--签到时间，当用户发送请求的时候，更新这个签到时间，如果签到时间为今天，说明已经签到\n\n\n\n\nQ:where语句如何查询24小时之前创建的记录？\nA:查询createdAt在24小时之前的记录就可以了\n\n\n\n\nQ:删除数据库记录只能用objectId吗？不能用where条件吗\nA:只能用objectId,where条件用于查询，查询后的结果集中会有ObjectId的。\n\n\n\n\nQ:云端逻辑怎么设定where条件\nA:\n\n\nwhere\n:{\n\nupdatedAt\n:{\n\n$lt\n:{\n__type\n:\nDate\n,\niso\n:\n2014-01-29 11:33:53\n}\n}\n\n\n\n\n\n\n\nQ:在查找数据库的回调里面再查找，不能收到回调消息\n\n\ndb.find(\n{\n\ntable\n:strTableName,\n\ncount\n:1,\n\nlimit\n:0,\n},\nfunction(err1,data1)\n{ \nvar searchNum = data1; //表的总行数，用sql语句获得\nvar limitnum=1000; //默认最多返回1000条记录\nvar runcount= parseInt(searchNum/1000); \nvar strOutID = '';\n\n//分多次获取记录，因为每次只能获取1000条\nvar i = 0;\n\nfor(i = 0;i !== runcount; i++){\n\nvar skipNum= 1000*i;\nif( i==runcount ) {\nlimitnum=searchNum-skipNum;\n} else {\nlimitnum=1000;\n}\n//能执行到这里，\n//response.send('data1'); \ndb.find(\n{\n\ntable\n:strTableName,\n\ncount\n:1,\n\nlimit\n:0,\n},\nfunction(err2,data2)\n{\n//这里执行不到\nresponse.send('data2'); \n}\n);\n} \n}\n);\n\n\n\n\nA:不能这样取，只能取一次，然后再取一次，不能在里面for循环\n\n\n\n\nQ:云逻辑可以查询支付订单吗？返回订单结果和数额之类的，有相关函数吗\nA:可以使用云逻辑去调用restful接口来查询\n\n\n\n\nQ:云端代码可以实现抓取别的网页信息吗\n比如说，我客户端去请求云端代码，让云端代码实现抓取某个咨询网站的信息\nA:可以，使用云端代码的http请求抓取即可。\n\n\n\n\nQ:请问云端代码可以发送短信吗？\nA:可以通过云端代码调用restful接口来实现。\n\n\n\n\nQ:云端代码更新用户表错误\n但是最后返回的err包含错误信息\n{\"code\":206,\"message\":\"User cannot be altered without sessionToken Error.\"}\nA:必须先登录才能更新\n\n\n\n\nQ:请问云端代码怎么返回JSON数据\nA:\n\n\nvar data = { dir: 'kunhony', param: 'archive' };\nvar str = JSON.stringify(data);\nresponse.end(str);\n\n\n\n\n\n\nQ:如何在云端请求微信\nA:http://docs.bmob.cn/cloudcode/WEB/d_cloudcodeweixin/doc/index.html\n\n\n\n\nQ:Bmob中如何支持Cookie？用于将SessionID分配给浏览器\nA:不支持set-cookie的方法。\n\n\n\n\nQ:请问云端逻辑如何返回错误？\nA:如下，代码一般为这种形式，如果错误，返回response.send(err);\n\n\nfunction onRequest(request, response, modules) {\n\nvar functions = modules.oFunctions;\n\nfunctions.run({\n   \nname\n: \ntest\n,\n   \ndata\n:{\ncontent\n:\n你好\n,\naddress\n:\nguangzhou\n}\n},function(err,data){\n   //回调函数\n   if(err){\n       response.send(err);\n    }else {\n       response.send(data);\n    }\n});\n}\n\n\n\n\n\n\nQ:开发公众号可以获取微信的openid吗\nA:可以\n\n\n\n\nQ:云端代码如何进行模糊查询\nA:调用restful的模糊查询接口\n\n\n\n\nQ:云逻辑能引入第三方模块吗？如underscore\nA:不可以，如要使用第三方模块，可考虑使用窗口服务。\n\n\n\n\nQ:我有一个云端代码，客户端访问的时候查看一条数据库对象，如果不存在，则创建、返回，如果存在则直接返回。所有客户端的访问都是查看同一个对象，如何保证多个客户端同时访问的时候不会同时创建多个对象？\nA:目前这个无法做到。\n\n\n\n\nQ:bql不支持 delete语句吗\nA:目前bql只支持查询语句。\n\n\n\n\nQ:表设置了 ACL， 我想用 master key 或 用户的 token 去更新表，在云端用批量更新模块，如何传入master key 或 用户的 token ？\nA:目前不支持\n\n\n\n\nQ:云端代码怎么延迟执行一个操作\nA:目前并无该项功能\n\n\n\n\nQ:云端代码中不同的模块中经常出现相同代码 有没有办法把这些代码提取到公共区域来复用\nA:云端代码之间是可以相互调用的，具体查看云端代码云对象章节。\n\n\n\n\nQ:如何清空某个数据表？\nA:需要先将表的所有值查询下来，然后遍历去删除，具体参考文档的查询及删除对象章节\n\n\n\n\nQ:怎么在云端调用 获取短信验证码、验证短信验证码\nA:使用云端代码进行http请求，请求RESTful接口即可\n\n\n\n\nQ:云端如何自定义返回数据\nA:定义好格式后以JSON形式返回\n\n\n\n\nQ:云端代码MD5加密中文，结果怎么和PHP的不一样？\nA:编码问题，https://cnodejs.org/topic/54ad4e40ce87bace2444cc49\n\n\n\n\nQ:BMOB云端数据库导入需手动导入CSV格式，如何做到自动抓取我本地CSV文件传入云端数据库\nA:Bmob导入数据，只可以从web后台手动导入。如果你要自动从本地传入数据库的话，可以自己写代码（程序）实现，用Bmob提供的SDK或基于RestApi来插入数据到云端数据库中。\n\n\n\n\nQ:云端数据库更新需上传CSV文件，如何实现自动云端更新\nA:云端数据库与你本地数据库的结构可能会有区别，需要你针对自己的数据库特点，读取本地数据库，转换后再进行上传\n\n\n\n\nQ:用云端查询db.find，查询到表里的数据，返回的字段名也是表的列名，有没有像sql里面as的方式修改这个名字\nA:目前还没有这个功能\n\n\n\n\nQ:如果一个字段里没有值，查询后返回的内容也没有这个字段，如果才能让这个字段也出现在返回的内容里。\nA:由于后台使用的是MongoDB，是无模式的，没有初始值，因此只有显示地给该字段赋值才会有内容返回。\n\n\n\n\nQ:写云端代码的时候，只能通过objectId来查询符合条件的一行数据？我想用表中的其他字段当做查询条件怎么写?\nA:可以使用条件查询，具体查看数据库对象中的查询多条数据小节。\n\n\n\n\nQ:用skip和limit来实现分页查询的话，如果表里的数据更新的很快的话，会不会查询出重复的数据？\nA:会出现重复数据，因此，一般您在查询时可以加上限制，比如，查询第一页时的时间为A，那您可以约束查询创建时间在A之前的数据，在那之后的数据不查询，这样就不会有重复了。\n\n\n\n\nQ:该如何实现类似乐观锁的功能\nA:目前并没有提供该类型的接口\n\n\n\n\nQ:连上vpn没有数据返回\nA:可以在连上VPN时ping https://api.bmob.cn/看看能否ping通，有可能是VPN屏蔽了\n\n\n\n\nQ:云端代码中where条件怎么表示!=？\nA:您好，可以参考restful文档中的查询数据中的条件查询，大概的形式为\"type\":{\"$ne\":\"delete\"}\n\n\n\n\nQ:如何更新1000条以上的记录\nA:可以采用分页，先取1000条数据进行更新，再取1000条之后的数据接着更新\n\n\n\n\nQ:请问云端代码请求HTTP时如何获取cookies和带cookies访问？\nA:将var http = modules.oHttp；\n改成var http = modules.oHttp.defaults({jar: true});\n即可使用全局cookie，后面的链接就不需要手动输入cookie了。\n\n\n\n\nQ:JavaScript能调用云端代码吗（xx平台能调用云端代码）\nA:只要支持https请求就可以通过restful来调用云端代码，部分sdk直接封装了调用云端代码的接口，具体可以查看云端代码文档。\n\n\n\n\nQ:请问云端new Date()如何获取和createTime里面一样的时间\nA:createAt这个属性是特殊字段，为了节约HTTP流量，我们没有进行特殊字段类型处理，直接返回string类型。你在云端代码里面new Date()获取的是一样的时间，因为服务器的时间是保持一致的。至于两者的数据格式问题，你可以自行处理。\n\n\n\n\nQ:云端代码数据库可以返回多少条记录？\nA:一次最多只能返回1000次数据，如果要获取的数据大于整个数目，必须要分多次查询\n\n\n\n\nQ:云端代码只能添加方法吗\n我想在云端代码中添加一个功能模块，但是发现云端代码中的每个文件都是独立的，而且只能是方法，我想问一下能不能实现。\nA:完全可以在方法内声明方法或者类的，这个不影响，而且可以通过间接调用的方式调用其他云端代码的执行。\n\n\n\n\nQ:webstorm在本地搭好服务器，在不联网的情况下，使用ios调用运行在本地的服务端代码，能不能利用这样的方式测试？\nA:不可以，数据保存在云端，不联网无法操作数据，本地调试过程中不需要客户端的参与。\n\n\n\n\nQ:云端代码执行console.log无输出\nA:在真正的云端代码上，不支持console.log这种输出，只能使用res.end()\n\n\n\n\nQ:云端怎么实现 var wpwp = require('wpwp')('YOUR-KEY');\nA:云端代码进行了封装，无法加载非官方模块。\n\n\n\n\nQ:如何更新数据表中Date的数据\nA:\n\n\nvar userData = dataObject.results[0];\nvar checkDate = userData.checkDate.iso;\n\nvar lastDate = new Date(checkDate.toString());\nvar nowDate = new Date();\n\ndb.setHeader({\nx-bmob-session-token\n:request.body.sessionToken.toString()});\nuserData.checkDate.iso=nowDate;\ndb.updateUserByObjectId({\nobjectId\n:request.body.objectId.toString() ,data: {\ncheckDate\n:userData.checkDate,\ndiamond\n:parseInt(userData.diamond)+10}},function(err,data)\n{\n})\n\n\n\n\n\n\nQ:containedIn在云端代码里面是什么指令\nA:对应为 \nhttp://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询\n 里面的 $in 查询，你可以参考restful文档，在where条件中使用就可以了。\n\n\n\n\nQ:如何在云端代码中计算两个时间的时间差\nA:\n\n\nvar lastDate;//一定要是Date哦\nvar nowDate = new Date(data); \n\nDate.parse(nowDate) - Date.parse(lastDate)\n\n//注意：单位是毫秒级的哦\n\n\n\n\n\n\nQ:批量操作对象中 \"path\": \"/1/classes/GameScore\" ，其中的 \"/1/class/ \"是什么来的？怎么确定下来的？\nA:/1/classse/ 是系统规定的路径，其中1是系统内部的版本号，classes表示接下来要操作的是数据表。\n\n\n\n\nQ:云代码能不能实现函数递归调用\nA:可以，但要注意不能过于复杂，5s内无回调会提示超时。\n\n\n\n\nQ:我想用云端代码修改user表中的数组，要如何设置？如何先获取表中的数组呢？获取了之后又要如何用arr.addUnique更新？求示例。\nA:要修改User表中的数据需要注意：\n1、要么你有登录用户的sessionToken信息（也就是权限），这样可以修改用户信息；\n2、要么你用masterKey（也就是超级权限）来修改用户信息。\n\n\n获取表中的信息非常简单，你直接Get就可以了，获取之后，你直接用类似如下的方法解决：\n\n\nvar arr = modules.oArray;\narr.addUnique({\n\ntable\n:\n_User\n,\n\n\nobjectId\n:\nj4w2DDDT\n, //这个对应是这个用户的objectId\n\ndata\n:{\nskills\n:{\n__op\n:\nAddUnique\n,\nobjects\n:[\nflying\n,\nkungfu\n]}}\n\n},function(err,data){\n//回调函数\n});\n\n\n\n\n\n\nQ:云端代码比较复杂的时候，很难找出根本原因\n1.能否支持加入日志，通过查看日志来debug？\n2.能否有类似IDE的断点，或者是报错信息更明确一点在哪里出错？\nA:可以借助我们开发的这个云端代码本地化调试工具来调试：\nhttps://github.com/bmob/bmob-cloud-tool\n\n\n\n\nQ:对于设置了ACL为用户只读的数据，如何在云端代码里将其全部读出？\nA:使用masterKey\n云端代码设置masterkey的方法：\n\n\nfunction onRequest(request, response, modules) {\nvar db = modules.oData;\ndb.setHeader({\nX-Bmob-Master-Key\n:\n这里填写Master Key信息\n});\ndb.updateUserByObjectId({\nobjectId\n:\n这里是需要更新的用户ObjectId信息\n ,data:{\nusername\n:\n123\n}},function(err,data){\nresponse.end(\n更新成功\n);\n}); \n}\n\n\n\n\n\n\nQ:如果把代码放在云端，本地JS调用时，是否需要输入Application ID、REST API Key才能进行调用呢？\nA:只需要在初始化js sdk的时候传人Application ID、REST API Key就行了，在js调用云端代码的时候不需要传入\n\n\n\n\nQ:云端代码里如何获取当前时间\nA:云端代码是运行在nodejs的环境中，所以js的函数能用在云端代码上。\n获取时间： var now = new Date();\n\n\n\n\nQ:调用云端代码，能否获取调用者的真实IP,想用IP来做排行榜的地理位置统计\nA:云端代码打印headers\n\n\nfunction onRequest(request, response, modules) {\nresponse.send(request.headers);\n} \n\n\n\n\n结果：\n\n\nResponse Body\n{\n\ncode\n: 200,\n\nmsg\n:\n{\n\nx-real-ip\n: \n114.114.114.114\n,\n\nx-forwarded-for\n: \n114.114.114.114\n,\n\nhost\n: \ncloud.bmob.cn\n,\n\nx-nginx-proxy\n: \ntrue\n,\n\nconnection\n: \nclose\n,\n\naccept\n: \n/\n,\n\na\n: \n,\n\ncontent-length\n: \n7\n,\n\ncontent-type\n: \napplication/x-www-form-urlencoded\n\n}\n}\n\n\n\n\nx-real-ip就是用户的真实ip的\n\n\n\n\nQ:请问怎么查询用户当前排名\n比如:我有个GameScore 表 \n字段有:username,score\n现在排行榜里面数据有5000多条，我知道某个用户objectId，如果快速找出排名位置呢？\nA:解决方案：\n根据order排名，把所有排名按次序放到一个数组中，然后根据objectId查找到某个用户名，用户名在这个数组中的位置即是他的排名。 \nRestAPI查询条件如下：\n第一步：先查询到某个用户的用户名：\n\n\ncurl -X GET \\\n-H \nX-Bmob-Application-Id: Your Application ID\n \\\n-H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n-G \\\n--data-urlencode 'keys=username' \\\nhttps://api.bmob.cn/1/users/某个用户的objectId\n\n\n\n\n第二步：score降序获取前1000名的用户的用户名：\n\n\ncurl -X GET \\\n-H \nX-Bmob-Application-Id: Your Application ID\n \\\n-H \nX-Bmob-REST-API-Key: Your REST API Key\n \\\n-G \\\n--data-urlencode 'keys=username\norder=-score\ncount=true\nlimit=1000\nskip=0' \\\nhttps://api.bmob.cn/1/classes/GameScore\n\n\n\n\n返回前1000名的用户名，判断前一个查询的用户名是否在这个数组的哪个位置，如果没有找到，继续第二步, skip设为1000，直到找到为止。\n\n\n优化方案：\nGameScore应该添加Pointer类型指向某个用户，然后在GameScore添加一个排名的列，更新score的时候更新排名，这样就可以直接根据用户的objectId一条查询就出来了。", 
            "title": "常见问题"
        }, 
        {
            "location": "/module/common_problem/README/index.html#_1", 
            "text": "Q:使用云端逻辑需要掌握什么语言\nA: Javascript ，因为云端逻辑是用 Nodejs 部署架构的。   Q:云端逻辑能做什么事情\nA:云端逻辑的推出是为了给大家解决更多后端业务逻辑的问题，让大家尽可能把更多的业务逻辑挪到云端，实现更快的更新迭代。目前，云端逻辑除可以自由操作云端数据库外，还提供了 邮件模块 、 HTTP模块 和 事件模块 等，方便大家自由发挥。   Q:云端逻辑能上传文件吗\nA:暂不支持。   Q:如何调试云端逻辑\nA:\n- Bmob在Web端（当前云端逻辑的下边）为大家提供最简单的云端逻辑的调试工具。\n- 云端逻辑本地化调试工具： https://github.com/bmob/bmob-cloud-tool  。   Q:云端逻辑或者android上update能否不用objectid用组合条件\nA:只能根据objectid来，在查询返回的结果集中有objectid   Q:云端逻辑，可以把消息发给IMSDK吗\nA:目前不可以。   Q:url转码怎么转\nA: encodeURI(url)   Q:如何使用同步的ohttp.post请求\nA:用eventproxy   Q:相同的代码，在Local中可以返回正确的结果，在Server中返回错误。请问如何解决？\nA:把本地的nodejs版本改成和云端一样，然后调试通过就可以了   Q:bmob的短信服务端验证接口云端代码怎么做？要发送一个post请求\nA:使用云端代码发送http请求即可   Q:生成新应用时云端代码没有复制到新应用\nA:可使用云端代码的本地调试工具可以运行后可以直接导入   Q:云端代码能否实现 WebSocket ？\nA:云端代码无法使用第三方库   Q:往表中添加基本类型的数据是调用数据库对象的insert方法，而添加关联关系对象是用add方法？？那我的表里有这两种数据类型，该怎么添加数据\nA:分别存储   Q:保存一个Object类型字段的值为null的时候会报错\nA:保存为这样{}   Q:如何实现一个签到的逻辑\nA:在用户表添加一个字段--签到时间，当用户发送请求的时候，更新这个签到时间，如果签到时间为今天，说明已经签到   Q:where语句如何查询24小时之前创建的记录？\nA:查询createdAt在24小时之前的记录就可以了   Q:删除数据库记录只能用objectId吗？不能用where条件吗\nA:只能用objectId,where条件用于查询，查询后的结果集中会有ObjectId的。   Q:云端逻辑怎么设定where条件\nA:  where :{ updatedAt :{ $lt :{ __type : Date , iso : 2014-01-29 11:33:53 }\n}   Q:在查找数据库的回调里面再查找，不能收到回调消息  db.find(\n{ table :strTableName, count :1, limit :0,\n},\nfunction(err1,data1)\n{ \nvar searchNum = data1; //表的总行数，用sql语句获得\nvar limitnum=1000; //默认最多返回1000条记录\nvar runcount= parseInt(searchNum/1000); \nvar strOutID = '';\n\n//分多次获取记录，因为每次只能获取1000条\nvar i = 0;\n\nfor(i = 0;i !== runcount; i++){\n\nvar skipNum= 1000*i;\nif( i==runcount ) {\nlimitnum=searchNum-skipNum;\n} else {\nlimitnum=1000;\n}\n//能执行到这里，\n//response.send('data1'); \ndb.find(\n{ table :strTableName, count :1, limit :0,\n},\nfunction(err2,data2)\n{\n//这里执行不到\nresponse.send('data2'); \n}\n);\n} \n}\n);  A:不能这样取，只能取一次，然后再取一次，不能在里面for循环   Q:云逻辑可以查询支付订单吗？返回订单结果和数额之类的，有相关函数吗\nA:可以使用云逻辑去调用restful接口来查询   Q:云端代码可以实现抓取别的网页信息吗\n比如说，我客户端去请求云端代码，让云端代码实现抓取某个咨询网站的信息\nA:可以，使用云端代码的http请求抓取即可。   Q:请问云端代码可以发送短信吗？\nA:可以通过云端代码调用restful接口来实现。   Q:云端代码更新用户表错误\n但是最后返回的err包含错误信息\n{\"code\":206,\"message\":\"User cannot be altered without sessionToken Error.\"}\nA:必须先登录才能更新   Q:请问云端代码怎么返回JSON数据\nA:  var data = { dir: 'kunhony', param: 'archive' };\nvar str = JSON.stringify(data);\nresponse.end(str);   Q:如何在云端请求微信\nA:http://docs.bmob.cn/cloudcode/WEB/d_cloudcodeweixin/doc/index.html   Q:Bmob中如何支持Cookie？用于将SessionID分配给浏览器\nA:不支持set-cookie的方法。   Q:请问云端逻辑如何返回错误？\nA:如下，代码一般为这种形式，如果错误，返回response.send(err);  function onRequest(request, response, modules) {\n\nvar functions = modules.oFunctions;\n\nfunctions.run({\n    name :  test ,\n    data :{ content : 你好 , address : guangzhou }\n},function(err,data){\n   //回调函数\n   if(err){\n       response.send(err);\n    }else {\n       response.send(data);\n    }\n});\n}   Q:开发公众号可以获取微信的openid吗\nA:可以   Q:云端代码如何进行模糊查询\nA:调用restful的模糊查询接口   Q:云逻辑能引入第三方模块吗？如underscore\nA:不可以，如要使用第三方模块，可考虑使用窗口服务。   Q:我有一个云端代码，客户端访问的时候查看一条数据库对象，如果不存在，则创建、返回，如果存在则直接返回。所有客户端的访问都是查看同一个对象，如何保证多个客户端同时访问的时候不会同时创建多个对象？\nA:目前这个无法做到。   Q:bql不支持 delete语句吗\nA:目前bql只支持查询语句。   Q:表设置了 ACL， 我想用 master key 或 用户的 token 去更新表，在云端用批量更新模块，如何传入master key 或 用户的 token ？\nA:目前不支持   Q:云端代码怎么延迟执行一个操作\nA:目前并无该项功能   Q:云端代码中不同的模块中经常出现相同代码 有没有办法把这些代码提取到公共区域来复用\nA:云端代码之间是可以相互调用的，具体查看云端代码云对象章节。   Q:如何清空某个数据表？\nA:需要先将表的所有值查询下来，然后遍历去删除，具体参考文档的查询及删除对象章节   Q:怎么在云端调用 获取短信验证码、验证短信验证码\nA:使用云端代码进行http请求，请求RESTful接口即可   Q:云端如何自定义返回数据\nA:定义好格式后以JSON形式返回   Q:云端代码MD5加密中文，结果怎么和PHP的不一样？\nA:编码问题，https://cnodejs.org/topic/54ad4e40ce87bace2444cc49   Q:BMOB云端数据库导入需手动导入CSV格式，如何做到自动抓取我本地CSV文件传入云端数据库\nA:Bmob导入数据，只可以从web后台手动导入。如果你要自动从本地传入数据库的话，可以自己写代码（程序）实现，用Bmob提供的SDK或基于RestApi来插入数据到云端数据库中。   Q:云端数据库更新需上传CSV文件，如何实现自动云端更新\nA:云端数据库与你本地数据库的结构可能会有区别，需要你针对自己的数据库特点，读取本地数据库，转换后再进行上传   Q:用云端查询db.find，查询到表里的数据，返回的字段名也是表的列名，有没有像sql里面as的方式修改这个名字\nA:目前还没有这个功能   Q:如果一个字段里没有值，查询后返回的内容也没有这个字段，如果才能让这个字段也出现在返回的内容里。\nA:由于后台使用的是MongoDB，是无模式的，没有初始值，因此只有显示地给该字段赋值才会有内容返回。   Q:写云端代码的时候，只能通过objectId来查询符合条件的一行数据？我想用表中的其他字段当做查询条件怎么写?\nA:可以使用条件查询，具体查看数据库对象中的查询多条数据小节。   Q:用skip和limit来实现分页查询的话，如果表里的数据更新的很快的话，会不会查询出重复的数据？\nA:会出现重复数据，因此，一般您在查询时可以加上限制，比如，查询第一页时的时间为A，那您可以约束查询创建时间在A之前的数据，在那之后的数据不查询，这样就不会有重复了。   Q:该如何实现类似乐观锁的功能\nA:目前并没有提供该类型的接口   Q:连上vpn没有数据返回\nA:可以在连上VPN时ping https://api.bmob.cn/看看能否ping通，有可能是VPN屏蔽了   Q:云端代码中where条件怎么表示!=？\nA:您好，可以参考restful文档中的查询数据中的条件查询，大概的形式为\"type\":{\"$ne\":\"delete\"}   Q:如何更新1000条以上的记录\nA:可以采用分页，先取1000条数据进行更新，再取1000条之后的数据接着更新   Q:请问云端代码请求HTTP时如何获取cookies和带cookies访问？\nA:将var http = modules.oHttp；\n改成var http = modules.oHttp.defaults({jar: true});\n即可使用全局cookie，后面的链接就不需要手动输入cookie了。   Q:JavaScript能调用云端代码吗（xx平台能调用云端代码）\nA:只要支持https请求就可以通过restful来调用云端代码，部分sdk直接封装了调用云端代码的接口，具体可以查看云端代码文档。   Q:请问云端new Date()如何获取和createTime里面一样的时间\nA:createAt这个属性是特殊字段，为了节约HTTP流量，我们没有进行特殊字段类型处理，直接返回string类型。你在云端代码里面new Date()获取的是一样的时间，因为服务器的时间是保持一致的。至于两者的数据格式问题，你可以自行处理。   Q:云端代码数据库可以返回多少条记录？\nA:一次最多只能返回1000次数据，如果要获取的数据大于整个数目，必须要分多次查询   Q:云端代码只能添加方法吗\n我想在云端代码中添加一个功能模块，但是发现云端代码中的每个文件都是独立的，而且只能是方法，我想问一下能不能实现。\nA:完全可以在方法内声明方法或者类的，这个不影响，而且可以通过间接调用的方式调用其他云端代码的执行。   Q:webstorm在本地搭好服务器，在不联网的情况下，使用ios调用运行在本地的服务端代码，能不能利用这样的方式测试？\nA:不可以，数据保存在云端，不联网无法操作数据，本地调试过程中不需要客户端的参与。   Q:云端代码执行console.log无输出\nA:在真正的云端代码上，不支持console.log这种输出，只能使用res.end()   Q:云端怎么实现 var wpwp = require('wpwp')('YOUR-KEY');\nA:云端代码进行了封装，无法加载非官方模块。   Q:如何更新数据表中Date的数据\nA:  var userData = dataObject.results[0];\nvar checkDate = userData.checkDate.iso;\n\nvar lastDate = new Date(checkDate.toString());\nvar nowDate = new Date();\n\ndb.setHeader({ x-bmob-session-token :request.body.sessionToken.toString()});\nuserData.checkDate.iso=nowDate;\ndb.updateUserByObjectId({ objectId :request.body.objectId.toString() ,data: { checkDate :userData.checkDate, diamond :parseInt(userData.diamond)+10}},function(err,data)\n{\n})   Q:containedIn在云端代码里面是什么指令\nA:对应为  http://docs.bmob.cn/data/Restful/b_developdoc/doc/index.html#查询  里面的 $in 查询，你可以参考restful文档，在where条件中使用就可以了。   Q:如何在云端代码中计算两个时间的时间差\nA:  var lastDate;//一定要是Date哦\nvar nowDate = new Date(data); \n\nDate.parse(nowDate) - Date.parse(lastDate)\n\n//注意：单位是毫秒级的哦   Q:批量操作对象中 \"path\": \"/1/classes/GameScore\" ，其中的 \"/1/class/ \"是什么来的？怎么确定下来的？\nA:/1/classse/ 是系统规定的路径，其中1是系统内部的版本号，classes表示接下来要操作的是数据表。   Q:云代码能不能实现函数递归调用\nA:可以，但要注意不能过于复杂，5s内无回调会提示超时。   Q:我想用云端代码修改user表中的数组，要如何设置？如何先获取表中的数组呢？获取了之后又要如何用arr.addUnique更新？求示例。\nA:要修改User表中的数据需要注意：\n1、要么你有登录用户的sessionToken信息（也就是权限），这样可以修改用户信息；\n2、要么你用masterKey（也就是超级权限）来修改用户信息。  获取表中的信息非常简单，你直接Get就可以了，获取之后，你直接用类似如下的方法解决：  var arr = modules.oArray;\narr.addUnique({ table : _User , objectId : j4w2DDDT , //这个对应是这个用户的objectId data :{ skills :{ __op : AddUnique , objects :[ flying , kungfu ]}}\n\n},function(err,data){\n//回调函数\n});   Q:云端代码比较复杂的时候，很难找出根本原因\n1.能否支持加入日志，通过查看日志来debug？\n2.能否有类似IDE的断点，或者是报错信息更明确一点在哪里出错？\nA:可以借助我们开发的这个云端代码本地化调试工具来调试：\nhttps://github.com/bmob/bmob-cloud-tool   Q:对于设置了ACL为用户只读的数据，如何在云端代码里将其全部读出？\nA:使用masterKey\n云端代码设置masterkey的方法：  function onRequest(request, response, modules) {\nvar db = modules.oData;\ndb.setHeader({ X-Bmob-Master-Key : 这里填写Master Key信息 });\ndb.updateUserByObjectId({ objectId : 这里是需要更新的用户ObjectId信息  ,data:{ username : 123 }},function(err,data){\nresponse.end( 更新成功 );\n}); \n}   Q:如果把代码放在云端，本地JS调用时，是否需要输入Application ID、REST API Key才能进行调用呢？\nA:只需要在初始化js sdk的时候传人Application ID、REST API Key就行了，在js调用云端代码的时候不需要传入   Q:云端代码里如何获取当前时间\nA:云端代码是运行在nodejs的环境中，所以js的函数能用在云端代码上。\n获取时间： var now = new Date();   Q:调用云端代码，能否获取调用者的真实IP,想用IP来做排行榜的地理位置统计\nA:云端代码打印headers  function onRequest(request, response, modules) {\nresponse.send(request.headers);\n}   结果：  Response Body\n{ code : 200, msg :\n{ x-real-ip :  114.114.114.114 , x-forwarded-for :  114.114.114.114 , host :  cloud.bmob.cn , x-nginx-proxy :  true , connection :  close , accept :  / , a :  , content-length :  7 , content-type :  application/x-www-form-urlencoded \n}\n}  x-real-ip就是用户的真实ip的   Q:请问怎么查询用户当前排名\n比如:我有个GameScore 表 \n字段有:username,score\n现在排行榜里面数据有5000多条，我知道某个用户objectId，如果快速找出排名位置呢？\nA:解决方案：\n根据order排名，把所有排名按次序放到一个数组中，然后根据objectId查找到某个用户名，用户名在这个数组中的位置即是他的排名。 \nRestAPI查询条件如下：\n第一步：先查询到某个用户的用户名：  curl -X GET \\\n-H  X-Bmob-Application-Id: Your Application ID  \\\n-H  X-Bmob-REST-API-Key: Your REST API Key  \\\n-G \\\n--data-urlencode 'keys=username' \\\nhttps://api.bmob.cn/1/users/某个用户的objectId  第二步：score降序获取前1000名的用户的用户名：  curl -X GET \\\n-H  X-Bmob-Application-Id: Your Application ID  \\\n-H  X-Bmob-REST-API-Key: Your REST API Key  \\\n-G \\\n--data-urlencode 'keys=username order=-score count=true limit=1000 skip=0' \\\nhttps://api.bmob.cn/1/classes/GameScore  返回前1000名的用户名，判断前一个查询的用户名是否在这个数组的哪个位置，如果没有找到，继续第二步, skip设为1000，直到找到为止。  优化方案：\nGameScore应该添加Pointer类型指向某个用户，然后在GameScore添加一个排名的列，更新score的时候更新排名，这样就可以直接根据用户的objectId一条查询就出来了。", 
            "title": "常见问题"
        }
    ]
}